exports.id = 99;
exports.ids = [99];
exports.modules = {

/***/ 6085:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "addBasePath", ({
  enumerable: true,
  get: function get() {
    return addBasePath;
  }
}));

var _addpathprefix = __webpack_require__(1751);

var _normalizetrailingslash = __webpack_require__(6962);

var basePath =  false || "";

function addBasePath(path, required) {
  return (0, _normalizetrailingslash.normalizePathTrailingSlash)( false ? 0 : (0, _addpathprefix.addPathPrefix)(path, basePath));
}

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 4318:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "addLocale", ({
  enumerable: true,
  get: function get() {
    return addLocale;
  }
}));

var _normalizetrailingslash = __webpack_require__(6962);

var addLocale = function addLocale(path) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (false) { var _require; }

  return path;
};

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 2038:
/***/ ((module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
0 && (0);

function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: all[name]
  });
}

_export(exports, {
  PrefetchKind: function PrefetchKind() {
    return _PrefetchKind;
  },
  ACTION_REFRESH: function ACTION_REFRESH() {
    return _ACTION_REFRESH;
  },
  ACTION_NAVIGATE: function ACTION_NAVIGATE() {
    return _ACTION_NAVIGATE;
  },
  ACTION_RESTORE: function ACTION_RESTORE() {
    return _ACTION_RESTORE;
  },
  ACTION_SERVER_PATCH: function ACTION_SERVER_PATCH() {
    return _ACTION_SERVER_PATCH;
  },
  ACTION_PREFETCH: function ACTION_PREFETCH() {
    return _ACTION_PREFETCH;
  },
  ACTION_FAST_REFRESH: function ACTION_FAST_REFRESH() {
    return _ACTION_FAST_REFRESH;
  },
  ACTION_SERVER_ACTION: function ACTION_SERVER_ACTION() {
    return _ACTION_SERVER_ACTION;
  }
});

var _ACTION_REFRESH = "refresh";
var _ACTION_NAVIGATE = "navigate";
var _ACTION_RESTORE = "restore";
var _ACTION_SERVER_PATCH = "server-patch";
var _ACTION_PREFETCH = "prefetch";
var _ACTION_FAST_REFRESH = "fast-refresh";
var _ACTION_SERVER_ACTION = "server-action";

var _PrefetchKind;

(function (PrefetchKind) {
  PrefetchKind["AUTO"] = "auto";
  PrefetchKind["FULL"] = "full";
  PrefetchKind["TEMPORARY"] = "temporary";
})(_PrefetchKind || (_PrefetchKind = {}));

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 8693:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "getDomainLocale", ({
  enumerable: true,
  get: function get() {
    return getDomainLocale;
  }
}));

var _normalizetrailingslash = __webpack_require__(6962);

var basePath = (/* unused pure expression or super */ null && ( false || ""));

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {
    return false;
  }
}

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 6512:
/***/ ((module, exports, __webpack_require__) => {

"use client";
"use strict";

var _excluded = ["href", "as", "children", "prefetch", "passHref", "replace", "shallow", "scroll", "locale", "onClick", "onMouseEnter", "onTouchStart", "legacyBehavior"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function get() {
    return _default;
  }
}));

var _interop_require_default = __webpack_require__(167);

var _react = /*#__PURE__*/_interop_require_default._(__webpack_require__(6689));

var _resolvehref = __webpack_require__(7782);

var _islocalurl = __webpack_require__(1109);

var _formaturl = __webpack_require__(3938);

var _utils = __webpack_require__(9232);

var _addlocale = __webpack_require__(4318);

var _routercontext = __webpack_require__(4964);

var _approutercontext = __webpack_require__(3280);

var _useintersection = __webpack_require__(6675);

var _getdomainlocale = __webpack_require__(8693);

var _addbasepath = __webpack_require__(6085);

var _routerreducertypes = __webpack_require__(2038);

var prefetched = new Set();

function prefetch(router, href, as, options, appOptions, isAppRouter) {
  if (true) {
    return;
  } // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.


  if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {
    return;
  } // We should only dedupe requests when experimental.optimisticClientCache is
  // disabled.


  if (!options.bypassPrefetchedCheck) {
    var locale = // Let the link's locale prop override the default router locale.
    typeof options.locale !== "undefined" ? options.locale : "locale" in router ? router.locale : undefined;
    var prefetchedKey = href + "%" + as + "%" + locale; // If we've already fetched the key, then don't prefetch it again!

    if (prefetched.has(prefetchedKey)) {
      return;
    } // Mark this URL as prefetched.


    prefetched.add(prefetchedKey);
  }

  var prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options); // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  Promise.resolve(prefetchPromise)["catch"](function (err) {
    if (false) {}
  });
}

function isModifiedEvent(event) {
  var eventTarget = event.currentTarget;
  var target = eventTarget.getAttribute("target");
  return target && target !== "_self" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {
  var nodeName = e.currentTarget.nodeName; // anchors inside an svg have a lowercase nodeName

  var isAnchorNodeName = nodeName.toUpperCase() === "A";

  if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.
  !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault();

  var navigate = function navigate() {
    // If the router is an NextRouter instance it will have `beforePopState`
    var routerScroll = scroll != null ? scroll : true;

    if ("beforePopState" in router) {
      router[replace ? "replace" : "push"](href, as, {
        shallow: shallow,
        locale: locale,
        scroll: routerScroll
      });
    } else {
      router[replace ? "replace" : "push"](as || href, {
        forceOptimisticNavigation: !prefetchEnabled,
        scroll: routerScroll
      });
    }
  };

  if (isAppRouter) {
    _react["default"].startTransition(navigate);
  } else {
    navigate();
  }
}

function formatStringOrUrl(urlObjOrString) {
  if (typeof urlObjOrString === "string") {
    return urlObjOrString;
  }

  return (0, _formaturl.formatUrl)(urlObjOrString);
}
/**
 * React Component that enables client-side transitions between routes.
 */


var Link = /*#__PURE__*/_react["default"].forwardRef(function LinkComponent(props, forwardedRef) {
  var children;

  var hrefProp = props.href,
      asProp = props.as,
      childrenProp = props.children,
      _props$prefetch = props.prefetch,
      prefetchProp = _props$prefetch === void 0 ? null : _props$prefetch,
      passHref = props.passHref,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale,
      _onClick = props.onClick,
      onMouseEnterProp = props.onMouseEnter,
      onTouchStartProp = props.onTouchStart,
      _props$legacyBehavior = props.legacyBehavior,
      legacyBehavior = _props$legacyBehavior === void 0 ? true === false : _props$legacyBehavior,
      restProps = _objectWithoutProperties(props, _excluded);

  children = childrenProp;

  if (legacyBehavior && (typeof children === "string" || typeof children === "number")) {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  }

  var pagesRouter = _react["default"].useContext(_routercontext.RouterContext);

  var appRouter = _react["default"].useContext(_approutercontext.AppRouterContext);

  var router = pagesRouter != null ? pagesRouter : appRouter; // We're in the app directory if there is no pages router.

  var isAppRouter = !pagesRouter;
  var prefetchEnabled = prefetchProp !== false;
  /**
   * The possible states for prefetch are:
   * - null: this is the default "auto" mode, where we will prefetch partially if the link is in the viewport
   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially
   * - false: we will not prefetch if in the viewport at all
   */

  var appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;

  if (false) { var hasWarned, optionalProps, optionalPropsGuard, requiredProps, requiredPropsGuard, createPropError; }

  if (false) { var hasDynamicSegment, _href; }

  var _react$default$useMem = _react["default"].useMemo(function () {
    if (!pagesRouter) {
      var _resolvedHref = formatStringOrUrl(hrefProp);

      return {
        href: _resolvedHref,
        as: asProp ? formatStringOrUrl(asProp) : _resolvedHref
      };
    }

    var _ref = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref
    };
  }, [pagesRouter, hrefProp, asProp]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var previousHref = _react["default"].useRef(href);

  var previousAs = _react["default"].useRef(as); // This will return the first child, if multiple are provided it will throw an error


  var child;

  if (legacyBehavior) {
    if (false) {} else {
      child = _react["default"].Children.only(children);
    }
  } else {
    if (false) {}
  }

  var childRef = legacyBehavior ? child && _typeof(child) === "object" && child.ref : forwardedRef;

  var _ref3 = (0, _useintersection.useIntersection)({
    rootMargin: "200px"
  }),
      _ref4 = _slicedToArray(_ref3, 3),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1],
      resetVisible = _ref4[2];

  var setRef = _react["default"].useCallback(function (el) {
    // Before the link getting observed, check if visible state need to be reset
    if (previousAs.current !== as || previousHref.current !== href) {
      resetVisible();
      previousAs.current = as;
      previousHref.current = href;
    }

    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === "function") childRef(el);else if (_typeof(childRef) === "object") {
        childRef.current = el;
      }
    }
  }, [as, childRef, href, resetVisible, setIntersectionRef]); // Prefetch the URL if we haven't already and it's visible.


  _react["default"].useEffect(function () {
    // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.
    if (false) {}

    if (!router) {
      return;
    } // If we don't need to prefetch the URL, don't do prefetch.


    if (!isVisible || !prefetchEnabled) {
      return;
    } // Prefetch the URL.


    prefetch(router, href, as, {
      locale: locale
    }, {
      kind: appPrefetchKind
    }, isAppRouter);
  }, [as, href, isVisible, locale, prefetchEnabled, pagesRouter == null ? void 0 : pagesRouter.locale, router, isAppRouter, appPrefetchKind]);

  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (false) {}

      if (!legacyBehavior && typeof _onClick === "function") {
        _onClick(e);
      }

      if (legacyBehavior && child.props && typeof child.props.onClick === "function") {
        child.props.onClick(e);
      }

      if (!router) {
        return;
      }

      if (e.defaultPrevented) {
        return;
      }

      linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);
    },
    onMouseEnter: function onMouseEnter(e) {
      if (!legacyBehavior && typeof onMouseEnterProp === "function") {
        onMouseEnterProp(e);
      }

      if (legacyBehavior && child.props && typeof child.props.onMouseEnter === "function") {
        child.props.onMouseEnter(e);
      }

      if (!router) {
        return;
      }

      if ((!prefetchEnabled || false) && isAppRouter) {
        return;
      }

      prefetch(router, href, as, {
        locale: locale,
        priority: true,
        // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
        bypassPrefetchedCheck: true
      }, {
        kind: appPrefetchKind
      }, isAppRouter);
    },
    onTouchStart: function onTouchStart(e) {
      if (!legacyBehavior && typeof onTouchStartProp === "function") {
        onTouchStartProp(e);
      }

      if (legacyBehavior && child.props && typeof child.props.onTouchStart === "function") {
        child.props.onTouchStart(e);
      }

      if (!router) {
        return;
      }

      if (!prefetchEnabled && isAppRouter) {
        return;
      }

      prefetch(router, href, as, {
        locale: locale,
        priority: true,
        // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
        bypassPrefetchedCheck: true
      }, {
        kind: appPrefetchKind
      }, isAppRouter);
    }
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user.
  // If the url is absolute, we can bypass the logic to prepend the domain and locale.

  if ((0, _utils.isAbsoluteUrl)(as)) {
    childProps.href = as;
  } else if (!legacyBehavior || passHref || child.type === "a" && !("href" in child.props)) {
    var curLocale = typeof locale !== "undefined" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale; // we only render domain locales if we are currently on a domain locale
    // so that locale links are still visitable in development/preview envs

    var localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);
    childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));
  }

  return legacyBehavior ? /*#__PURE__*/_react["default"].cloneElement(child, childProps) : /*#__PURE__*/_react["default"].createElement("a", _objectSpread(_objectSpread({}, restProps), childProps), children);
});

var _default = Link;

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 6962:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "normalizePathTrailingSlash", ({
  enumerable: true,
  get: function get() {
    return normalizePathTrailingSlash;
  }
}));

var _removetrailingslash = __webpack_require__(3297);

var _parsepath = __webpack_require__(8854);

var normalizePathTrailingSlash = function normalizePathTrailingSlash(path) {
  if (!path.startsWith("/") || undefined) {
    return path;
  }

  var _ref = (0, _parsepath.parsePath)(path),
      pathname = _ref.pathname,
      query = _ref.query,
      hash = _ref.hash;

  if (false) {}

  return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
};

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 6682:
/***/ ((module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
0 && (0);

function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: all[name]
  });
}

_export(exports, {
  requestIdleCallback: function requestIdleCallback() {
    return _requestIdleCallback;
  },
  cancelIdleCallback: function cancelIdleCallback() {
    return _cancelIdleCallback;
  }
});

var _requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function (cb) {
  var start = Date.now();
  return self.setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function (id) {
  return clearTimeout(id);
};

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 6675:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "useIntersection", ({
  enumerable: true,
  get: function get() {
    return useIntersection;
  }
}));

var _react = __webpack_require__(6689);

var _requestidlecallback = __webpack_require__(6682);

var hasIntersectionObserver = typeof IntersectionObserver === "function";
var observers = new Map();
var idList = [];

function createObserver(options) {
  var id = {
    root: options.root || null,
    margin: options.rootMargin || ""
  };
  var existing = idList.find(function (obj) {
    return obj.root === id.root && obj.margin === id.margin;
  });
  var instance;

  if (existing) {
    instance = observers.get(existing);

    if (instance) {
      return instance;
    }
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  instance = {
    id: id,
    observer: observer,
    elements: elements
  };
  idList.push(id);
  observers.set(id, instance);
  return instance;
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
      var index = idList.findIndex(function (obj) {
        return obj.root === id.root && obj.margin === id.margin;
      });

      if (index > -1) {
        idList.splice(index, 1);
      }
    }
  };
}

function useIntersection(param) {
  var rootRef = param.rootRef,
      rootMargin = param.rootMargin,
      disabled = param.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;

  var _ref = (0, _react.useState)(false),
      _ref2 = _slicedToArray(_ref, 2),
      visible = _ref2[0],
      setVisible = _ref2[1];

  var elementRef = (0, _react.useRef)(null);
  var setElement = (0, _react.useCallback)(function (element) {
    elementRef.current = element;
  }, []);
  (0, _react.useEffect)(function () {
    if (hasIntersectionObserver) {
      if (isDisabled || visible) return;
      var element = elementRef.current;

      if (element && element.tagName) {
        var unobserve = observe(element, function (isVisible) {
          return isVisible && setVisible(isVisible);
        }, {
          root: rootRef == null ? void 0 : rootRef.current,
          rootMargin: rootMargin
        });
        return unobserve;
      }
    } else {
      if (!visible) {
        var idleCallback = (0, _requestidlecallback.requestIdleCallback)(function () {
          return setVisible(true);
        });
        return function () {
          return (0, _requestidlecallback.cancelIdleCallback)(idleCallback);
        };
      }
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [isDisabled, rootMargin, rootRef, visible, elementRef.current]);
  var resetVisible = (0, _react.useCallback)(function () {
    setVisible(false);
  }, []);
  return [setElement, visible, resetVisible];
}

if ((typeof exports["default"] === 'function' || _typeof(exports["default"]) === 'object' && exports["default"] !== null) && typeof exports["default"].__esModule === 'undefined') {
  Object.defineProperty(exports["default"], '__esModule', {
    value: true
  });
  Object.assign(exports["default"], exports);
  module.exports = exports["default"];
}

/***/ }),

/***/ 7578:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { return groups[name] = result[g[name]], groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;

var whatwg_url_1 = __webpack_require__(3143);

var redact_1 = __webpack_require__(6996);

Object.defineProperty(exports, "redactConnectionString", ({
  enumerable: true,
  get: function get() {
    return redact_1.redactConnectionString;
  }
}));
var DUMMY_HOSTNAME = '__this_is_a_placeholder__';

function connectionStringHasValidScheme(connectionString) {
  return connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://');
}

var HOSTS_REGEX = /*#__PURE__*/_wrapRegExp(/^([^/]+):\/\/(?:([^:@]*)(?::([^@]*))?@)?((?!:)[^/?@]*)(.*)/, {
  protocol: 1,
  username: 2,
  password: 3,
  hosts: 4,
  rest: 5
});

var CaseInsensitiveMap = /*#__PURE__*/function (_Map) {
  _inherits(CaseInsensitiveMap, _Map);

  var _super2 = _createSuper(CaseInsensitiveMap);

  function CaseInsensitiveMap() {
    _classCallCheck(this, CaseInsensitiveMap);

    return _super2.apply(this, arguments);
  }

  _createClass(CaseInsensitiveMap, [{
    key: "delete",
    value: function _delete(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "delete", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "get",
    value: function get(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "get", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "has",
    value: function has(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "has", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "set",
    value: function set(name, value) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "set", this).call(this, this._normalizeKey(name), value);
    }
  }, {
    key: "_normalizeKey",
    value: function _normalizeKey(name) {
      name = "".concat(name);

      var _iterator = _createForOfIteratorHelper(this.keys()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;

          if (key.toLowerCase() === name.toLowerCase()) {
            name = key;
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return name;
    }
  }]);

  return CaseInsensitiveMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));

function caseInsenstiveURLSearchParams(Ctor) {
  return /*#__PURE__*/function (_Ctor, _Symbol$iterator) {
    _inherits(CaseInsenstiveURLSearchParams, _Ctor);

    var _super3 = _createSuper(CaseInsenstiveURLSearchParams);

    function CaseInsenstiveURLSearchParams() {
      _classCallCheck(this, CaseInsenstiveURLSearchParams);

      return _super3.apply(this, arguments);
    }

    _createClass(CaseInsenstiveURLSearchParams, [{
      key: "append",
      value: function append(name, value) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "append", this).call(this, this._normalizeKey(name), value);
      }
    }, {
      key: "delete",
      value: function _delete(name) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "delete", this).call(this, this._normalizeKey(name));
      }
    }, {
      key: "get",
      value: function get(name) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "get", this).call(this, this._normalizeKey(name));
      }
    }, {
      key: "getAll",
      value: function getAll(name) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "getAll", this).call(this, this._normalizeKey(name));
      }
    }, {
      key: "has",
      value: function has(name) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "has", this).call(this, this._normalizeKey(name));
      }
    }, {
      key: "set",
      value: function set(name, value) {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "set", this).call(this, this._normalizeKey(name), value);
      }
    }, {
      key: "keys",
      value: function keys() {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "keys", this).call(this);
      }
    }, {
      key: "values",
      value: function values() {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "values", this).call(this);
      }
    }, {
      key: "entries",
      value: function entries() {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "entries", this).call(this);
      }
    }, {
      key: _Symbol$iterator,
      value: function value() {
        return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), Symbol.iterator, this).call(this);
      }
    }, {
      key: "_normalizeKey",
      value: function _normalizeKey(name) {
        return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
      }
    }]);

    return CaseInsenstiveURLSearchParams;
  }(Ctor, Symbol.iterator);
}

var URLWithoutHost = /*#__PURE__*/function (_whatwg_url_1$URL) {
  _inherits(URLWithoutHost, _whatwg_url_1$URL);

  var _super4 = _createSuper(URLWithoutHost);

  function URLWithoutHost() {
    _classCallCheck(this, URLWithoutHost);

    return _super4.apply(this, arguments);
  }

  return _createClass(URLWithoutHost);
}(whatwg_url_1.URL);

var MongoParseError = /*#__PURE__*/function (_Error) {
  _inherits(MongoParseError, _Error);

  var _super5 = _createSuper(MongoParseError);

  function MongoParseError() {
    _classCallCheck(this, MongoParseError);

    return _super5.apply(this, arguments);
  }

  _createClass(MongoParseError, [{
    key: "name",
    get: function get() {
      return 'MongoParseError';
    }
  }]);

  return MongoParseError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var ConnectionString = /*#__PURE__*/function (_URLWithoutHost, _Symbol$for) {
  _inherits(ConnectionString, _URLWithoutHost);

  var _super6 = _createSuper(ConnectionString);

  function ConnectionString(uri) {
    var _this2;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConnectionString);

    var _a;

    var looseValidation = options.looseValidation;

    if (!looseValidation && !connectionStringHasValidScheme(uri)) {
      throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
    }

    var match = uri.match(HOSTS_REGEX);

    if (!match) {
      throw new MongoParseError("Invalid connection string \"".concat(uri, "\""));
    }

    var _ref = (_a = match.groups) !== null && _a !== void 0 ? _a : {},
        protocol = _ref.protocol,
        username = _ref.username,
        password = _ref.password,
        hosts = _ref.hosts,
        rest = _ref.rest;

    if (!looseValidation) {
      if (!protocol || !hosts) {
        throw new MongoParseError("Protocol and host list are required in \"".concat(uri, "\""));
      }

      try {
        decodeURIComponent(username !== null && username !== void 0 ? username : '');
        decodeURIComponent(password !== null && password !== void 0 ? password : '');
      } catch (err) {
        throw new MongoParseError(err.message);
      }

      var illegalCharacters = /[:/?#[\]@]/gi;

      if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
        throw new MongoParseError("Username contains unescaped characters ".concat(username));
      }

      if (!username || !password) {
        var uriWithoutProtocol = uri.replace("".concat(protocol, "://"), '');

        if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {
          throw new MongoParseError('URI contained empty userinfo section');
        }
      }

      if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
        throw new MongoParseError('Password contains unescaped characters');
      }
    }

    var authString = '';
    if (typeof username === 'string') authString += username;
    if (typeof password === 'string') authString += ":".concat(password);
    if (authString) authString += '@';

    try {
      _this2 = _super6.call(this, "".concat(protocol.toLowerCase(), "://").concat(authString).concat(DUMMY_HOSTNAME).concat(rest));
    } catch (err) {
      if (looseValidation) {
        new ConnectionString(uri, _objectSpread(_objectSpread({}, options), {}, {
          looseValidation: false
        }));
      }

      if (typeof err.message === 'string') {
        err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
      }

      throw err;
    }

    _this2._hosts = hosts.split(',');

    if (!looseValidation) {
      if (_this2.isSRV && _this2.hosts.length !== 1) {
        throw new MongoParseError('mongodb+srv URI cannot have multiple service names');
      }

      if (_this2.isSRV && _this2.hosts.some(function (host) {
        return host.includes(':');
      })) {
        throw new MongoParseError('mongodb+srv URI cannot have port number');
      }
    }

    if (!_this2.pathname) {
      _this2.pathname = '/';
    }

    Object.setPrototypeOf(_this2.searchParams, caseInsenstiveURLSearchParams(_this2.searchParams.constructor).prototype);
    return _this2;
  }

  _createClass(ConnectionString, [{
    key: "host",
    get: function get() {
      return DUMMY_HOSTNAME;
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "hostname",
    get: function get() {
      return DUMMY_HOSTNAME;
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "port",
    get: function get() {
      return '';
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "href",
    get: function get() {
      return this.toString();
    },
    set: function set(_ignored) {
      throw new Error('Cannot set href for connection strings');
    }
  }, {
    key: "isSRV",
    get: function get() {
      return this.protocol.includes('srv');
    }
  }, {
    key: "hosts",
    get: function get() {
      return this._hosts;
    },
    set: function set(list) {
      this._hosts = list;
    }
  }, {
    key: "toString",
    value: function toString() {
      return _get(_getPrototypeOf(ConnectionString.prototype), "toString", this).call(this).replace(DUMMY_HOSTNAME, this.hosts.join(','));
    }
  }, {
    key: "clone",
    value: function clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
  }, {
    key: "redact",
    value: function redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
  }, {
    key: "typedSearchParams",
    value: function typedSearchParams() {
      var sametype =  false && 0;
      return this.searchParams;
    }
  }, {
    key: _Symbol$for,
    value: function value() {
      var href = this.href,
          origin = this.origin,
          protocol = this.protocol,
          username = this.username,
          password = this.password,
          hosts = this.hosts,
          pathname = this.pathname,
          search = this.search,
          searchParams = this.searchParams,
          hash = this.hash;
      return {
        href: href,
        origin: origin,
        protocol: protocol,
        username: username,
        password: password,
        hosts: hosts,
        pathname: pathname,
        search: search,
        searchParams: searchParams,
        hash: hash
      };
    }
  }]);

  return ConnectionString;
}(URLWithoutHost, Symbol["for"]('nodejs.util.inspect.custom'));

exports.ConnectionString = ConnectionString;

var CommaAndColonSeparatedRecord = /*#__PURE__*/function (_CaseInsensitiveMap) {
  _inherits(CommaAndColonSeparatedRecord, _CaseInsensitiveMap);

  var _super7 = _createSuper(CommaAndColonSeparatedRecord);

  function CommaAndColonSeparatedRecord(from) {
    var _this3;

    _classCallCheck(this, CommaAndColonSeparatedRecord);

    _this3 = _super7.call(this);

    var _iterator2 = _createForOfIteratorHelper((from !== null && from !== void 0 ? from : '').split(',')),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var entry = _step2.value;
        if (!entry) continue;
        var colonIndex = entry.indexOf(':');

        if (colonIndex === -1) {
          _this3.set(entry, '');
        } else {
          _this3.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return _this3;
  }

  _createClass(CommaAndColonSeparatedRecord, [{
    key: "toString",
    value: function toString() {
      return _toConsumableArray(this).map(function (entry) {
        return entry.join(':');
      }).join(',');
    }
  }]);

  return CommaAndColonSeparatedRecord;
}(CaseInsensitiveMap);

exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
exports["default"] = ConnectionString;

/***/ }),

/***/ 6996:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.redactConnectionString = exports.redactValidConnectionString = void 0;

var index_1 = __importStar(__webpack_require__(7578));

function redactValidConnectionString(inputUrl, options) {
  var _a, _b;

  var url = inputUrl.clone();
  var replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : '_credentials_';
  var redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;

  if ((url.username || url.password) && redactUsernames) {
    url.username = replacementString;
    url.password = '';
  } else if (url.password) {
    url.password = replacementString;
  }

  if (url.searchParams.has('authMechanismProperties')) {
    var props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get('authMechanismProperties'));

    if (props.get('AWS_SESSION_TOKEN')) {
      props.set('AWS_SESSION_TOKEN', replacementString);
      url.searchParams.set('authMechanismProperties', props.toString());
    }
  }

  if (url.searchParams.has('tlsCertificateKeyFilePassword')) {
    url.searchParams.set('tlsCertificateKeyFilePassword', replacementString);
  }

  if (url.searchParams.has('proxyUsername') && redactUsernames) {
    url.searchParams.set('proxyUsername', replacementString);
  }

  if (url.searchParams.has('proxyPassword')) {
    url.searchParams.set('proxyPassword', replacementString);
  }

  return url;
}

exports.redactValidConnectionString = redactValidConnectionString;

function redactConnectionString(uri, options) {
  var _a, _b;

  var replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : '<credentials>';
  var redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
  var parsed;

  try {
    parsed = new index_1["default"](uri);
  } catch (_c) {}

  if (parsed) {
    options = _objectSpread(_objectSpread({}, options), {}, {
      replacementString: '___credentials___'
    });
    return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
  }

  var R = replacementString;
  var replacements = [function (uri) {
    return uri.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, "$1".concat(R, "$3"));
  }, function (uri) {
    return uri.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, "$1".concat(R));
  }, function (uri) {
    return uri.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, "$1".concat(R));
  }, function (uri) {
    return redactUsernames ? uri.replace(/(proxyUsername=)([^&]+)/gi, "$1".concat(R)) : uri;
  }, function (uri) {
    return uri.replace(/(proxyPassword=)([^&]+)/gi, "$1".concat(R));
  }];

  for (var _i = 0, _replacements = replacements; _i < _replacements.length; _i++) {
    var replacer = _replacements[_i];
    uri = replacer(uri);
  }

  return uri;
}

exports.redactConnectionString = redactConnectionString;

/***/ }),

/***/ 2340:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Admin = void 0;

var add_user_1 = __webpack_require__(8012);

var execute_operation_1 = __webpack_require__(5756);

var list_databases_1 = __webpack_require__(333);

var remove_user_1 = __webpack_require__(9246);

var run_command_1 = __webpack_require__(6621);

var validate_collection_1 = __webpack_require__(6735);
/**
 * The **Admin** class is an internal class that allows convenient access to
 * the admin functionality and commands for MongoDB.
 *
 * **ADMIN Cannot directly be instantiated**
 * @public
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * const admin = client.db().admin();
 * const dbInfo = await admin.listDatabases();
 * for (const db of dbInfo.databases) {
 *   console.log(db.name);
 * }
 * ```
 */


var Admin = /*#__PURE__*/function () {
  /**
   * Create a new Admin instance
   * @internal
   */
  function Admin(db) {
    _classCallCheck(this, Admin);

    this.s = {
      db: db
    };
  }
  /**
   * Execute a command
   *
   * The driver will ensure the following fields are attached to the command sent to the server:
   * - `lsid` - sourced from an implicit session or options.session
   * - `$readPreference` - defaults to primary or can be configured by options.readPreference
   * - `$db` - sourced from the name of this database
   *
   * If the client has a serverApi setting:
   * - `apiVersion`
   * - `apiStrict`
   * - `apiDeprecationErrors`
   *
   * When in a transaction:
   * - `readConcern` - sourced from readConcern set on the TransactionOptions
   * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
   *
   * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
   *
   * @param command - The command to execute
   * @param options - Optional settings for the command
   */


  _createClass(Admin, [{
    key: "command",
    value: function () {
      var _command2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_command, options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunCommandOperation(this.s.db, _command, _objectSpread({
                dbName: 'admin'
              }, options))));

            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function command(_x, _x2) {
        return _command2.apply(this, arguments);
      }

      return command;
    }()
    /**
     * Retrieve the server build information
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "buildInfo",
    value: function () {
      var _buildInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.command({
                buildinfo: 1
              }, options));

            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function buildInfo(_x3) {
        return _buildInfo.apply(this, arguments);
      }

      return buildInfo;
    }()
    /**
     * Retrieve the server build information
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "serverInfo",
    value: function () {
      var _serverInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.command({
                buildinfo: 1
              }, options));

            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function serverInfo(_x4) {
        return _serverInfo.apply(this, arguments);
      }

      return serverInfo;
    }()
    /**
     * Retrieve this db's server status.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "serverStatus",
    value: function () {
      var _serverStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.command({
                serverStatus: 1
              }, options));

            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function serverStatus(_x5) {
        return _serverStatus.apply(this, arguments);
      }

      return serverStatus;
    }()
    /**
     * Ping the MongoDB server and retrieve results
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "ping",
    value: function () {
      var _ping = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this.command({
                ping: 1
              }, options));

            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function ping(_x6) {
        return _ping.apply(this, arguments);
      }

      return ping;
    }()
    /**
     * Add a user to the database
     *
     * @param username - The username for the new user
     * @param passwordOrOptions - An optional password for the new user, or the options for the command
     * @param options - Optional settings for the command
     * @deprecated Use the createUser command in `db.command()` instead.
     * @see https://www.mongodb.com/docs/manual/reference/command/createUser/
     */

  }, {
    key: "addUser",
    value: function () {
      var _addUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(username, passwordOrOptions, options) {
        var password;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              options = options != null && _typeof(options) === 'object' ? options : passwordOrOptions != null && _typeof(passwordOrOptions) === 'object' ? passwordOrOptions : undefined;
              password = typeof passwordOrOptions === 'string' ? passwordOrOptions : undefined;
              return _context6.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.db.client, new add_user_1.AddUserOperation(this.s.db, username, password, _objectSpread({
                dbName: 'admin'
              }, options))));

            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function addUser(_x7, _x8, _x9) {
        return _addUser.apply(this, arguments);
      }

      return addUser;
    }()
    /**
     * Remove a user from a database
     *
     * @param username - The username to remove
     * @param options - Optional settings for the command
     */

  }, {
    key: "removeUser",
    value: function () {
      var _removeUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(username, options) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, _objectSpread({
                dbName: 'admin'
              }, options))));

            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function removeUser(_x10, _x11) {
        return _removeUser.apply(this, arguments);
      }

      return removeUser;
    }()
    /**
     * Validate an existing collection
     *
     * @param collectionName - The name of the collection to validate.
     * @param options - Optional settings for the command
     */

  }, {
    key: "validateCollection",
    value: function () {
      var _validateCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(collectionName) {
        var options,
            _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
              return _context8.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options)));

            case 2:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function validateCollection(_x12) {
        return _validateCollection.apply(this, arguments);
      }

      return validateCollection;
    }()
    /**
     * List the available databases
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "listDatabases",
    value: function () {
      var _listDatabases = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(options) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, options)));

            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function listDatabases(_x13) {
        return _listDatabases.apply(this, arguments);
      }

      return listDatabases;
    }()
    /**
     * Get ReplicaSet status
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "replSetGetStatus",
    value: function () {
      var _replSetGetStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", this.command({
                replSetGetStatus: 1
              }, options));

            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function replSetGetStatus(_x14) {
        return _replSetGetStatus.apply(this, arguments);
      }

      return replSetGetStatus;
    }()
  }]);

  return Admin;
}();

exports.Admin = Admin;

/***/ }),

/***/ 4356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolveBSONOptions = exports.pluckBSONSerializeOptions = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSON = exports.Binary = void 0;

var bson_1 = __webpack_require__(8054);

Object.defineProperty(exports, "Binary", ({
  enumerable: true,
  get: function get() {
    return bson_1.Binary;
  }
}));
Object.defineProperty(exports, "BSON", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSON;
  }
}));
Object.defineProperty(exports, "BSONRegExp", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSONRegExp;
  }
}));
Object.defineProperty(exports, "BSONSymbol", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSONSymbol;
  }
}));
Object.defineProperty(exports, "BSONType", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSONType;
  }
}));
Object.defineProperty(exports, "calculateObjectSize", ({
  enumerable: true,
  get: function get() {
    return bson_1.calculateObjectSize;
  }
}));
Object.defineProperty(exports, "Code", ({
  enumerable: true,
  get: function get() {
    return bson_1.Code;
  }
}));
Object.defineProperty(exports, "DBRef", ({
  enumerable: true,
  get: function get() {
    return bson_1.DBRef;
  }
}));
Object.defineProperty(exports, "Decimal128", ({
  enumerable: true,
  get: function get() {
    return bson_1.Decimal128;
  }
}));
Object.defineProperty(exports, "deserialize", ({
  enumerable: true,
  get: function get() {
    return bson_1.deserialize;
  }
}));
Object.defineProperty(exports, "Double", ({
  enumerable: true,
  get: function get() {
    return bson_1.Double;
  }
}));
Object.defineProperty(exports, "Int32", ({
  enumerable: true,
  get: function get() {
    return bson_1.Int32;
  }
}));
Object.defineProperty(exports, "Long", ({
  enumerable: true,
  get: function get() {
    return bson_1.Long;
  }
}));
Object.defineProperty(exports, "MaxKey", ({
  enumerable: true,
  get: function get() {
    return bson_1.MaxKey;
  }
}));
Object.defineProperty(exports, "MinKey", ({
  enumerable: true,
  get: function get() {
    return bson_1.MinKey;
  }
}));
Object.defineProperty(exports, "ObjectId", ({
  enumerable: true,
  get: function get() {
    return bson_1.ObjectId;
  }
}));
Object.defineProperty(exports, "serialize", ({
  enumerable: true,
  get: function get() {
    return bson_1.serialize;
  }
}));
Object.defineProperty(exports, "Timestamp", ({
  enumerable: true,
  get: function get() {
    return bson_1.Timestamp;
  }
}));

function pluckBSONSerializeOptions(options) {
  var fieldsAsRaw = options.fieldsAsRaw,
      useBigInt64 = options.useBigInt64,
      promoteValues = options.promoteValues,
      promoteBuffers = options.promoteBuffers,
      promoteLongs = options.promoteLongs,
      serializeFunctions = options.serializeFunctions,
      ignoreUndefined = options.ignoreUndefined,
      bsonRegExp = options.bsonRegExp,
      raw = options.raw,
      enableUtf8Validation = options.enableUtf8Validation;
  return {
    fieldsAsRaw: fieldsAsRaw,
    useBigInt64: useBigInt64,
    promoteValues: promoteValues,
    promoteBuffers: promoteBuffers,
    promoteLongs: promoteLongs,
    serializeFunctions: serializeFunctions,
    ignoreUndefined: ignoreUndefined,
    bsonRegExp: bsonRegExp,
    raw: raw,
    enableUtf8Validation: enableUtf8Validation
  };
}

exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
/**
 * Merge the given BSONSerializeOptions, preferring options over the parent's options, and
 * substituting defaults for values not set.
 *
 * @internal
 */

function resolveBSONOptions(options, parent) {
  var _ref, _options$raw, _ref2, _options$useBigInt, _ref3, _options$promoteLongs, _ref4, _options$promoteValue, _ref5, _options$promoteBuffe, _ref6, _options$ignoreUndefi, _ref7, _options$bsonRegExp, _ref8, _options$serializeFun, _ref9, _options$fieldsAsRaw, _ref10, _options$enableUtf8Va;

  var parentOptions = parent === null || parent === void 0 ? void 0 : parent.bsonOptions;
  return {
    raw: (_ref = (_options$raw = options === null || options === void 0 ? void 0 : options.raw) !== null && _options$raw !== void 0 ? _options$raw : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.raw) !== null && _ref !== void 0 ? _ref : false,
    useBigInt64: (_ref2 = (_options$useBigInt = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _options$useBigInt !== void 0 ? _options$useBigInt : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.useBigInt64) !== null && _ref2 !== void 0 ? _ref2 : false,
    promoteLongs: (_ref3 = (_options$promoteLongs = options === null || options === void 0 ? void 0 : options.promoteLongs) !== null && _options$promoteLongs !== void 0 ? _options$promoteLongs : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteLongs) !== null && _ref3 !== void 0 ? _ref3 : true,
    promoteValues: (_ref4 = (_options$promoteValue = options === null || options === void 0 ? void 0 : options.promoteValues) !== null && _options$promoteValue !== void 0 ? _options$promoteValue : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteValues) !== null && _ref4 !== void 0 ? _ref4 : true,
    promoteBuffers: (_ref5 = (_options$promoteBuffe = options === null || options === void 0 ? void 0 : options.promoteBuffers) !== null && _options$promoteBuffe !== void 0 ? _options$promoteBuffe : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteBuffers) !== null && _ref5 !== void 0 ? _ref5 : false,
    ignoreUndefined: (_ref6 = (_options$ignoreUndefi = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _options$ignoreUndefi !== void 0 ? _options$ignoreUndefi : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.ignoreUndefined) !== null && _ref6 !== void 0 ? _ref6 : false,
    bsonRegExp: (_ref7 = (_options$bsonRegExp = options === null || options === void 0 ? void 0 : options.bsonRegExp) !== null && _options$bsonRegExp !== void 0 ? _options$bsonRegExp : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.bsonRegExp) !== null && _ref7 !== void 0 ? _ref7 : false,
    serializeFunctions: (_ref8 = (_options$serializeFun = options === null || options === void 0 ? void 0 : options.serializeFunctions) !== null && _options$serializeFun !== void 0 ? _options$serializeFun : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.serializeFunctions) !== null && _ref8 !== void 0 ? _ref8 : false,
    fieldsAsRaw: (_ref9 = (_options$fieldsAsRaw = options === null || options === void 0 ? void 0 : options.fieldsAsRaw) !== null && _options$fieldsAsRaw !== void 0 ? _options$fieldsAsRaw : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.fieldsAsRaw) !== null && _ref9 !== void 0 ? _ref9 : {},
    enableUtf8Validation: (_ref10 = (_options$enableUtf8Va = options === null || options === void 0 ? void 0 : options.enableUtf8Validation) !== null && _options$enableUtf8Va !== void 0 ? _options$enableUtf8Va : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.enableUtf8Validation) !== null && _ref10 !== void 0 ? _ref10 : true
  };
}

exports.resolveBSONOptions = resolveBSONOptions;

/***/ }),

/***/ 1419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.mergeBatchResults = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var delete_1 = __webpack_require__(4371);

var execute_operation_1 = __webpack_require__(5756);

var insert_1 = __webpack_require__(3583);

var operation_1 = __webpack_require__(4797);

var update_1 = __webpack_require__(8679);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);
/** @internal */


var kServerError = Symbol('serverError');
/** @public */

exports.BatchType = Object.freeze({
  INSERT: 1,
  UPDATE: 2,
  DELETE: 3
});
/**
 * Keeps the state of a unordered batch so we can rewrite the results
 * correctly after command execution
 *
 * @public
 */

var Batch = /*#__PURE__*/_createClass(function Batch(batchType, originalZeroIndex) {
  _classCallCheck(this, Batch);

  this.originalZeroIndex = originalZeroIndex;
  this.currentIndex = 0;
  this.originalIndexes = [];
  this.batchType = batchType;
  this.operations = [];
  this.size = 0;
  this.sizeBytes = 0;
});

exports.Batch = Batch;
/**
 * @public
 * The result of a bulk write.
 */

var BulkWriteResult = /*#__PURE__*/function () {
  /**
   * Create a new BulkWriteResult instance
   * @internal
   */
  function BulkWriteResult(bulkResult) {
    var _this$result$nInserte, _this$result$nMatched, _this$result$nModifie, _this$result$nRemoved, _this$result$upserted;

    _classCallCheck(this, BulkWriteResult);

    this.result = bulkResult;
    this.insertedCount = (_this$result$nInserte = this.result.nInserted) !== null && _this$result$nInserte !== void 0 ? _this$result$nInserte : 0;
    this.matchedCount = (_this$result$nMatched = this.result.nMatched) !== null && _this$result$nMatched !== void 0 ? _this$result$nMatched : 0;
    this.modifiedCount = (_this$result$nModifie = this.result.nModified) !== null && _this$result$nModifie !== void 0 ? _this$result$nModifie : 0;
    this.deletedCount = (_this$result$nRemoved = this.result.nRemoved) !== null && _this$result$nRemoved !== void 0 ? _this$result$nRemoved : 0;
    this.upsertedCount = (_this$result$upserted = this.result.upserted.length) !== null && _this$result$upserted !== void 0 ? _this$result$upserted : 0;
    this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
    this.insertedIds = BulkWriteResult.generateIdMap(this.result.insertedIds);
    Object.defineProperty(this, 'result', {
      value: this.result,
      enumerable: false
    });
  }
  /** Evaluates to true if the bulk operation correctly executes */


  _createClass(BulkWriteResult, [{
    key: "ok",
    get: function get() {
      return this.result.ok;
    }
    /**
     * The number of inserted documents
     * @deprecated Use insertedCount instead.
     */

  }, {
    key: "nInserted",
    get: function get() {
      return this.result.nInserted;
    }
    /**
     * Number of upserted documents
     * @deprecated User upsertedCount instead.
     */

  }, {
    key: "nUpserted",
    get: function get() {
      return this.result.nUpserted;
    }
    /**
     * Number of matched documents
     * @deprecated Use matchedCount instead.
     */

  }, {
    key: "nMatched",
    get: function get() {
      return this.result.nMatched;
    }
    /**
     * Number of documents updated physically on disk
     * @deprecated Use modifiedCount instead.
     */

  }, {
    key: "nModified",
    get: function get() {
      return this.result.nModified;
    }
    /**
     * Number of removed documents
     * @deprecated Use deletedCount instead.
     */

  }, {
    key: "nRemoved",
    get: function get() {
      return this.result.nRemoved;
    }
    /**
     * Returns an array of all inserted ids
     * @deprecated Use insertedIds instead.
     */

  }, {
    key: "getInsertedIds",
    value: function getInsertedIds() {
      return this.result.insertedIds;
    }
    /**
     * Returns an array of all upserted ids
     * @deprecated Use upsertedIds instead.
     */

  }, {
    key: "getUpsertedIds",
    value: function getUpsertedIds() {
      return this.result.upserted;
    }
    /** Returns the upserted id at the given index */

  }, {
    key: "getUpsertedIdAt",
    value: function getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    /** Returns raw internal result */

  }, {
    key: "getRawResponse",
    value: function getRawResponse() {
      return this.result;
    }
    /** Returns true if the bulk operation contains a write error */

  }, {
    key: "hasWriteErrors",
    value: function hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    /** Returns the number of write errors off the bulk operation */

  }, {
    key: "getWriteErrorCount",
    value: function getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    /** Returns a specific write error object */

  }, {
    key: "getWriteErrorAt",
    value: function getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    /** Retrieve all write errors */

  }, {
    key: "getWriteErrors",
    value: function getWriteErrors() {
      return this.result.writeErrors;
    }
    /** Retrieve the write concern error if one exists */

  }, {
    key: "getWriteConcernError",
    value: function getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        // Return the error
        return this.result.writeConcernErrors[0];
      } else {
        // Combine the errors
        var errmsg = '';

        for (var i = 0; i < this.result.writeConcernErrors.length; i++) {
          var err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg; // TODO: Something better

          if (i === 0) errmsg = errmsg + ' and ';
        }

        return new WriteConcernError({
          errmsg: errmsg,
          code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed
        });
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "BulkWriteResult(".concat(this.result, ")");
    }
  }, {
    key: "isOk",
    value: function isOk() {
      return this.result.ok === 1;
    }
  }], [{
    key: "generateIdMap",
    value: function generateIdMap(ids) {
      var idMap = {};

      var _iterator = _createForOfIteratorHelper(ids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var doc = _step.value;
          idMap[doc.index] = doc._id;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return idMap;
    }
  }]);

  return BulkWriteResult;
}();

exports.BulkWriteResult = BulkWriteResult;
/**
 * An error representing a failure by the server to apply the requested write concern to the bulk operation.
 * @public
 * @category Error
 */

var WriteConcernError = /*#__PURE__*/function () {
  function WriteConcernError(error) {
    _classCallCheck(this, WriteConcernError);

    this[kServerError] = error;
  }
  /** Write concern error code. */


  _createClass(WriteConcernError, [{
    key: "code",
    get: function get() {
      return this[kServerError].code;
    }
    /** Write concern error message. */

  }, {
    key: "errmsg",
    get: function get() {
      return this[kServerError].errmsg;
    }
    /** Write concern error info. */

  }, {
    key: "errInfo",
    get: function get() {
      return this[kServerError].errInfo;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this[kServerError];
    }
  }, {
    key: "toString",
    value: function toString() {
      return "WriteConcernError(".concat(this.errmsg, ")");
    }
  }]);

  return WriteConcernError;
}();

exports.WriteConcernError = WriteConcernError;
/**
 * An error that occurred during a BulkWrite on the server.
 * @public
 * @category Error
 */

var WriteError = /*#__PURE__*/function () {
  function WriteError(err) {
    _classCallCheck(this, WriteError);

    this.err = err;
  }
  /** WriteError code. */


  _createClass(WriteError, [{
    key: "code",
    get: function get() {
      return this.err.code;
    }
    /** WriteError original bulk operation index. */

  }, {
    key: "index",
    get: function get() {
      return this.err.index;
    }
    /** WriteError message. */

  }, {
    key: "errmsg",
    get: function get() {
      return this.err.errmsg;
    }
    /** WriteError details. */

  }, {
    key: "errInfo",
    get: function get() {
      return this.err.errInfo;
    }
    /** Returns the underlying operation that caused the error */

  }, {
    key: "getOperation",
    value: function getOperation() {
      return this.err.op;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        code: this.err.code,
        index: this.err.index,
        errmsg: this.err.errmsg,
        op: this.err.op
      };
    }
  }, {
    key: "toString",
    value: function toString() {
      return "WriteError(".concat(JSON.stringify(this.toJSON()), ")");
    }
  }]);

  return WriteError;
}();

exports.WriteError = WriteError;
/** Merges results into shared data structure */

function mergeBatchResults(batch, bulkResult, err, result) {
  // If we have an error set the result to be the err object
  if (err) {
    result = err;
  } else if (result && result.result) {
    result = result.result;
  }

  if (result == null) {
    return;
  } // Do we have a top level error stop processing and return


  if (result.ok === 0 && bulkResult.ok === 1) {
    bulkResult.ok = 0;
    var writeError = {
      index: 0,
      code: result.code || 0,
      errmsg: result.message,
      errInfo: result.errInfo,
      op: batch.operations[0]
    };
    bulkResult.writeErrors.push(new WriteError(writeError));
    return;
  } else if (result.ok === 0 && bulkResult.ok === 0) {
    return;
  } // If we have an insert Batch type


  if (isInsertBatch(batch) && result.n) {
    bulkResult.nInserted = bulkResult.nInserted + result.n;
  } // If we have an insert Batch type


  if (isDeleteBatch(batch) && result.n) {
    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
  }

  var nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes

  if (Array.isArray(result.upserted)) {
    nUpserted = result.upserted.length;

    for (var i = 0; i < result.upserted.length; i++) {
      bulkResult.upserted.push({
        index: result.upserted[i].index + batch.originalZeroIndex,
        _id: result.upserted[i]._id
      });
    }
  } else if (result.upserted) {
    nUpserted = 1;
    bulkResult.upserted.push({
      index: batch.originalZeroIndex,
      _id: result.upserted
    });
  } // If we have an update Batch type


  if (isUpdateBatch(batch) && result.n) {
    var nModified = result.nModified;
    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);

    if (typeof nModified === 'number') {
      bulkResult.nModified = bulkResult.nModified + nModified;
    } else {
      bulkResult.nModified = 0;
    }
  }

  if (Array.isArray(result.writeErrors)) {
    for (var _i2 = 0; _i2 < result.writeErrors.length; _i2++) {
      var _writeError = {
        index: batch.originalIndexes[result.writeErrors[_i2].index],
        code: result.writeErrors[_i2].code,
        errmsg: result.writeErrors[_i2].errmsg,
        errInfo: result.writeErrors[_i2].errInfo,
        op: batch.operations[result.writeErrors[_i2].index]
      };
      bulkResult.writeErrors.push(new WriteError(_writeError));
    }
  }

  if (result.writeConcernError) {
    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
  }
}

exports.mergeBatchResults = mergeBatchResults;

function executeCommands(bulkOperation, options, callback) {
  if (bulkOperation.s.batches.length === 0) {
    return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult));
  }

  var batch = bulkOperation.s.batches.shift();

  function resultHandler(err, result) {
    // Error is a driver related error not a bulk op error, return early
    if (err && 'message' in err && !(err instanceof error_1.MongoWriteConcernError)) {
      return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));
    }

    if (err instanceof error_1.MongoWriteConcernError) {
      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
    } // Merge the results together


    mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
    var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line

    executeCommands(bulkOperation, options, callback);
  }

  var finalOptions = (0, utils_1.resolveOptions)(bulkOperation, _objectSpread(_objectSpread({}, options), {}, {
    ordered: bulkOperation.isOrdered
  }));

  if (finalOptions.bypassDocumentValidation !== true) {
    delete finalOptions.bypassDocumentValidation;
  } // Set an operationIf if provided


  if (bulkOperation.operationId) {
    resultHandler.operationId = bulkOperation.operationId;
  } // Is the bypassDocumentValidation options specific


  if (bulkOperation.s.bypassDocumentValidation === true) {
    finalOptions.bypassDocumentValidation = true;
  } // Is the checkKeys option disabled


  if (bulkOperation.s.checkKeys === false) {
    finalOptions.checkKeys = false;
  }

  if (finalOptions.retryWrites) {
    if (isUpdateBatch(batch)) {
      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(function (op) {
        return op.multi;
      });
    }

    if (isDeleteBatch(batch)) {
      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(function (op) {
        return op.limit === 0;
      });
    }
  }

  try {
    if (isInsertBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    } else if (isUpdateBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    } else if (isDeleteBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    }
  } catch (err) {
    // Force top level error
    err.ok = 0; // Merge top level error and return

    mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);
    callback();
  }
}

function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
  var _err$result, _err$result2;

  mergeBatchResults(batch, bulkResult, undefined, err.result);
  callback(new MongoBulkWriteError({
    message: (_err$result = err.result) === null || _err$result === void 0 ? void 0 : _err$result.writeConcernError.errmsg,
    code: (_err$result2 = err.result) === null || _err$result2 === void 0 ? void 0 : _err$result2.writeConcernError.result
  }, new BulkWriteResult(bulkResult)));
}
/**
 * An error indicating an unsuccessful Bulk Write
 * @public
 * @category Error
 */


var MongoBulkWriteError = /*#__PURE__*/function (_error_1$MongoServerE) {
  _inherits(MongoBulkWriteError, _error_1$MongoServerE);

  var _super = _createSuper(MongoBulkWriteError);

  /** Creates a new MongoBulkWriteError */
  function MongoBulkWriteError(error, result) {
    var _this;

    _classCallCheck(this, MongoBulkWriteError);

    _this = _super.call(this, error);
    _this.writeErrors = [];
    if (error instanceof WriteConcernError) _this.err = error;else if (!(error instanceof Error)) {
      var _error$writeErrors;

      _this.message = error.message;
      _this.code = error.code;
      _this.writeErrors = (_error$writeErrors = error.writeErrors) !== null && _error$writeErrors !== void 0 ? _error$writeErrors : [];
    }
    _this.result = result;
    Object.assign(_assertThisInitialized(_this), error);
    return _this;
  }

  _createClass(MongoBulkWriteError, [{
    key: "name",
    get: function get() {
      return 'MongoBulkWriteError';
    }
    /** Number of documents inserted. */

  }, {
    key: "insertedCount",
    get: function get() {
      return this.result.insertedCount;
    }
    /** Number of documents matched for update. */

  }, {
    key: "matchedCount",
    get: function get() {
      return this.result.matchedCount;
    }
    /** Number of documents modified. */

  }, {
    key: "modifiedCount",
    get: function get() {
      return this.result.modifiedCount;
    }
    /** Number of documents deleted. */

  }, {
    key: "deletedCount",
    get: function get() {
      return this.result.deletedCount;
    }
    /** Number of documents upserted. */

  }, {
    key: "upsertedCount",
    get: function get() {
      return this.result.upsertedCount;
    }
    /** Inserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "insertedIds",
    get: function get() {
      return this.result.insertedIds;
    }
    /** Upserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "upsertedIds",
    get: function get() {
      return this.result.upsertedIds;
    }
  }]);

  return MongoBulkWriteError;
}(error_1.MongoServerError);

exports.MongoBulkWriteError = MongoBulkWriteError;
/**
 * A builder object that is returned from {@link BulkOperationBase#find}.
 * Is used to build a write operation that involves a query filter.
 *
 * @public
 */

var FindOperators = /*#__PURE__*/function () {
  /**
   * Creates a new FindOperators object.
   * @internal
   */
  function FindOperators(bulkOperation) {
    _classCallCheck(this, FindOperators);

    this.bulkOperation = bulkOperation;
  }
  /** Add a multiple update operation to the bulk operation */


  _createClass(FindOperators, [{
    key: "update",
    value: function update(updateDocument) {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: true
      })));
    }
    /** Add a single update operation to the bulk operation */

  }, {
    key: "updateOne",
    value: function updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
        throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
      }

      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: false
      })));
    }
    /** Add a replace one operation to the bulk operation */

  }, {
    key: "replaceOne",
    value: function replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
      }

      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: false
      })));
    }
    /** Add a delete one operation to the bulk operation */

  }, {
    key: "deleteOne",
    value: function deleteOne() {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, _objectSpread(_objectSpread({}, currentOp), {}, {
        limit: 1
      })));
    }
    /** Add a delete many operation to the bulk operation */

  }, {
    key: "delete",
    value: function _delete() {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, _objectSpread(_objectSpread({}, currentOp), {}, {
        limit: 0
      })));
    }
    /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */

  }, {
    key: "upsert",
    value: function upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    /** Specifies the collation for the query condition. */

  }, {
    key: "collation",
    value: function collation(_collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.collation = _collation;
      return this;
    }
    /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */

  }, {
    key: "arrayFilters",
    value: function arrayFilters(_arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.arrayFilters = _arrayFilters;
      return this;
    }
    /** Specifies hint for the bulk operation. */

  }, {
    key: "hint",
    value: function hint(_hint) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.hint = _hint;
      return this;
    }
  }]);

  return FindOperators;
}();

exports.FindOperators = FindOperators;
/**
 * TODO(NODE-4063)
 * BulkWrites merge complexity is implemented in executeCommands
 * This provides a vehicle to treat bulkOperations like any other operation (hence "shim")
 * We would like this logic to simply live inside the BulkWriteOperation class
 * @internal
 */

var BulkWriteShimOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(BulkWriteShimOperation, _operation_1$Abstract);

  var _super2 = _createSuper(BulkWriteShimOperation);

  function BulkWriteShimOperation(bulkOperation, options) {
    var _this2;

    _classCallCheck(this, BulkWriteShimOperation);

    _this2 = _super2.call(this, options);
    _this2.bulkOperation = bulkOperation;
    return _this2;
  }

  _createClass(BulkWriteShimOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      if (this.options.session == null) {
        // An implicit session could have been created by 'executeOperation'
        // So if we stick it on finalOptions here, each bulk operation
        // will use this same session, it'll be passed in the same way
        // an explicit session would be
        this.options.session = session;
      }

      return executeCommands(this.bulkOperation, this.options, callback);
    }
  }]);

  return BulkWriteShimOperation;
}(operation_1.AbstractCallbackOperation);
/** @public */


var BulkOperationBase = /*#__PURE__*/function () {
  /**
   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
   * @internal
   */
  function BulkOperationBase(collection, options, isOrdered) {
    _classCallCheck(this, BulkOperationBase);

    // determine whether bulkOperation is ordered or unordered
    this.isOrdered = isOrdered;
    var topology = (0, utils_1.getTopology)(collection);
    options = options == null ? {} : options; // TODO Bring from driver information in hello
    // Get the namespace for the write operations

    var namespace = collection.s.namespace; // Used to mark operation as executed

    var executed = false; // Current item

    var currentOp = undefined; // Set max byte size

    var hello = topology.lastHello(); // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents
    // over 2mb are still allowed

    var usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
    var maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
    var maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
    var maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000; // Calculates the largest possible size of an Array key, represented as a BSON string
    // element. This calculation:
    //     1 byte for BSON type
    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))
    //   + 1 bytes for null terminator

    var maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2; // Final options for retryable writes

    var finalOptions = Object.assign({}, options);
    finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db); // Final results

    var bulkResult = {
      ok: 1,
      writeErrors: [],
      writeConcernErrors: [],
      insertedIds: [],
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: []
    }; // Internal state

    this.s = {
      // Final result
      bulkResult: bulkResult,
      // Current batch state
      currentBatch: undefined,
      currentIndex: 0,
      // ordered specific
      currentBatchSize: 0,
      currentBatchSizeBytes: 0,
      // unordered specific
      currentInsertBatch: undefined,
      currentUpdateBatch: undefined,
      currentRemoveBatch: undefined,
      batches: [],
      // Write concern
      writeConcern: write_concern_1.WriteConcern.fromOptions(options),
      // Max batch size options
      maxBsonObjectSize: maxBsonObjectSize,
      maxBatchSizeBytes: maxBatchSizeBytes,
      maxWriteBatchSize: maxWriteBatchSize,
      maxKeySize: maxKeySize,
      // Namespace
      namespace: namespace,
      // Topology
      topology: topology,
      // Options
      options: finalOptions,
      // BSON options
      bsonOptions: (0, bson_1.resolveBSONOptions)(options),
      // Current operation
      currentOp: currentOp,
      // Executed
      executed: executed,
      // Collection
      collection: collection,
      // Fundamental error
      err: undefined,
      // check keys
      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false
    }; // bypass Validation

    if (options.bypassDocumentValidation === true) {
      this.s.bypassDocumentValidation = true;
    }
  }
  /**
   * Add a single insert document to the bulk operation
   *
   * @example
   * ```ts
   * const bulkOp = collection.initializeOrderedBulkOp();
   *
   * // Adds three inserts to the bulkOp.
   * bulkOp
   *   .insert({ a: 1 })
   *   .insert({ b: 2 })
   *   .insert({ c: 3 });
   * await bulkOp.execute();
   * ```
   */


  _createClass(BulkOperationBase, [{
    key: "insert",
    value: function insert(document) {
      if (document._id == null && !shouldForceServerObjectId(this)) {
        document._id = new bson_1.ObjectId();
      }

      return this.addToOperationsList(exports.BatchType.INSERT, document);
    }
    /**
     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
     * Returns a builder object used to complete the definition of the operation.
     *
     * @example
     * ```ts
     * const bulkOp = collection.initializeOrderedBulkOp();
     *
     * // Add an updateOne to the bulkOp
     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
     *
     * // Add an updateMany to the bulkOp
     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
     *
     * // Add an upsert
     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
     *
     * // Add a deletion
     * bulkOp.find({ g: 7 }).deleteOne();
     *
     * // Add a multi deletion
     * bulkOp.find({ h: 8 }).delete();
     *
     * // Add a replaceOne
     * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
     *
     * // Update using a pipeline (requires Mongodb 4.2 or higher)
     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
     * ]);
     *
     * // All of the ops will now be executed
     * await bulkOp.execute();
     * ```
     */

  }, {
    key: "find",
    value: function find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');
      } // Save a current selector


      this.s.currentOp = {
        selector: selector
      };
      return new FindOperators(this);
    }
    /** Specifies a raw operation to perform in the bulk write. */

  }, {
    key: "raw",
    value: function raw(op) {
      if (op == null || _typeof(op) !== 'object') {
        throw new error_1.MongoInvalidArgumentError('Operation must be an object with an operation key');
      }

      if ('insertOne' in op) {
        var forceServerObjectId = shouldForceServerObjectId(this);

        if (op.insertOne && op.insertOne.document == null) {
          // NOTE: provided for legacy support, but this is a malformed operation
          if (forceServerObjectId !== true && op.insertOne._id == null) {
            op.insertOne._id = new bson_1.ObjectId();
          }

          return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);
        }

        if (forceServerObjectId !== true && op.insertOne.document._id == null) {
          op.insertOne.document._id = new bson_1.ObjectId();
        }

        return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);
      }

      if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {
        if ('replaceOne' in op) {
          if ('q' in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, _objectSpread(_objectSpread({}, op.replaceOne), {}, {
            multi: false
          }));

          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }

        if ('updateOne' in op) {
          if ('q' in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var _updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, _objectSpread(_objectSpread({}, op.updateOne), {}, {
            multi: false
          }));

          if (!(0, utils_1.hasAtomicOperators)(_updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, _updateStatement);
        }

        if ('updateMany' in op) {
          if ('q' in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var _updateStatement2 = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, _objectSpread(_objectSpread({}, op.updateMany), {}, {
            multi: true
          }));

          if (!(0, utils_1.hasAtomicOperators)(_updateStatement2.u)) {
            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, _updateStatement2);
        }
      }

      if ('deleteOne' in op) {
        if ('q' in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
        }

        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, _objectSpread(_objectSpread({}, op.deleteOne), {}, {
          limit: 1
        })));
      }

      if ('deleteMany' in op) {
        if ('q' in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
        }

        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, _objectSpread(_objectSpread({}, op.deleteMany), {}, {
          limit: 0
        })));
      } // otherwise an unknown operation was provided


      throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "batches",
    get: function get() {
      var batches = _toConsumableArray(this.s.batches);

      if (this.isOrdered) {
        if (this.s.currentBatch) batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch) batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch) batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch) batches.push(this.s.currentRemoveBatch);
      }

      return batches;
    }
  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var options,
            writeConcern,
            finalOptions,
            operation,
            _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};

              if (!this.s.executed) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoBatchReExecutionError();

            case 3:
              writeConcern = write_concern_1.WriteConcern.fromOptions(options);

              if (writeConcern) {
                this.s.writeConcern = writeConcern;
              } // If we have current batch


              if (this.isOrdered) {
                if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);
              } else {
                if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
                if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
                if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
              } // If we have no operations in the bulk raise an error


              if (!(this.s.batches.length === 0)) {
                _context.next = 8;
                break;
              }

              throw new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');

            case 8:
              this.s.executed = true;
              finalOptions = _objectSpread(_objectSpread({}, this.s.options), options);
              operation = new BulkWriteShimOperation(this, finalOptions);
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.s.collection.client, operation));

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function execute() {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Handles the write error before executing commands
     * @internal
     */

  }, {
    key: "handleWriteError",
    value: function handleWriteError(callback, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        var msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : 'write operation failed';
        callback(new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult));
        return true;
      }

      var writeConcernError = writeResult.getWriteConcernError();

      if (writeConcernError) {
        callback(new MongoBulkWriteError(writeConcernError, writeResult));
        return true;
      }

      return false;
    }
  }]);

  return BulkOperationBase;
}();

exports.BulkOperationBase = BulkOperationBase;
Object.defineProperty(BulkOperationBase.prototype, 'length', {
  enumerable: true,
  get: function get() {
    return this.s.currentIndex;
  }
});

function shouldForceServerObjectId(bulkOperation) {
  var _bulkOperation$s$coll;

  if (typeof bulkOperation.s.options.forceServerObjectId === 'boolean') {
    return bulkOperation.s.options.forceServerObjectId;
  }

  if (typeof ((_bulkOperation$s$coll = bulkOperation.s.collection.s.db.options) === null || _bulkOperation$s$coll === void 0 ? void 0 : _bulkOperation$s$coll.forceServerObjectId) === 'boolean') {
    var _bulkOperation$s$coll2;

    return (_bulkOperation$s$coll2 = bulkOperation.s.collection.s.db.options) === null || _bulkOperation$s$coll2 === void 0 ? void 0 : _bulkOperation$s$coll2.forceServerObjectId;
  }

  return false;
}

function isInsertBatch(batch) {
  return batch.batchType === exports.BatchType.INSERT;
}

function isUpdateBatch(batch) {
  return batch.batchType === exports.BatchType.UPDATE;
}

function isDeleteBatch(batch) {
  return batch.batchType === exports.BatchType.DELETE;
}

function buildCurrentOp(bulkOp) {
  var currentOp = bulkOp.s.currentOp;
  bulkOp.s.currentOp = undefined;
  if (!currentOp) currentOp = {};
  return currentOp;
}

/***/ }),

/***/ 5873:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OrderedBulkOperation = void 0;

var BSON = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var common_1 = __webpack_require__(1419);
/** @public */


var OrderedBulkOperation = /*#__PURE__*/function (_common_1$BulkOperati) {
  _inherits(OrderedBulkOperation, _common_1$BulkOperati);

  var _super = _createSuper(OrderedBulkOperation);

  /** @internal */
  function OrderedBulkOperation(collection, options) {
    _classCallCheck(this, OrderedBulkOperation);

    return _super.call(this, collection, options, true);
  }

  _createClass(OrderedBulkOperation, [{
    key: "addToOperationsList",
    value: function addToOperationsList(batchType, document) {
      // Get the bsonSize
      var bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      }); // Throw error if the doc is bigger than the max BSON size

      if (bsonSize >= this.s.maxBsonObjectSize) // TODO(NODE-3483): Change this to MongoBSONError
        throw new error_1.MongoInvalidArgumentError("Document is larger than the maximum size ".concat(this.s.maxBsonObjectSize)); // Create a new batch object if we don't have a current one

      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }

      var maxKeySize = this.s.maxKeySize; // Check if we need to create a new batch

      if ( // New batch if we exceed the max batch op size
      this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
      // since we can't sent an empty batch
      this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
      this.s.currentBatch.batchType !== batchType) {
        // Save the batch to the execution stack
        this.s.batches.push(this.s.currentBatch); // Create a new batch

        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex); // Reset the current size trackers

        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }

      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document._id
        });
      } // We have an array of documents


      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
      }

      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }]);

  return OrderedBulkOperation;
}(common_1.BulkOperationBase);

exports.OrderedBulkOperation = OrderedBulkOperation;

/***/ }),

/***/ 2325:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnorderedBulkOperation = void 0;

var BSON = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var common_1 = __webpack_require__(1419);
/** @public */


var UnorderedBulkOperation = /*#__PURE__*/function (_common_1$BulkOperati) {
  _inherits(UnorderedBulkOperation, _common_1$BulkOperati);

  var _super = _createSuper(UnorderedBulkOperation);

  /** @internal */
  function UnorderedBulkOperation(collection, options) {
    _classCallCheck(this, UnorderedBulkOperation);

    return _super.call(this, collection, options, false);
  }

  _createClass(UnorderedBulkOperation, [{
    key: "handleWriteError",
    value: function handleWriteError(callback, writeResult) {
      if (this.s.batches.length) {
        return false;
      }

      return _get(_getPrototypeOf(UnorderedBulkOperation.prototype), "handleWriteError", this).call(this, callback, writeResult);
    }
  }, {
    key: "addToOperationsList",
    value: function addToOperationsList(batchType, document) {
      // Get the bsonSize
      var bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      }); // Throw error if the doc is bigger than the max BSON size

      if (bsonSize >= this.s.maxBsonObjectSize) {
        // TODO(NODE-3483): Change this to MongoBSONError
        throw new error_1.MongoInvalidArgumentError("Document is larger than the maximum size ".concat(this.s.maxBsonObjectSize));
      } // Holds the current batch


      this.s.currentBatch = undefined; // Get the right type of batch

      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }

      var maxKeySize = this.s.maxKeySize; // Create a new batch object if we don't have a current one

      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      } // Check if we need to create a new batch


      if ( // New batch if we exceed the max batch op size
      this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
      // since we can't sent an empty batch
      this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
      this.s.currentBatch.batchType !== batchType) {
        // Save the batch to the execution stack
        this.s.batches.push(this.s.currentBatch); // Create a new batch

        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      } // We have an array of documents


      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
      }

      this.s.currentBatch.operations.push(document);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1; // Save back the current Batch to the right type

      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      } // Update current batch size


      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }]);

  return UnorderedBulkOperation;
}(common_1.BulkOperationBase);

exports.UnorderedBulkOperation = UnorderedBulkOperation;

/***/ }),

/***/ 7944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen["return"] !== "function") { this["return"] = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChangeStream = void 0;

var collection_1 = __webpack_require__(9816);

var constants_1 = __webpack_require__(9592);

var change_stream_cursor_1 = __webpack_require__(7929);

var db_1 = __webpack_require__(8931);

var error_1 = __webpack_require__(9525);

var mongo_client_1 = __webpack_require__(3094);

var mongo_types_1 = __webpack_require__(1815);

var utils_1 = __webpack_require__(672);
/** @internal */


var kCursorStream = Symbol('cursorStream');
/** @internal */

var kClosed = Symbol('closed');
/** @internal */

var kMode = Symbol('mode');
var CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument', 'fullDocumentBeforeChange', 'showExpandedEvents'];
var CHANGE_DOMAIN_TYPES = {
  COLLECTION: Symbol('Collection'),
  DATABASE: Symbol('Database'),
  CLUSTER: Symbol('Cluster')
};
var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
var NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';
var CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';
/**
 * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.
 * @public
 */

var ChangeStream = /*#__PURE__*/function (_mongo_types_1$TypedE, _Symbol$asyncIterator) {
  _inherits(ChangeStream, _mongo_types_1$TypedE);

  var _super = _createSuper(ChangeStream);

  /**
   * @internal
   *
   * @param parent - The parent object that created this change stream
   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
   */
  function ChangeStream(parent) {
    var _this2;

    var pipeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ChangeStream);

    _this2 = _super.call(this);
    _this2.pipeline = pipeline;
    _this2.options = _objectSpread({}, options);
    delete _this2.options.writeConcern;

    if (parent instanceof collection_1.Collection) {
      _this2.type = CHANGE_DOMAIN_TYPES.COLLECTION;
    } else if (parent instanceof db_1.Db) {
      _this2.type = CHANGE_DOMAIN_TYPES.DATABASE;
    } else if (parent instanceof mongo_client_1.MongoClient) {
      _this2.type = CHANGE_DOMAIN_TYPES.CLUSTER;
    } else {
      throw new error_1.MongoChangeStreamError('Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient');
    }

    _this2.parent = parent;
    _this2.namespace = parent.s.namespace;

    if (!_this2.options.readPreference && parent.readPreference) {
      _this2.options.readPreference = parent.readPreference;
    } // Create contained Change Stream cursor


    _this2.cursor = _this2._createChangeStreamCursor(options);
    _this2[kClosed] = false;
    _this2[kMode] = false; // Listen for any `change` listeners being added to ChangeStream

    _this2.on('newListener', function (eventName) {
      if (eventName === 'change' && _this2.cursor && _this2.listenerCount('change') === 0) {
        _this2._streamEvents(_this2.cursor);
      }
    });

    _this2.on('removeListener', function (eventName) {
      if (eventName === 'change' && _this2.listenerCount('change') === 0 && _this2.cursor) {
        var _this2$kCursorStream;

        (_this2$kCursorStream = _this2[kCursorStream]) === null || _this2$kCursorStream === void 0 ? void 0 : _this2$kCursorStream.removeAllListeners('data');
      }
    });

    return _this2;
  }
  /** @internal */


  _createClass(ChangeStream, [{
    key: "cursorStream",
    get: function get() {
      return this[kCursorStream];
    }
    /** The cached resume token that is used to resume after the most recently returned change. */

  }, {
    key: "resumeToken",
    get: function get() {
      var _this$cursor;

      return (_this$cursor = this.cursor) === null || _this$cursor === void 0 ? void 0 : _this$cursor.resumeToken;
    }
    /** Check if there is any document still available in the Change Stream */

  }, {
    key: "hasNext",
    value: function () {
      var _hasNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _hasNext2;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this._setIsIterator(); // Change streams must resume indefinitely while each resume event succeeds.
              // This loop continues until either a change event is received or until a resume attempt
              // fails.
              // eslint-disable-next-line no-constant-condition


            case 1:
              if (false) {}

              _context.prev = 2;
              _context.next = 5;
              return this.cursor.hasNext();

            case 5:
              _hasNext2 = _context.sent;
              return _context.abrupt("return", _hasNext2);

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              _context.prev = 11;
              _context.next = 14;
              return this._processErrorIteratorMode(_context.t0);

            case 14:
              _context.next = 26;
              break;

            case 16:
              _context.prev = 16;
              _context.t1 = _context["catch"](11);
              _context.prev = 18;
              _context.next = 21;
              return this.close();

            case 21:
              _context.next = 25;
              break;

            case 23:
              _context.prev = 23;
              _context.t2 = _context["catch"](18);

            case 25:
              throw _context.t1;

            case 26:
              _context.next = 1;
              break;

            case 28:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 9], [11, 16], [18, 23]]);
      }));

      function hasNext() {
        return _hasNext.apply(this, arguments);
      }

      return hasNext;
    }()
    /** Get the next available document from the Change Stream. */

  }, {
    key: "next",
    value: function () {
      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var change, processedChange;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this._setIsIterator(); // Change streams must resume indefinitely while each resume event succeeds.
              // This loop continues until either a change event is received or until a resume attempt
              // fails.
              // eslint-disable-next-line no-constant-condition


            case 1:
              if (false) {}

              _context2.prev = 2;
              _context2.next = 5;
              return this.cursor.next();

            case 5:
              change = _context2.sent;
              processedChange = this._processChange(change !== null && change !== void 0 ? change : null);
              return _context2.abrupt("return", processedChange);

            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](2);
              _context2.prev = 12;
              _context2.next = 15;
              return this._processErrorIteratorMode(_context2.t0);

            case 15:
              _context2.next = 27;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t1 = _context2["catch"](12);
              _context2.prev = 19;
              _context2.next = 22;
              return this.close();

            case 22:
              _context2.next = 26;
              break;

            case 24:
              _context2.prev = 24;
              _context2.t2 = _context2["catch"](19);

            case 26:
              throw _context2.t1;

            case 27:
              _context2.next = 1;
              break;

            case 29:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[2, 10], [12, 17], [19, 24]]);
      }));

      function next() {
        return _next2.apply(this, arguments);
      }

      return next;
    }()
    /**
     * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned
     */

  }, {
    key: "tryNext",
    value: function () {
      var _tryNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var change;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this._setIsIterator(); // Change streams must resume indefinitely while each resume event succeeds.
              // This loop continues until either a change event is received or until a resume attempt
              // fails.
              // eslint-disable-next-line no-constant-condition


            case 1:
              if (false) {}

              _context3.prev = 2;
              _context3.next = 5;
              return this.cursor.tryNext();

            case 5:
              change = _context3.sent;
              return _context3.abrupt("return", change !== null && change !== void 0 ? change : null);

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](2);
              _context3.prev = 11;
              _context3.next = 14;
              return this._processErrorIteratorMode(_context3.t0);

            case 14:
              _context3.next = 26;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t1 = _context3["catch"](11);
              _context3.prev = 18;
              _context3.next = 21;
              return this.close();

            case 21:
              _context3.next = 25;
              break;

            case 23:
              _context3.prev = 23;
              _context3.t2 = _context3["catch"](18);

            case 25:
              throw _context3.t1;

            case 26:
              _context3.next = 1;
              break;

            case 28:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[2, 9], [11, 16], [18, 23]]);
      }));

      function tryNext() {
        return _tryNext.apply(this, arguments);
      }

      return tryNext;
    }()
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      var _this = this;

      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!_this.closed) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return");

            case 2:
              _context4.prev = 2;

            case 3:
              if (false) {}

              _context4.next = 6;
              return _awaitAsyncGenerator(_this.next());

            case 6:
              _context4.next = 8;
              return _context4.sent;

            case 8:
              _context4.next = 3;
              break;

            case 10:
              _context4.prev = 10;
              _context4.prev = 11;
              _context4.next = 14;
              return _awaitAsyncGenerator(_this.close());

            case 14:
              _context4.next = 18;
              break;

            case 16:
              _context4.prev = 16;
              _context4.t0 = _context4["catch"](11);

            case 18:
              return _context4.finish(10);

            case 19:
            case "end":
              return _context4.stop();
          }
        }, _callee4, null, [[2,, 10, 19], [11, 16]]);
      }))();
    }
    /** Is the cursor closed */

  }, {
    key: "closed",
    get: function get() {
      return this[kClosed] || this.cursor.closed;
    }
    /** Close the Change Stream */

  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var cursor;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              this[kClosed] = true;
              cursor = this.cursor;
              _context5.prev = 2;
              _context5.next = 5;
              return cursor.close();

            case 5:
              _context5.prev = 5;

              this._endStream();

              return _context5.finish(5);

            case 8:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[2,, 5, 8]]);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Return a modified Readable stream including a possible transform method.
     *
     * NOTE: When using a Stream to process change stream events, the stream will
     * NOT automatically resume in the case a resumable error is encountered.
     *
     * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
     */

  }, {
    key: "stream",
    value: function stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }

      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    /** @internal */

  }, {
    key: "_setIsEmitter",
    value: function _setIsEmitter() {
      if (this[kMode] === 'iterator') {
        // TODO(NODE-3485): Replace with MongoChangeStreamModeError
        throw new error_1.MongoAPIError('ChangeStream cannot be used as an EventEmitter after being used as an iterator');
      }

      this[kMode] = 'emitter';
    }
    /** @internal */

  }, {
    key: "_setIsIterator",
    value: function _setIsIterator() {
      if (this[kMode] === 'emitter') {
        // TODO(NODE-3485): Replace with MongoChangeStreamModeError
        throw new error_1.MongoAPIError('ChangeStream cannot be used as an iterator after being used as an EventEmitter');
      }

      this[kMode] = 'iterator';
    }
    /**
     * Create a new change stream cursor based on self's configuration
     * @internal
     */

  }, {
    key: "_createChangeStreamCursor",
    value: function _createChangeStreamCursor(options) {
      var _this3 = this;

      var changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);

      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }

      var pipeline = [{
        $changeStream: changeStreamStageOptions
      }].concat(_toConsumableArray(this.pipeline));
      var client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;

      if (client == null) {
        // This should never happen because of the assertion in the constructor
        throw new error_1.MongoRuntimeError("Changestream type should only be one of cluster, database, collection. Found ".concat(this.type.toString()));
      }

      var changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, options);

      var _iterator = _createForOfIteratorHelper(CHANGE_STREAM_EVENTS),
          _step;

      try {
        var _loop = function _loop() {
          var event = _step.value;
          changeStreamCursor.on(event, function (e) {
            return _this3.emit(event, e);
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }

      return changeStreamCursor;
    }
    /** @internal */

  }, {
    key: "_closeEmitterModeWithError",
    value: function _closeEmitterModeWithError(error) {
      this.emit(ChangeStream.ERROR, error);
      this.close()["catch"](function () {
        return null;
      });
    }
    /** @internal */

  }, {
    key: "_streamEvents",
    value: function _streamEvents(cursor) {
      var _this$kCursorStream,
          _this4 = this;

      this._setIsEmitter();

      var stream = (_this$kCursorStream = this[kCursorStream]) !== null && _this$kCursorStream !== void 0 ? _this$kCursorStream : cursor.stream();
      this[kCursorStream] = stream;
      stream.on('data', function (change) {
        try {
          var processedChange = _this4._processChange(change);

          _this4.emit(ChangeStream.CHANGE, processedChange);
        } catch (error) {
          _this4.emit(ChangeStream.ERROR, error);
        }
      });
      stream.on('error', function (error) {
        return _this4._processErrorStreamMode(error);
      });
    }
    /** @internal */

  }, {
    key: "_endStream",
    value: function _endStream() {
      var cursorStream = this[kCursorStream];

      if (cursorStream) {
        ['data', 'close', 'end', 'error'].forEach(function (event) {
          return cursorStream.removeAllListeners(event);
        });
        cursorStream.destroy();
      }

      this[kCursorStream] = undefined;
    }
    /** @internal */

  }, {
    key: "_processChange",
    value: function _processChange(change) {
      if (this[kClosed]) {
        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      } // a null change means the cursor has been notified, implicitly closing the change stream


      if (change == null) {
        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }

      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      } // cache the resume token


      this.cursor.cacheResumeToken(change._id); // wipe the startAtOperationTime if there was one so that there won't be a conflict
      // between resumeToken and startAtOperationTime if we need to reconnect the cursor

      this.options.startAtOperationTime = undefined;
      return change;
    }
    /** @internal */

  }, {
    key: "_processErrorStreamMode",
    value: function _processErrorStreamMode(changeStreamError) {
      var _this5 = this;

      // If the change stream has been closed explicitly, do not process error.
      if (this[kClosed]) return;

      if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        this._endStream();

        this.cursor.close()["catch"](function () {
          return null;
        });
        var topology = (0, utils_1.getTopology)(this.parent);
        topology.selectServer(this.cursor.readPreference, {}, function (serverSelectionError) {
          if (serverSelectionError) return _this5._closeEmitterModeWithError(changeStreamError);
          _this5.cursor = _this5._createChangeStreamCursor(_this5.cursor.resumeOptions);
        });
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    /** @internal */

  }, {
    key: "_processErrorIteratorMode",
    value: function () {
      var _processErrorIteratorMode2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(changeStreamError) {
        var topology;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!this[kClosed]) {
                _context6.next = 2;
                break;
              }

              throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);

            case 2:
              if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
                _context6.next = 11;
                break;
              }

              _context6.prev = 3;
              _context6.next = 6;
              return this.close();

            case 6:
              _context6.next = 10;
              break;

            case 8:
              _context6.prev = 8;
              _context6.t0 = _context6["catch"](3);

            case 10:
              throw changeStreamError;

            case 11:
              _context6.next = 13;
              return this.cursor.close()["catch"](function () {
                return null;
              });

            case 13:
              topology = (0, utils_1.getTopology)(this.parent);
              _context6.prev = 14;
              _context6.next = 17;
              return topology.selectServerAsync(this.cursor.readPreference, {});

            case 17:
              this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
              _context6.next = 25;
              break;

            case 20:
              _context6.prev = 20;
              _context6.t1 = _context6["catch"](14);
              _context6.next = 24;
              return this.close();

            case 24:
              throw changeStreamError;

            case 25:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[3, 8], [14, 20]]);
      }));

      function _processErrorIteratorMode(_x) {
        return _processErrorIteratorMode2.apply(this, arguments);
      }

      return _processErrorIteratorMode;
    }()
  }]);

  return ChangeStream;
}(mongo_types_1.TypedEventEmitter, Symbol.asyncIterator);
/** @event */


ChangeStream.RESPONSE = constants_1.RESPONSE;
/** @event */

ChangeStream.MORE = constants_1.MORE;
/** @event */

ChangeStream.INIT = constants_1.INIT;
/** @event */

ChangeStream.CLOSE = constants_1.CLOSE;
/**
 * Fired for each new matching change in the specified namespace. Attaching a `change`
 * event listener to a Change Stream will switch the stream into flowing mode. Data will
 * then be passed as soon as it is available.
 * @event
 */

ChangeStream.CHANGE = constants_1.CHANGE;
/** @event */

ChangeStream.END = constants_1.END;
/** @event */

ChangeStream.ERROR = constants_1.ERROR;
/**
 * Emitted each time the change stream stores a new resume token.
 * @event
 */

ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
exports.ChangeStream = ChangeStream;

/***/ }),

/***/ 3264:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AuthProvider = exports.AuthContext = void 0;

var error_1 = __webpack_require__(9525);
/**
 * Context used during authentication
 * @internal
 */


var AuthContext = /*#__PURE__*/_createClass(function AuthContext(connection, credentials, options) {
  _classCallCheck(this, AuthContext);

  /** If the context is for reauthentication. */
  this.reauthenticating = false;
  this.connection = connection;
  this.credentials = credentials;
  this.options = options;
});

exports.AuthContext = AuthContext;

var AuthProvider = /*#__PURE__*/function () {
  function AuthProvider() {
    _classCallCheck(this, AuthProvider);
  }

  _createClass(AuthProvider, [{
    key: "prepare",
    value:
    /**
     * Prepare the handshake document before the initial handshake.
     *
     * @param handshakeDoc - The document used for the initial handshake on a connection
     * @param authContext - Context for authentication flow
     */
    function () {
      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handshakeDoc, _authContext) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", handshakeDoc);

            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function prepare(_x, _x2) {
        return _prepare.apply(this, arguments);
      }

      return prepare;
    }()
    /**
     * Reauthenticate.
     * @param context - The shared auth context.
     */

  }, {
    key: "reauth",
    value: function () {
      var _reauth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!context.reauthenticating) {
                _context2.next = 2;
                break;
              }

              throw new error_1.MongoRuntimeError('Reauthentication already in progress.');

            case 2:
              _context2.prev = 2;
              context.reauthenticating = true;
              _context2.next = 6;
              return this.auth(context);

            case 6:
              _context2.prev = 6;
              context.reauthenticating = false;
              return _context2.finish(6);

            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[2,, 6, 9]]);
      }));

      function reauth(_x3) {
        return _reauth.apply(this, arguments);
      }

      return reauth;
    }()
  }]);

  return AuthProvider;
}();

exports.AuthProvider = AuthProvider;

/***/ }),

/***/ 7874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;

var dns = __webpack_require__(9523);

var deps_1 = __webpack_require__(8310);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);
/** @public */


exports.GSSAPICanonicalizationValue = Object.freeze({
  on: true,
  off: false,
  none: 'none',
  forward: 'forward',
  forwardAndReverse: 'forwardAndReverse'
});

function externalCommand(_x, _x2) {
  return _externalCommand.apply(this, arguments);
}

function _externalCommand() {
  _externalCommand = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, command) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", connection.commandAsync((0, utils_1.ns)('$external.$cmd'), command, undefined));

        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _externalCommand.apply(this, arguments);
}

var krb;

var GSSAPI = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(GSSAPI, _auth_provider_1$Auth);

  var _super = _createSuper(GSSAPI);

  function GSSAPI() {
    _classCallCheck(this, GSSAPI);

    return _super.apply(this, arguments);
  }

  _createClass(GSSAPI, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authContext) {
        var connection, credentials, username, client, payload, saslStartResponse, negotiatedPayload, saslContinueResponse, finalizePayload;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              connection = authContext.connection, credentials = authContext.credentials;

              if (!(credentials == null)) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');

            case 3:
              username = credentials.username;
              _context.next = 6;
              return makeKerberosClient(authContext);

            case 6:
              client = _context.sent;
              _context.next = 9;
              return client.step('');

            case 9:
              payload = _context.sent;
              _context.next = 12;
              return externalCommand(connection, saslStart(payload));

            case 12:
              saslStartResponse = _context.sent;
              _context.next = 15;
              return negotiate(client, 10, saslStartResponse.payload);

            case 15:
              negotiatedPayload = _context.sent;
              _context.next = 18;
              return externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));

            case 18:
              saslContinueResponse = _context.sent;
              _context.next = 21;
              return finalize(client, username, saslContinueResponse.payload);

            case 21:
              finalizePayload = _context.sent;
              _context.next = 24;
              return externalCommand(connection, {
                saslContinue: 1,
                conversationId: saslContinueResponse.conversationId,
                payload: finalizePayload
              });

            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function auth(_x3) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return GSSAPI;
}(auth_provider_1.AuthProvider);

exports.GSSAPI = GSSAPI;

function makeKerberosClient(_x4) {
  return _makeKerberosClient.apply(this, arguments);
}

function _makeKerberosClient() {
  _makeKerberosClient = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(authContext) {
    var _mechanismProperties$, _mechanismProperties$2;

    var hostAddress, credentials, _krb, initializeClient, username, password, mechanismProperties, serviceName, host, initOptions, spnHost, spn;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          hostAddress = authContext.options.hostAddress;
          credentials = authContext.credentials;

          if (!(!hostAddress || typeof hostAddress.host !== 'string' || !credentials)) {
            _context3.next = 4;
            break;
          }

          throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');

        case 4:
          loadKrb();

          if (!('kModuleError' in krb)) {
            _context3.next = 7;
            break;
          }

          throw krb['kModuleError'];

        case 7:
          _krb = krb, initializeClient = _krb.initializeClient;
          username = credentials.username, password = credentials.password;
          mechanismProperties = credentials.mechanismProperties;
          serviceName = (_mechanismProperties$ = mechanismProperties.SERVICE_NAME) !== null && _mechanismProperties$ !== void 0 ? _mechanismProperties$ : 'mongodb';
          _context3.next = 13;
          return performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);

        case 13:
          host = _context3.sent;
          initOptions = {};

          if (password != null) {
            // TODO(NODE-5139): These do not match the typescript options in initializeClient
            Object.assign(initOptions, {
              user: username,
              password: password
            });
          }

          spnHost = (_mechanismProperties$2 = mechanismProperties.SERVICE_HOST) !== null && _mechanismProperties$2 !== void 0 ? _mechanismProperties$2 : host;
          spn = "".concat(serviceName).concat(process.platform === 'win32' ? '/' : '@').concat(spnHost);

          if ('SERVICE_REALM' in mechanismProperties) {
            spn = "".concat(spn, "@").concat(mechanismProperties.SERVICE_REALM);
          }

          return _context3.abrupt("return", initializeClient(spn, initOptions));

        case 20:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _makeKerberosClient.apply(this, arguments);
}

function saslStart(payload) {
  return {
    saslStart: 1,
    mechanism: 'GSSAPI',
    payload: payload,
    autoAuthorize: 1
  };
}

function saslContinue(payload, conversationId) {
  return {
    saslContinue: 1,
    conversationId: conversationId,
    payload: payload
  };
}

function negotiate(_x5, _x6, _x7) {
  return _negotiate.apply(this, arguments);
}

function _negotiate() {
  _negotiate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(client, retries, payload) {
    var response;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          _context4.next = 3;
          return client.step(payload);

        case 3:
          response = _context4.sent;
          return _context4.abrupt("return", response || '');

        case 7:
          _context4.prev = 7;
          _context4.t0 = _context4["catch"](0);

          if (!(retries === 0)) {
            _context4.next = 11;
            break;
          }

          throw _context4.t0;

        case 11:
          return _context4.abrupt("return", negotiate(client, retries - 1, payload));

        case 12:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[0, 7]]);
  }));
  return _negotiate.apply(this, arguments);
}

function finalize(_x8, _x9, _x10) {
  return _finalize.apply(this, arguments);
}

function _finalize() {
  _finalize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(client, user, payload) {
    var response;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return client.unwrap(payload);

        case 2:
          response = _context5.sent;
          return _context5.abrupt("return", client.wrap(response || '', {
            user: user
          }));

        case 4:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _finalize.apply(this, arguments);
}

function performGSSAPICanonicalizeHostName(_x11, _x12) {
  return _performGSSAPICanonicalizeHostName.apply(this, arguments);
}

function _performGSSAPICanonicalizeHostName() {
  _performGSSAPICanonicalizeHostName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(host, mechanismProperties) {
    var mode, _yield$dns$promises$l2, address, results;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          mode = mechanismProperties.CANONICALIZE_HOST_NAME;

          if (!(!mode || mode === exports.GSSAPICanonicalizationValue.none)) {
            _context6.next = 3;
            break;
          }

          return _context6.abrupt("return", host);

        case 3:
          if (!(mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse)) {
            _context6.next = 20;
            break;
          }

          _context6.next = 6;
          return dns.promises.lookup(host);

        case 6:
          _yield$dns$promises$l2 = _context6.sent;
          address = _yield$dns$promises$l2.address;
          _context6.prev = 8;
          _context6.next = 11;
          return dns.promises.resolvePtr(address);

        case 11:
          results = _context6.sent;
          return _context6.abrupt("return", results.length > 0 ? results[0] : host);

        case 15:
          _context6.prev = 15;
          _context6.t0 = _context6["catch"](8);
          return _context6.abrupt("return", resolveCname(host));

        case 18:
          _context6.next = 21;
          break;

        case 20:
          return _context6.abrupt("return", resolveCname(host));

        case 21:
        case "end":
          return _context6.stop();
      }
    }, _callee6, null, [[8, 15]]);
  }));
  return _performGSSAPICanonicalizeHostName.apply(this, arguments);
}

exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;

function resolveCname(_x13) {
  return _resolveCname.apply(this, arguments);
}

function _resolveCname() {
  _resolveCname = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(host) {
    var results;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _context7.next = 3;
          return dns.promises.resolveCname(host);

        case 3:
          results = _context7.sent;
          return _context7.abrupt("return", results.length > 0 ? results[0] : host);

        case 7:
          _context7.prev = 7;
          _context7.t0 = _context7["catch"](0);
          return _context7.abrupt("return", host);

        case 10:
        case "end":
          return _context7.stop();
      }
    }, _callee7, null, [[0, 7]]);
  }));
  return _resolveCname.apply(this, arguments);
}

exports.resolveCname = resolveCname;
/**
 * Load the Kerberos library.
 */

function loadKrb() {
  if (!krb) {
    krb = (0, deps_1.getKerberos)();
  }
}

/***/ }),

/***/ 7739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = void 0;

var error_1 = __webpack_require__(9525);

var gssapi_1 = __webpack_require__(7874);

var providers_1 = __webpack_require__(4923); // https://github.com/mongodb/specifications/blob/master/source/auth/auth.rst


function getDefaultAuthMechanism(hello) {
  if (hello) {
    // If hello contains saslSupportedMechs, use scram-sha-256
    // if it is available, else scram-sha-1
    if (Array.isArray(hello.saslSupportedMechs)) {
      return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
    } // Fallback to legacy selection method. If wire version >= 3, use scram-sha-1


    if (hello.maxWireVersion >= 3) {
      return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
    }
  } // Default for wireprotocol < 3


  return providers_1.AuthMechanism.MONGODB_CR;
}

var ALLOWED_PROVIDER_NAMES = ['aws', 'azure'];
var ALLOWED_HOSTS_ERROR = 'Auth mechanism property ALLOWED_HOSTS must be an array of strings.';
/** @internal */

exports.DEFAULT_ALLOWED_HOSTS = ['*.mongodb.net', '*.mongodb-dev.net', '*.mongodbgov.net', 'localhost', '127.0.0.1', '::1'];
/** Error for when the token audience is missing in the environment. */

var TOKEN_AUDIENCE_MISSING_ERROR = 'TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.';
/**
 * A representation of the credentials used by MongoDB
 * @public
 */

var MongoCredentials = /*#__PURE__*/function () {
  function MongoCredentials(options) {
    var _options$username;

    _classCallCheck(this, MongoCredentials);

    this.username = (_options$username = options.username) !== null && _options$username !== void 0 ? _options$username : '';
    this.password = options.password;
    this.source = options.source;

    if (!this.source && options.db) {
      this.source = options.db;
    }

    this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
    this.mechanismProperties = options.mechanismProperties || {};

    if (this.mechanism.match(/MONGODB-AWS/i)) {
      if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
        this.username = process.env.AWS_ACCESS_KEY_ID;
      }

      if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
        this.password = process.env.AWS_SECRET_ACCESS_KEY;
      }

      if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
        this.mechanismProperties = _objectSpread(_objectSpread({}, this.mechanismProperties), {}, {
          AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
        });
      }
    }

    if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
      this.mechanismProperties = _objectSpread(_objectSpread({}, this.mechanismProperties), {}, {
        ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
      });
    }

    Object.freeze(this.mechanismProperties);
    Object.freeze(this);
  }
  /** Determines if two MongoCredentials objects are equivalent */


  _createClass(MongoCredentials, [{
    key: "equals",
    value: function equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    /**
     * If the authentication mechanism is set to "default", resolves the authMechanism
     * based on the server version and server supported sasl mechanisms.
     *
     * @param hello - A hello response from the server
     */

  }, {
    key: "resolveAuthMechanism",
    value: function resolveAuthMechanism(hello) {
      // If the mechanism is not "default", then it does not need to be resolved
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var _this$mechanismProper;

      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_CR || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError("Username required for mechanism '".concat(this.mechanism, "'"));
      }

      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        if (this.username && this.mechanismProperties.PROVIDER_NAME) {
          throw new error_1.MongoInvalidArgumentError("username and PROVIDER_NAME may not be used together for mechanism '".concat(this.mechanism, "'."));
        }

        if (this.mechanismProperties.PROVIDER_NAME === 'azure' && !this.mechanismProperties.TOKEN_AUDIENCE) {
          throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);
        }

        if (this.mechanismProperties.PROVIDER_NAME && !ALLOWED_PROVIDER_NAMES.includes(this.mechanismProperties.PROVIDER_NAME)) {
          throw new error_1.MongoInvalidArgumentError("Currently only a PROVIDER_NAME in ".concat(ALLOWED_PROVIDER_NAMES.join(','), " is supported for mechanism '").concat(this.mechanism, "'."));
        }

        if (this.mechanismProperties.REFRESH_TOKEN_CALLBACK && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError("A REQUEST_TOKEN_CALLBACK must be provided when using a REFRESH_TOKEN_CALLBACK for mechanism '".concat(this.mechanism, "'"));
        }

        if (!this.mechanismProperties.PROVIDER_NAME && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError("Either a PROVIDER_NAME or a REQUEST_TOKEN_CALLBACK must be specified for mechanism '".concat(this.mechanism, "'."));
        }

        if (this.mechanismProperties.ALLOWED_HOSTS) {
          var hosts = this.mechanismProperties.ALLOWED_HOSTS;

          if (!Array.isArray(hosts)) {
            throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
          }

          var _iterator = _createForOfIteratorHelper(hosts),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var host = _step.value;

              if (typeof host !== 'string') {
                throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }

      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== '$external') {
          // TODO(NODE-3485): Replace this with a MongoAuthValidationError
          throw new error_1.MongoAPIError("Invalid source '".concat(this.source, "' for mechanism '").concat(this.mechanism, "' specified."));
        }
      }

      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        // TODO(NODE-3485): Replace this with a MongoAuthValidationError
        throw new error_1.MongoAPIError('PLAIN Authentication Mechanism needs an auth source');
      }

      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === '') {
          Reflect.set(this, 'password', undefined);
          return;
        } // TODO(NODE-3485): Replace this with a MongoAuthValidationError


        throw new error_1.MongoAPIError("Password not allowed for mechanism MONGODB-X509");
      }

      var canonicalization = (_this$mechanismProper = this.mechanismProperties.CANONICALIZE_HOST_NAME) !== null && _this$mechanismProper !== void 0 ? _this$mechanismProper : false;

      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError("Invalid CANONICALIZE_HOST_NAME value: ".concat(canonicalization));
      }
    }
  }], [{
    key: "merge",
    value: function merge(creds, options) {
      var _ref, _options$username2, _ref2, _options$password, _ref3, _options$mechanism, _ref4, _options$mechanismPro, _ref5, _ref6, _options$source;

      return new MongoCredentials({
        username: (_ref = (_options$username2 = options.username) !== null && _options$username2 !== void 0 ? _options$username2 : creds === null || creds === void 0 ? void 0 : creds.username) !== null && _ref !== void 0 ? _ref : '',
        password: (_ref2 = (_options$password = options.password) !== null && _options$password !== void 0 ? _options$password : creds === null || creds === void 0 ? void 0 : creds.password) !== null && _ref2 !== void 0 ? _ref2 : '',
        mechanism: (_ref3 = (_options$mechanism = options.mechanism) !== null && _options$mechanism !== void 0 ? _options$mechanism : creds === null || creds === void 0 ? void 0 : creds.mechanism) !== null && _ref3 !== void 0 ? _ref3 : providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: (_ref4 = (_options$mechanismPro = options.mechanismProperties) !== null && _options$mechanismPro !== void 0 ? _options$mechanismPro : creds === null || creds === void 0 ? void 0 : creds.mechanismProperties) !== null && _ref4 !== void 0 ? _ref4 : {},
        source: (_ref5 = (_ref6 = (_options$source = options.source) !== null && _options$source !== void 0 ? _options$source : options.db) !== null && _ref6 !== void 0 ? _ref6 : creds === null || creds === void 0 ? void 0 : creds.source) !== null && _ref5 !== void 0 ? _ref5 : 'admin'
      });
    }
  }]);

  return MongoCredentials;
}();

exports.MongoCredentials = MongoCredentials;

/***/ }),

/***/ 9406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoCR = void 0;

var crypto = __webpack_require__(6113);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var MongoCR = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(MongoCR, _auth_provider_1$Auth);

  var _super = _createSuper(MongoCR);

  function MongoCR() {
    _classCallCheck(this, MongoCR);

    return _super.apply(this, arguments);
  }

  _createClass(MongoCR, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authContext) {
        var connection, credentials, username, password, source, _yield$connection$com, nonce, hashPassword, key, authenticateCommand;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              connection = authContext.connection, credentials = authContext.credentials;

              if (credentials) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 3:
              username = credentials.username, password = credentials.password, source = credentials.source;
              _context.next = 6;
              return connection.commandAsync((0, utils_1.ns)("".concat(source, ".$cmd")), {
                getnonce: 1
              }, undefined);

            case 6:
              _yield$connection$com = _context.sent;
              nonce = _yield$connection$com.nonce;
              hashPassword = crypto.createHash('md5').update("".concat(username, ":mongo:").concat(password), 'utf8').digest('hex'); // Final key

              key = crypto.createHash('md5').update("".concat(nonce).concat(username).concat(hashPassword), 'utf8').digest('hex');
              authenticateCommand = {
                authenticate: 1,
                user: username,
                nonce: nonce,
                key: key
              };
              _context.next = 13;
              return connection.commandAsync((0, utils_1.ns)("".concat(source, ".$cmd")), authenticateCommand, undefined);

            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function auth(_x) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return MongoCR;
}(auth_provider_1.AuthProvider);

exports.MongoCR = MongoCR;

/***/ }),

/***/ 4406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoDBAWS = void 0;

var crypto = __webpack_require__(6113);

var util_1 = __webpack_require__(3837);

var BSON = __webpack_require__(4356);

var deps_1 = __webpack_require__(8310);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var mongo_credentials_1 = __webpack_require__(7739);

var providers_1 = __webpack_require__(4923);

var ASCII_N = 110;
var AWS_RELATIVE_URI = 'http://169.254.170.2';
var AWS_EC2_URI = 'http://169.254.169.254';
var AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';
var bsonOptions = {
  useBigInt64: false,
  promoteLongs: true,
  promoteValues: true,
  promoteBuffers: false,
  bsonRegExp: false
};

var MongoDBAWS = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(MongoDBAWS, _auth_provider_1$Auth);

  var _super = _createSuper(MongoDBAWS);

  function MongoDBAWS() {
    var _this;

    _classCallCheck(this, MongoDBAWS);

    _this = _super.call(this);
    _this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);
    return _this;
  }

  _createClass(MongoDBAWS, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authContext) {
        var connection, sign, credentials, accessKeyId, secretAccessKey, sessionToken, awsCredentials, db, nonce, saslStart, saslStartResponse, serverResponse, host, serverNonce, body, options, payload, saslContinue;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              connection = authContext.connection;

              if (authContext.credentials) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 3:
              if (!('kModuleError' in deps_1.aws4)) {
                _context.next = 5;
                break;
              }

              throw deps_1.aws4['kModuleError'];

            case 5:
              sign = deps_1.aws4.sign;

              if (!((0, utils_1.maxWireVersion)(connection) < 9)) {
                _context.next = 8;
                break;
              }

              throw new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later');

            case 8:
              if (authContext.credentials.username) {
                _context.next = 12;
                break;
              }

              _context.next = 11;
              return makeTempCredentials(authContext.credentials);

            case 11:
              authContext.credentials = _context.sent;

            case 12:
              credentials = authContext.credentials;
              accessKeyId = credentials.username;
              secretAccessKey = credentials.password;
              sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN; // If all three defined, include sessionToken, else include username and pass, else no credentials

              awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {
                accessKeyId: accessKeyId,
                secretAccessKey: secretAccessKey,
                sessionToken: sessionToken
              } : accessKeyId && secretAccessKey ? {
                accessKeyId: accessKeyId,
                secretAccessKey: secretAccessKey
              } : undefined;
              db = credentials.source;
              _context.next = 20;
              return this.randomBytesAsync(32);

            case 20:
              nonce = _context.sent;
              saslStart = {
                saslStart: 1,
                mechanism: 'MONGODB-AWS',
                payload: BSON.serialize({
                  r: nonce,
                  p: ASCII_N
                }, bsonOptions)
              };
              _context.next = 24;
              return connection.commandAsync((0, utils_1.ns)("".concat(db, ".$cmd")), saslStart, undefined);

            case 24:
              saslStartResponse = _context.sent;
              serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
              host = serverResponse.h;
              serverNonce = serverResponse.s.buffer;

              if (!(serverNonce.length !== 64)) {
                _context.next = 30;
                break;
              }

              throw new error_1.MongoRuntimeError("Invalid server nonce length ".concat(serverNonce.length, ", expected 64"));

            case 30:
              if (utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
                _context.next = 32;
                break;
              }

              throw new error_1.MongoRuntimeError('Server nonce does not begin with client nonce');

            case 32:
              if (!(host.length < 1 || host.length > 255 || host.indexOf('..') !== -1)) {
                _context.next = 34;
                break;
              }

              throw new error_1.MongoRuntimeError("Server returned an invalid host: \"".concat(host, "\""));

            case 34:
              body = 'Action=GetCallerIdentity&Version=2011-06-15';
              options = sign({
                method: 'POST',
                host: host,
                region: deriveRegion(serverResponse.h),
                service: 'sts',
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Content-Length': body.length,
                  'X-MongoDB-Server-Nonce': utils_1.ByteUtils.toBase64(serverNonce),
                  'X-MongoDB-GS2-CB-Flag': 'n'
                },
                path: '/',
                body: body
              }, awsCredentials);
              payload = {
                a: options.headers.Authorization,
                d: options.headers['X-Amz-Date']
              };

              if (sessionToken) {
                payload.t = sessionToken;
              }

              saslContinue = {
                saslContinue: 1,
                conversationId: 1,
                payload: BSON.serialize(payload, bsonOptions)
              };
              _context.next = 41;
              return connection.commandAsync((0, utils_1.ns)("".concat(db, ".$cmd")), saslContinue, undefined);

            case 41:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function auth(_x) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return MongoDBAWS;
}(auth_provider_1.AuthProvider);

exports.MongoDBAWS = MongoDBAWS;

function makeTempCredentials(_x2) {
  return _makeTempCredentials.apply(this, arguments);
}

function _makeTempCredentials() {
  _makeTempCredentials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(credentials) {
    var makeMongoCredentialsFromAWSTemp, credentialProvider, token, roleName, creds, fromNodeProviderChain, provider, _creds;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          makeMongoCredentialsFromAWSTemp = function _makeMongoCredentials(creds) {
            if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {
              throw new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials');
            }

            return new mongo_credentials_1.MongoCredentials({
              username: creds.AccessKeyId,
              password: creds.SecretAccessKey,
              source: credentials.source,
              mechanism: providers_1.AuthMechanism.MONGODB_AWS,
              mechanismProperties: {
                AWS_SESSION_TOKEN: creds.Token
              }
            });
          };

          credentialProvider = (0, deps_1.getAwsCredentialProvider)(); // Check if the AWS credential provider from the SDK is present. If not,
          // use the old method.

          if (!('kModuleError' in credentialProvider)) {
            _context2.next = 21;
            break;
          }

          if (!process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
            _context2.next = 9;
            break;
          }

          _context2.t0 = makeMongoCredentialsFromAWSTemp;
          _context2.next = 7;
          return (0, utils_1.request)("".concat(AWS_RELATIVE_URI).concat(process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI));

        case 7:
          _context2.t1 = _context2.sent;
          return _context2.abrupt("return", (0, _context2.t0)(_context2.t1));

        case 9:
          _context2.next = 11;
          return (0, utils_1.request)("".concat(AWS_EC2_URI, "/latest/api/token"), {
            method: 'PUT',
            json: false,
            headers: {
              'X-aws-ec2-metadata-token-ttl-seconds': 30
            }
          });

        case 11:
          token = _context2.sent;
          _context2.next = 14;
          return (0, utils_1.request)("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH), {
            json: false,
            headers: {
              'X-aws-ec2-metadata-token': token
            }
          });

        case 14:
          roleName = _context2.sent;
          _context2.next = 17;
          return (0, utils_1.request)("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH, "/").concat(roleName), {
            headers: {
              'X-aws-ec2-metadata-token': token
            }
          });

        case 17:
          creds = _context2.sent;
          return _context2.abrupt("return", makeMongoCredentialsFromAWSTemp(creds));

        case 21:
          /*
           * Creates a credential provider that will attempt to find credentials from the
           * following sources (listed in order of precedence):
           *
           * - Environment variables exposed via process.env
           * - SSO credentials from token cache
           * - Web identity token credentials
           * - Shared credentials and config ini files
           * - The EC2/ECS Instance Metadata Service
           */
          fromNodeProviderChain = credentialProvider.fromNodeProviderChain;
          provider = fromNodeProviderChain();
          _context2.prev = 23;
          _context2.next = 26;
          return provider();

        case 26:
          _creds = _context2.sent;
          return _context2.abrupt("return", makeMongoCredentialsFromAWSTemp({
            AccessKeyId: _creds.accessKeyId,
            SecretAccessKey: _creds.secretAccessKey,
            Token: _creds.sessionToken,
            Expiration: _creds.expiration
          }));

        case 30:
          _context2.prev = 30;
          _context2.t2 = _context2["catch"](23);
          throw new error_1.MongoAWSError(_context2.t2.message);

        case 33:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[23, 30]]);
  }));
  return _makeTempCredentials.apply(this, arguments);
}

function deriveRegion(host) {
  var parts = host.split('.');

  if (parts.length === 1 || parts[1] === 'amazonaws') {
    return 'us-east-1';
  }

  return parts[1];
}

/***/ }),

/***/ 8990:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = void 0;

var error_1 = __webpack_require__(9525);

var auth_provider_1 = __webpack_require__(3264);

var aws_service_workflow_1 = __webpack_require__(4658);

var azure_service_workflow_1 = __webpack_require__(449);

var callback_workflow_1 = __webpack_require__(2233);
/** Error when credentials are missing. */


var MISSING_CREDENTIALS_ERROR = 'AuthContext must provide credentials.';
/** @internal */

exports.OIDC_WORKFLOWS = new Map();
exports.OIDC_WORKFLOWS.set('callback', new callback_workflow_1.CallbackWorkflow());
exports.OIDC_WORKFLOWS.set('aws', new aws_service_workflow_1.AwsServiceWorkflow());
exports.OIDC_WORKFLOWS.set('azure', new azure_service_workflow_1.AzureServiceWorkflow());
/**
 * OIDC auth provider.
 * @experimental
 */

var MongoDBOIDC = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(MongoDBOIDC, _auth_provider_1$Auth);

  var _super = _createSuper(MongoDBOIDC);

  /**
   * Instantiate the auth provider.
   */
  function MongoDBOIDC() {
    _classCallCheck(this, MongoDBOIDC);

    return _super.call(this);
  }
  /**
   * Authenticate using OIDC
   */


  _createClass(MongoDBOIDC, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authContext) {
        var connection, reauthenticating, response, credentials, workflow;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              connection = authContext.connection, reauthenticating = authContext.reauthenticating, response = authContext.response;
              credentials = getCredentials(authContext);
              workflow = getWorkflow(credentials);
              _context.next = 5;
              return workflow.execute(connection, credentials, reauthenticating, response);

            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function auth(_x) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
    /**
     * Add the speculative auth for the initial handshake.
     */

  }, {
    key: "prepare",
    value: function () {
      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(handshakeDoc, authContext) {
        var credentials, workflow, result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              credentials = getCredentials(authContext);
              workflow = getWorkflow(credentials);
              _context2.next = 4;
              return workflow.speculativeAuth(credentials);

            case 4:
              result = _context2.sent;
              return _context2.abrupt("return", _objectSpread(_objectSpread({}, handshakeDoc), result));

            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function prepare(_x2, _x3) {
        return _prepare.apply(this, arguments);
      }

      return prepare;
    }()
  }]);

  return MongoDBOIDC;
}(auth_provider_1.AuthProvider);

exports.MongoDBOIDC = MongoDBOIDC;
/**
 * Get credentials from the auth context, throwing if they do not exist.
 */

function getCredentials(authContext) {
  var credentials = authContext.credentials;

  if (!credentials) {
    throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
  }

  return credentials;
}
/**
 * Gets either a device workflow or callback workflow.
 */


function getWorkflow(credentials) {
  var providerName = credentials.mechanismProperties.PROVIDER_NAME;
  var workflow = exports.OIDC_WORKFLOWS.get(providerName || 'callback');

  if (!workflow) {
    throw new error_1.MongoInvalidArgumentError("Could not load workflow for provider ".concat(credentials.mechanismProperties.PROVIDER_NAME));
  }

  return workflow;
}

/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AwsServiceWorkflow = void 0;

var fs = __webpack_require__(7147);

var error_1 = __webpack_require__(9525);

var service_workflow_1 = __webpack_require__(7379);
/** Error for when the token is missing in the environment. */


var TOKEN_MISSING_ERROR = 'AWS_WEB_IDENTITY_TOKEN_FILE must be set in the environment.';
/**
 * Device workflow implementation for AWS.
 *
 * @internal
 */

var AwsServiceWorkflow = /*#__PURE__*/function (_service_workflow_1$S) {
  _inherits(AwsServiceWorkflow, _service_workflow_1$S);

  var _super = _createSuper(AwsServiceWorkflow);

  function AwsServiceWorkflow() {
    _classCallCheck(this, AwsServiceWorkflow);

    return _super.call(this);
  }
  /**
   * Get the token from the environment.
   */


  _createClass(AwsServiceWorkflow, [{
    key: "getToken",
    value: function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var tokenFile;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              tokenFile = process.env.AWS_WEB_IDENTITY_TOKEN_FILE;

              if (tokenFile) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);

            case 3:
              return _context.abrupt("return", fs.promises.readFile(tokenFile, 'utf8'));

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function getToken() {
        return _getToken.apply(this, arguments);
      }

      return getToken;
    }()
  }]);

  return AwsServiceWorkflow;
}(service_workflow_1.ServiceWorkflow);

exports.AwsServiceWorkflow = AwsServiceWorkflow;

/***/ }),

/***/ 449:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AzureServiceWorkflow = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var azure_token_cache_1 = __webpack_require__(8407);

var service_workflow_1 = __webpack_require__(7379);
/** Base URL for getting Azure tokens. */


var AZURE_BASE_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01';
/** Azure request headers. */

var AZURE_HEADERS = Object.freeze({
  Metadata: 'true',
  Accept: 'application/json'
});
/** Invalid endpoint result error. */

var ENDPOINT_RESULT_ERROR = 'Azure endpoint did not return a value with only access_token and expires_in properties';
/** Error for when the token audience is missing in the environment. */

var TOKEN_AUDIENCE_MISSING_ERROR = 'TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.';
/**
 * Device workflow implementation for Azure.
 *
 * @internal
 */

var AzureServiceWorkflow = /*#__PURE__*/function (_service_workflow_1$S) {
  _inherits(AzureServiceWorkflow, _service_workflow_1$S);

  var _super = _createSuper(AzureServiceWorkflow);

  function AzureServiceWorkflow() {
    var _this;

    _classCallCheck(this, AzureServiceWorkflow);

    _this = _super.apply(this, arguments);
    _this.cache = new azure_token_cache_1.AzureTokenCache();
    return _this;
  }
  /**
   * Get the token from the environment.
   */


  _createClass(AzureServiceWorkflow, [{
    key: "getToken",
    value: function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(credentials) {
        var tokenAudience, token, entry, response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              tokenAudience = credentials === null || credentials === void 0 ? void 0 : credentials.mechanismProperties.TOKEN_AUDIENCE;

              if (tokenAudience) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);

            case 3:
              entry = this.cache.getEntry(tokenAudience);

              if (!(entry !== null && entry !== void 0 && entry.isValid())) {
                _context.next = 8;
                break;
              }

              token = entry.token;
              _context.next = 16;
              break;

            case 8:
              this.cache.deleteEntry(tokenAudience);
              _context.next = 11;
              return getAzureTokenData(tokenAudience);

            case 11:
              response = _context.sent;

              if (isEndpointResultValid(response)) {
                _context.next = 14;
                break;
              }

              throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);

            case 14:
              this.cache.addEntry(tokenAudience, response);
              token = response.access_token;

            case 16:
              return _context.abrupt("return", token);

            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function getToken(_x) {
        return _getToken.apply(this, arguments);
      }

      return getToken;
    }()
  }]);

  return AzureServiceWorkflow;
}(service_workflow_1.ServiceWorkflow);

exports.AzureServiceWorkflow = AzureServiceWorkflow;
/**
 * Hit the Azure endpoint to get the token data.
 */

function getAzureTokenData(_x2) {
  return _getAzureTokenData.apply(this, arguments);
}
/**
 * Determines if a result returned from the endpoint is valid.
 * This means the result is not nullish, contains the access_token required field
 * and the expires_in required field.
 */


function _getAzureTokenData() {
  _getAzureTokenData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenAudience) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          url = "".concat(AZURE_BASE_URL, "&resource=").concat(tokenAudience);
          _context2.next = 3;
          return (0, utils_1.request)(url, {
            json: true,
            headers: AZURE_HEADERS
          });

        case 3:
          data = _context2.sent;
          return _context2.abrupt("return", data);

        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getAzureTokenData.apply(this, arguments);
}

function isEndpointResultValid(token) {
  if (token == null || _typeof(token) !== 'object') return false;
  return 'access_token' in token && 'expires_in' in token;
}

/***/ }),

/***/ 8407:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AzureTokenCache = exports.AzureTokenEntry = void 0;

var cache_1 = __webpack_require__(3758);
/** @internal */


var AzureTokenEntry = /*#__PURE__*/function (_cache_1$ExpiringCach) {
  _inherits(AzureTokenEntry, _cache_1$ExpiringCach);

  var _super = _createSuper(AzureTokenEntry);

  /**
   * Instantiate the entry.
   */
  function AzureTokenEntry(token, expiration) {
    var _this;

    _classCallCheck(this, AzureTokenEntry);

    _this = _super.call(this, expiration);
    _this.token = token;
    return _this;
  }

  return _createClass(AzureTokenEntry);
}(cache_1.ExpiringCacheEntry);

exports.AzureTokenEntry = AzureTokenEntry;
/**
 * A cache of access tokens from Azure.
 * @internal
 */

var AzureTokenCache = /*#__PURE__*/function (_cache_1$Cache) {
  _inherits(AzureTokenCache, _cache_1$Cache);

  var _super2 = _createSuper(AzureTokenCache);

  function AzureTokenCache() {
    _classCallCheck(this, AzureTokenCache);

    return _super2.apply(this, arguments);
  }

  _createClass(AzureTokenCache, [{
    key: "addEntry",
    value:
    /**
     * Add an entry to the cache.
     */
    function addEntry(tokenAudience, token) {
      var entry = new AzureTokenEntry(token.access_token, token.expires_in);
      this.entries.set(tokenAudience, entry);
      return entry;
    }
    /**
     * Create a cache key.
     */

  }, {
    key: "cacheKey",
    value: function cacheKey(tokenAudience) {
      return tokenAudience;
    }
    /**
     * Delete an entry from the cache.
     */

  }, {
    key: "deleteEntry",
    value: function deleteEntry(tokenAudience) {
      this.entries["delete"](tokenAudience);
    }
    /**
     * Get an Azure token entry from the cache.
     */

  }, {
    key: "getEntry",
    value: function getEntry(tokenAudience) {
      return this.entries.get(tokenAudience);
    }
  }]);

  return AzureTokenCache;
}(cache_1.Cache);

exports.AzureTokenCache = AzureTokenCache;

/***/ }),

/***/ 3758:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Cache = exports.ExpiringCacheEntry = void 0;
/* 5 minutes in milliseconds */

var EXPIRATION_BUFFER_MS = 300000;
/**
 * An entry in a cache that can expire in a certain amount of time.
 */

var ExpiringCacheEntry = /*#__PURE__*/function () {
  /**
   * Create a new expiring token entry.
   */
  function ExpiringCacheEntry(expiration) {
    _classCallCheck(this, ExpiringCacheEntry);

    this.expiration = this.expirationTime(expiration);
  }
  /**
   * The entry is still valid if the expiration is more than
   * 5 minutes from the expiration time.
   */


  _createClass(ExpiringCacheEntry, [{
    key: "isValid",
    value: function isValid() {
      return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;
    }
    /**
     * Get an expiration time in milliseconds past epoch.
     */

  }, {
    key: "expirationTime",
    value: function expirationTime(expiresInSeconds) {
      return Date.now() + expiresInSeconds * 1000;
    }
  }]);

  return ExpiringCacheEntry;
}();

exports.ExpiringCacheEntry = ExpiringCacheEntry;
/**
 * Base class for OIDC caches.
 */

var Cache = /*#__PURE__*/function () {
  /**
   * Create a new cache.
   */
  function Cache() {
    _classCallCheck(this, Cache);

    this.entries = new Map();
  }
  /**
   * Clear the cache.
   */


  _createClass(Cache, [{
    key: "clear",
    value: function clear() {
      this.entries.clear();
    }
    /**
     * Create a cache key from the address and username.
     */

  }, {
    key: "hashedCacheKey",
    value: function hashedCacheKey(address, username, callbackHash) {
      return JSON.stringify([address, username, callbackHash]);
    }
  }]);

  return Cache;
}();

exports.Cache = Cache;

/***/ }),

/***/ 2711:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CallbackLockCache = void 0;

var error_1 = __webpack_require__(9525);

var cache_1 = __webpack_require__(3758);
/** Error message for when request callback is missing. */


var REQUEST_CALLBACK_REQUIRED_ERROR = 'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';
/* Counter for function "hashes".*/

var FN_HASH_COUNTER = 0;
/* No function present function */

var NO_FUNCTION = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", {
            accessToken: 'test'
          });

        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));

  return function NO_FUNCTION() {
    return _ref.apply(this, arguments);
  };
}();
/* The map of function hashes */


var FN_HASHES = new WeakMap();
/* Put the no function hash in the map. */

FN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);
/**
 * A cache of request and refresh callbacks per server/user.
 */

var CallbackLockCache = /*#__PURE__*/function (_cache_1$Cache) {
  _inherits(CallbackLockCache, _cache_1$Cache);

  var _super = _createSuper(CallbackLockCache);

  function CallbackLockCache() {
    _classCallCheck(this, CallbackLockCache);

    return _super.apply(this, arguments);
  }

  _createClass(CallbackLockCache, [{
    key: "getEntry",
    value:
    /**
     * Get the callbacks for the connection and credentials. If an entry does not
     * exist a new one will get set.
     */
    function getEntry(connection, credentials) {
      var requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
      var refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;

      if (!requestCallback) {
        throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);
      }

      var callbackHash = hashFunctions(requestCallback, refreshCallback);
      var key = this.cacheKey(connection.address, credentials.username, callbackHash);
      var entry = this.entries.get(key);

      if (entry) {
        return entry;
      }

      return this.addEntry(key, callbackHash, requestCallback, refreshCallback);
    }
    /**
     * Set locked callbacks on for connection and credentials.
     */

  }, {
    key: "addEntry",
    value: function addEntry(key, callbackHash, requestCallback, refreshCallback) {
      var entry = {
        requestCallback: withLock(requestCallback),
        refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,
        callbackHash: callbackHash
      };
      this.entries.set(key, entry);
      return entry;
    }
    /**
     * Create a cache key from the address and username.
     */

  }, {
    key: "cacheKey",
    value: function cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }]);

  return CallbackLockCache;
}(cache_1.Cache);

exports.CallbackLockCache = CallbackLockCache;
/**
 * Ensure the callback is only executed one at a time.
 */

function withLock(callback) {
  var lock = Promise.resolve();
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(info, context) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return lock;

          case 2:
            lock = lock.then(function () {
              return callback(info, context);
            });
            return _context2.abrupt("return", lock);

          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));

    return function (_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
}
/**
 * Get the hash string for the request and refresh functions.
 */


function hashFunctions(requestFn, refreshFn) {
  var requestHash = FN_HASHES.get(requestFn);
  var refreshHash = FN_HASHES.get(refreshFn !== null && refreshFn !== void 0 ? refreshFn : NO_FUNCTION);

  if (requestHash == null) {
    // Create a new one for the function and put it in the map.
    FN_HASH_COUNTER++;
    requestHash = FN_HASH_COUNTER;
    FN_HASHES.set(requestFn, FN_HASH_COUNTER);
  }

  if (refreshHash == null && refreshFn) {
    // Create a new one for the function and put it in the map.
    FN_HASH_COUNTER++;
    refreshHash = FN_HASH_COUNTER;
    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);
  }

  return "".concat(requestHash, "-").concat(refreshHash);
}

/***/ }),

/***/ 2233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CallbackWorkflow = void 0;

var bson_1 = __webpack_require__(8054);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var providers_1 = __webpack_require__(4923);

var callback_lock_cache_1 = __webpack_require__(2711);

var token_entry_cache_1 = __webpack_require__(1828);
/** The current version of OIDC implementation. */


var OIDC_VERSION = 0;
/** 5 minutes in seconds */

var TIMEOUT_S = 300;
/** Properties allowed on results of callbacks. */

var RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];
/** Error message when the callback result is invalid. */

var CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';
/**
 * OIDC implementation of a callback based workflow.
 * @internal
 */

var CallbackWorkflow = /*#__PURE__*/function () {
  /**
   * Instantiate the workflow
   */
  function CallbackWorkflow() {
    _classCallCheck(this, CallbackWorkflow);

    this.cache = new token_entry_cache_1.TokenEntryCache();
    this.callbackCache = new callback_lock_cache_1.CallbackLockCache();
  }
  /**
   * Get the document to add for speculative authentication. This also needs
   * to add a db field from the credentials source.
   */


  _createClass(CallbackWorkflow, [{
    key: "speculativeAuth",
    value: function () {
      var _speculativeAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(credentials) {
        var document;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              document = startCommandDocument(credentials);
              document.db = credentials.source;
              return _context.abrupt("return", {
                speculativeAuthenticate: document
              });

            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function speculativeAuth(_x) {
        return _speculativeAuth.apply(this, arguments);
      }

      return speculativeAuth;
    }()
    /**
     * Execute the OIDC callback workflow.
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, credentials, reauthenticating, response) {
        var _this$callbackCache$g, requestCallback, refreshCallback, callbackHash, entry, result, _response$speculative, tokenResult, _response$speculative2, startDocument, conversationId, serverResult, _tokenResult;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // Get the callbacks with locks from the callback lock cache.
              _this$callbackCache$g = this.callbackCache.getEntry(connection, credentials), requestCallback = _this$callbackCache$g.requestCallback, refreshCallback = _this$callbackCache$g.refreshCallback, callbackHash = _this$callbackCache$g.callbackHash; // Look for an existing entry in the cache.

              entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);

              if (!entry) {
                _context2.next = 30;
                break;
              }

              if (!(entry.isValid() && !reauthenticating)) {
                _context2.next = 9;
                break;
              }

              _context2.next = 6;
              return this.finishAuthentication(connection, credentials, entry.tokenResult, response === null || response === void 0 || (_response$speculative = response.speculativeAuthenticate) === null || _response$speculative === void 0 ? void 0 : _response$speculative.conversationId);

            case 6:
              result = _context2.sent;
              _context2.next = 28;
              break;

            case 9:
              _context2.next = 11;
              return this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);

            case 11:
              tokenResult = _context2.sent;
              _context2.prev = 12;
              _context2.next = 15;
              return this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response === null || response === void 0 || (_response$speculative2 = response.speculativeAuthenticate) === null || _response$speculative2 === void 0 ? void 0 : _response$speculative2.conversationId);

            case 15:
              result = _context2.sent;
              _context2.next = 28;
              break;

            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](12);

              if (!(reauthenticating && _context2.t0 instanceof error_1.MongoError && _context2.t0.code === error_1.MONGODB_ERROR_CODES.Reauthenticate)) {
                _context2.next = 27;
                break;
              }

              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
              _context2.next = 24;
              return this.execute(connection, credentials, reauthenticating);

            case 24:
              result = _context2.sent;
              _context2.next = 28;
              break;

            case 27:
              throw _context2.t0;

            case 28:
              _context2.next = 41;
              break;

            case 30:
              _context2.next = 32;
              return this.startAuthentication(connection, credentials, reauthenticating, response);

            case 32:
              startDocument = _context2.sent;
              conversationId = startDocument.conversationId;
              serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);
              _context2.next = 37;
              return this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);

            case 37:
              _tokenResult = _context2.sent;
              _context2.next = 40;
              return this.finishAuthentication(connection, credentials, _tokenResult, conversationId);

            case 40:
              result = _context2.sent;

            case 41:
              return _context2.abrupt("return", result);

            case 42:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[12, 18]]);
      }));

      function execute(_x2, _x3, _x4, _x5) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Starts the callback authentication process. If there is a speculative
     * authentication document from the initial handshake, then we will use that
     * value to get the issuer, otherwise we will send the saslStart command.
     */

  }, {
    key: "startAuthentication",
    value: function () {
      var _startAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection, credentials, reauthenticating, response) {
        var result;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!reauthenticating && response !== null && response !== void 0 && response.speculativeAuthenticate)) {
                _context3.next = 4;
                break;
              }

              result = response.speculativeAuthenticate;
              _context3.next = 7;
              break;

            case 4:
              _context3.next = 6;
              return connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);

            case 6:
              result = _context3.sent;

            case 7:
              return _context3.abrupt("return", result);

            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function startAuthentication(_x6, _x7, _x8, _x9) {
        return _startAuthentication.apply(this, arguments);
      }

      return startAuthentication;
    }()
    /**
     * Finishes the callback authentication process.
     */

  }, {
    key: "finishAuthentication",
    value: function () {
      var _finishAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection, credentials, tokenResult, conversationId) {
        var result;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);

            case 2:
              result = _context4.sent;
              return _context4.abrupt("return", result);

            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function finishAuthentication(_x10, _x11, _x12, _x13) {
        return _finishAuthentication.apply(this, arguments);
      }

      return finishAuthentication;
    }()
    /**
     * Fetches an access token using either the request or refresh callbacks and
     * puts it in the cache.
     */

  }, {
    key: "fetchAccessToken",
    value: function () {
      var _fetchAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {
        var entry, result, context;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              // Get the token from the cache.
              entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
              context = {
                timeoutSeconds: TIMEOUT_S,
                version: OIDC_VERSION
              }; // Check if there's a token in the cache.

              if (!entry) {
                _context5.next = 17;
                break;
              }

              if (!(entry.isValid() && !reauthenticating)) {
                _context5.next = 5;
                break;
              }

              return _context5.abrupt("return", entry.tokenResult);

            case 5:
              if (!refreshCallback) {
                _context5.next = 12;
                break;
              }

              context.refreshToken = entry.tokenResult.refreshToken;
              _context5.next = 9;
              return refreshCallback(serverInfo, context);

            case 9:
              result = _context5.sent;
              _context5.next = 15;
              break;

            case 12:
              _context5.next = 14;
              return requestCallback(serverInfo, context);

            case 14:
              result = _context5.sent;

            case 15:
              _context5.next = 20;
              break;

            case 17:
              _context5.next = 19;
              return requestCallback(serverInfo, context);

            case 19:
              result = _context5.sent;

            case 20:
              if (!isCallbackResultInvalid(result)) {
                _context5.next = 23;
                break;
              }

              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
              throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);

            case 23:
              // Cleanup the cache.
              this.cache.deleteExpiredEntries(); // Put the new entry into the cache.

              this.cache.addEntry(connection.address, credentials.username || '', callbackHash, result, serverInfo);
              return _context5.abrupt("return", result);

            case 26:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function fetchAccessToken(_x14, _x15, _x16, _x17, _x18, _x19, _x20) {
        return _fetchAccessToken.apply(this, arguments);
      }

      return fetchAccessToken;
    }()
  }]);

  return CallbackWorkflow;
}();

exports.CallbackWorkflow = CallbackWorkflow;
/**
 * Generate the finishing command document for authentication. Will be a
 * saslStart or saslContinue depending on the presence of a conversation id.
 */

function finishCommandDocument(token, conversationId) {
  if (conversationId != null && typeof conversationId === 'number') {
    return {
      saslContinue: 1,
      conversationId: conversationId,
      payload: new bson_1.Binary(bson_1.BSON.serialize({
        jwt: token
      }))
    };
  } // saslContinue requires a conversationId in the command to be valid so in this
  // case the server allows "step two" to actually be a saslStart with the token
  // as the jwt since the use of the cached value has no correlating conversating
  // on the particular connection.


  return {
    saslStart: 1,
    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
    payload: new bson_1.Binary(bson_1.BSON.serialize({
      jwt: token
    }))
  };
}
/**
 * Determines if a result returned from a request or refresh callback
 * function is invalid. This means the result is nullish, doesn't contain
 * the accessToken required field, and does not contain extra fields.
 */


function isCallbackResultInvalid(tokenResult) {
  if (tokenResult == null || _typeof(tokenResult) !== 'object') return true;
  if (!('accessToken' in tokenResult)) return true;
  return !Object.getOwnPropertyNames(tokenResult).every(function (prop) {
    return RESULT_PROPERTIES.includes(prop);
  });
}
/**
 * Generate the saslStart command document.
 */


function startCommandDocument(credentials) {
  var payload = {};

  if (credentials.username) {
    payload.n = credentials.username;
  }

  return {
    saslStart: 1,
    autoAuthorize: 1,
    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
  };
}

/***/ }),

/***/ 7379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.commandDocument = exports.ServiceWorkflow = void 0;

var bson_1 = __webpack_require__(8054);

var utils_1 = __webpack_require__(672);

var providers_1 = __webpack_require__(4923);
/**
 * Common behaviour for OIDC device workflows.
 * @internal
 */


var ServiceWorkflow = /*#__PURE__*/function () {
  function ServiceWorkflow() {
    _classCallCheck(this, ServiceWorkflow);
  }

  _createClass(ServiceWorkflow, [{
    key: "execute",
    value:
    /**
     * Execute the workflow. Looks for AWS_WEB_IDENTITY_TOKEN_FILE in the environment
     * and then attempts to read the token from that path.
     */
    function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, credentials) {
        var token, command;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.getToken(credentials);

            case 2:
              token = _context.sent;
              command = commandDocument(token);
              return _context.abrupt("return", connection.commandAsync((0, utils_1.ns)(credentials.source), command, undefined));

            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function execute(_x, _x2) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Get the document to add for speculative authentication.
     */

  }, {
    key: "speculativeAuth",
    value: function () {
      var _speculativeAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(credentials) {
        var token, document;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getToken(credentials);

            case 2:
              token = _context2.sent;
              document = commandDocument(token);
              document.db = credentials.source;
              return _context2.abrupt("return", {
                speculativeAuthenticate: document
              });

            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function speculativeAuth(_x3) {
        return _speculativeAuth.apply(this, arguments);
      }

      return speculativeAuth;
    }()
  }]);

  return ServiceWorkflow;
}();

exports.ServiceWorkflow = ServiceWorkflow;
/**
 * Create the saslStart command document.
 */

function commandDocument(token) {
  return {
    saslStart: 1,
    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
    payload: bson_1.BSON.serialize({
      jwt: token
    })
  };
}

exports.commandDocument = commandDocument;

/***/ }),

/***/ 1828:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TokenEntryCache = exports.TokenEntry = void 0;

var cache_1 = __webpack_require__(3758);
/* Default expiration is now for when no expiration provided */


var DEFAULT_EXPIRATION_SECS = 0;
/** @internal */

var TokenEntry = /*#__PURE__*/function (_cache_1$ExpiringCach) {
  _inherits(TokenEntry, _cache_1$ExpiringCach);

  var _super = _createSuper(TokenEntry);

  /**
   * Instantiate the entry.
   */
  function TokenEntry(tokenResult, serverInfo, expiration) {
    var _this;

    _classCallCheck(this, TokenEntry);

    _this = _super.call(this, expiration);
    _this.tokenResult = tokenResult;
    _this.serverInfo = serverInfo;
    return _this;
  }

  return _createClass(TokenEntry);
}(cache_1.ExpiringCacheEntry);

exports.TokenEntry = TokenEntry;
/**
 * Cache of OIDC token entries.
 * @internal
 */

var TokenEntryCache = /*#__PURE__*/function (_cache_1$Cache) {
  _inherits(TokenEntryCache, _cache_1$Cache);

  var _super2 = _createSuper(TokenEntryCache);

  function TokenEntryCache() {
    _classCallCheck(this, TokenEntryCache);

    return _super2.apply(this, arguments);
  }

  _createClass(TokenEntryCache, [{
    key: "addEntry",
    value:
    /**
     * Set an entry in the token cache.
     */
    function addEntry(address, username, callbackHash, tokenResult, serverInfo) {
      var _tokenResult$expiresI;

      var entry = new TokenEntry(tokenResult, serverInfo, (_tokenResult$expiresI = tokenResult.expiresInSeconds) !== null && _tokenResult$expiresI !== void 0 ? _tokenResult$expiresI : DEFAULT_EXPIRATION_SECS);
      this.entries.set(this.cacheKey(address, username, callbackHash), entry);
      return entry;
    }
    /**
     * Delete an entry from the cache.
     */

  }, {
    key: "deleteEntry",
    value: function deleteEntry(address, username, callbackHash) {
      this.entries["delete"](this.cacheKey(address, username, callbackHash));
    }
    /**
     * Get an entry from the cache.
     */

  }, {
    key: "getEntry",
    value: function getEntry(address, username, callbackHash) {
      return this.entries.get(this.cacheKey(address, username, callbackHash));
    }
    /**
     * Delete all expired entries from the cache.
     */

  }, {
    key: "deleteExpiredEntries",
    value: function deleteExpiredEntries() {
      var _iterator = _createForOfIteratorHelper(this.entries),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value2 = _slicedToArray(_step.value, 2),
              key = _step$value2[0],
              entry = _step$value2[1];

          if (!entry.isValid()) {
            this.entries["delete"](key);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Create a cache key from the address and username.
     */

  }, {
    key: "cacheKey",
    value: function cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }]);

  return TokenEntryCache;
}(cache_1.Cache);

exports.TokenEntryCache = TokenEntryCache;

/***/ }),

/***/ 4889:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Plain = void 0;

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var Plain = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(Plain, _auth_provider_1$Auth);

  var _super = _createSuper(Plain);

  function Plain() {
    _classCallCheck(this, Plain);

    return _super.apply(this, arguments);
  }

  _createClass(Plain, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authContext) {
        var connection, credentials, username, password, payload, command;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              connection = authContext.connection, credentials = authContext.credentials;

              if (credentials) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 3:
              username = credentials.username, password = credentials.password;
              payload = new bson_1.Binary(Buffer.from("\0".concat(username, "\0").concat(password)));
              command = {
                saslStart: 1,
                mechanism: 'PLAIN',
                payload: payload,
                autoAuthorize: 1
              };
              _context.next = 8;
              return connection.commandAsync((0, utils_1.ns)('$external.$cmd'), command, undefined);

            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function auth(_x) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return Plain;
}(auth_provider_1.AuthProvider);

exports.Plain = Plain;

/***/ }),

/***/ 4923:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = void 0;
/** @public */

exports.AuthMechanism = Object.freeze({
  MONGODB_AWS: 'MONGODB-AWS',
  MONGODB_CR: 'MONGODB-CR',
  MONGODB_DEFAULT: 'DEFAULT',
  MONGODB_GSSAPI: 'GSSAPI',
  MONGODB_PLAIN: 'PLAIN',
  MONGODB_SCRAM_SHA1: 'SCRAM-SHA-1',
  MONGODB_SCRAM_SHA256: 'SCRAM-SHA-256',
  MONGODB_X509: 'MONGODB-X509',

  /** @experimental */
  MONGODB_OIDC: 'MONGODB-OIDC'
});
/** @internal */

exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([exports.AuthMechanism.MONGODB_GSSAPI, exports.AuthMechanism.MONGODB_AWS, exports.AuthMechanism.MONGODB_OIDC, exports.AuthMechanism.MONGODB_X509]);

/***/ }),

/***/ 1001:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ScramSHA256 = exports.ScramSHA1 = void 0;

var crypto = __webpack_require__(6113);

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(4356);

var deps_1 = __webpack_require__(8310);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var providers_1 = __webpack_require__(4923);

var ScramSHA = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(ScramSHA, _auth_provider_1$Auth);

  var _super = _createSuper(ScramSHA);

  function ScramSHA(cryptoMethod) {
    var _this;

    _classCallCheck(this, ScramSHA);

    _this = _super.call(this);
    _this.cryptoMethod = cryptoMethod || 'sha1';
    _this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);
    return _this;
  }

  _createClass(ScramSHA, [{
    key: "prepare",
    value: function () {
      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handshakeDoc, authContext) {
        var cryptoMethod, credentials, nonce, request;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              cryptoMethod = this.cryptoMethod;
              credentials = authContext.credentials;

              if (credentials) {
                _context.next = 4;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 4:
              if (cryptoMethod === 'sha256' && ('kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function')) {
                (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');
              }

              _context.next = 7;
              return this.randomBytesAsync(24);

            case 7:
              nonce = _context.sent;
              // store the nonce for later use
              authContext.nonce = nonce;
              request = _objectSpread(_objectSpread({}, handshakeDoc), {}, {
                speculativeAuthenticate: _objectSpread(_objectSpread({}, makeFirstMessage(cryptoMethod, credentials, nonce)), {}, {
                  db: credentials.source
                })
              });
              return _context.abrupt("return", request);

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function prepare(_x, _x2) {
        return _prepare.apply(this, arguments);
      }

      return prepare;
    }()
  }, {
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authContext) {
        var reauthenticating, response;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              reauthenticating = authContext.reauthenticating, response = authContext.response;

              if (!(response !== null && response !== void 0 && response.speculativeAuthenticate && !reauthenticating)) {
                _context2.next = 3;
                break;
              }

              return _context2.abrupt("return", continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext));

            case 3:
              return _context2.abrupt("return", executeScram(this.cryptoMethod, authContext));

            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function auth(_x3) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return ScramSHA;
}(auth_provider_1.AuthProvider);

function cleanUsername(username) {
  return username.replace('=', '=3D').replace(',', '=2C');
}

function clientFirstMessageBare(username, nonce) {
  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.
  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);
}

function makeFirstMessage(cryptoMethod, credentials, nonce) {
  var username = cleanUsername(credentials.username);
  var mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.

  return {
    saslStart: 1,
    mechanism: mechanism,
    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),
    autoAuthorize: 1,
    options: {
      skipEmptyExchange: true
    }
  };
}

function executeScram(_x4, _x5) {
  return _executeScram.apply(this, arguments);
}

function _executeScram() {
  _executeScram = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cryptoMethod, authContext) {
    var connection, credentials, nonce, db, saslStartCmd, response;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          connection = authContext.connection, credentials = authContext.credentials;

          if (credentials) {
            _context3.next = 3;
            break;
          }

          throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

        case 3:
          if (authContext.nonce) {
            _context3.next = 5;
            break;
          }

          throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');

        case 5:
          nonce = authContext.nonce;
          db = credentials.source;
          saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
          _context3.next = 10;
          return connection.commandAsync((0, utils_1.ns)("".concat(db, ".$cmd")), saslStartCmd, undefined);

        case 10:
          response = _context3.sent;
          _context3.next = 13;
          return continueScramConversation(cryptoMethod, response, authContext);

        case 13:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _executeScram.apply(this, arguments);
}

function continueScramConversation(_x6, _x7, _x8) {
  return _continueScramConversation.apply(this, arguments);
}

function _continueScramConversation() {
  _continueScramConversation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cryptoMethod, response, authContext) {
    var connection, credentials, nonce, db, username, password, processedPassword, payload, dict, iterations, salt, rnonce, withoutProof, saltedPassword, clientKey, serverKey, storedKey, authMessage, clientSignature, clientProof, clientFinal, serverSignature, saslContinueCmd, r, parsedResponse, retrySaslContinueCmd;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          connection = authContext.connection;
          credentials = authContext.credentials;

          if (credentials) {
            _context4.next = 4;
            break;
          }

          throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

        case 4:
          if (authContext.nonce) {
            _context4.next = 6;
            break;
          }

          throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');

        case 6:
          nonce = authContext.nonce;
          db = credentials.source;
          username = cleanUsername(credentials.username);
          password = credentials.password;

          if (cryptoMethod === 'sha256') {
            processedPassword = 'kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function' ? password : (0, deps_1.saslprep)(password);
          } else {
            processedPassword = passwordDigest(username, password);
          }

          payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
          dict = parsePayload(payload.value());
          iterations = parseInt(dict.i, 10);

          if (!(iterations && iterations < 4096)) {
            _context4.next = 16;
            break;
          }

          throw new error_1.MongoRuntimeError("Server returned an invalid iteration count ".concat(iterations));

        case 16:
          salt = dict.s;
          rnonce = dict.r;

          if (!rnonce.startsWith('nonce')) {
            _context4.next = 20;
            break;
          }

          throw new error_1.MongoRuntimeError("Server returned an invalid nonce: ".concat(rnonce));

        case 20:
          // Set up start of proof
          withoutProof = "c=biws,r=".concat(rnonce);
          saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);
          clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');
          serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');
          storedKey = H(cryptoMethod, clientKey);
          authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');
          clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
          clientProof = "p=".concat(xor(clientKey, clientSignature));
          clientFinal = [withoutProof, clientProof].join(',');
          serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
          saslContinueCmd = {
            saslContinue: 1,
            conversationId: response.conversationId,
            payload: new bson_1.Binary(Buffer.from(clientFinal))
          };
          _context4.next = 33;
          return connection.commandAsync((0, utils_1.ns)("".concat(db, ".$cmd")), saslContinueCmd, undefined);

        case 33:
          r = _context4.sent;
          parsedResponse = parsePayload(r.payload.value());

          if (compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {
            _context4.next = 37;
            break;
          }

          throw new error_1.MongoRuntimeError('Server returned an invalid signature');

        case 37:
          if (!(r.done !== false)) {
            _context4.next = 39;
            break;
          }

          return _context4.abrupt("return");

        case 39:
          retrySaslContinueCmd = {
            saslContinue: 1,
            conversationId: r.conversationId,
            payload: Buffer.alloc(0)
          };
          _context4.next = 42;
          return connection.commandAsync((0, utils_1.ns)("".concat(db, ".$cmd")), retrySaslContinueCmd, undefined);

        case 42:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _continueScramConversation.apply(this, arguments);
}

function parsePayload(payload) {
  var dict = {};
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) {
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  }

  return dict;
}

function passwordDigest(username, password) {
  if (typeof username !== 'string') {
    throw new error_1.MongoInvalidArgumentError('Username must be a string');
  }

  if (typeof password !== 'string') {
    throw new error_1.MongoInvalidArgumentError('Password must be a string');
  }

  if (password.length === 0) {
    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');
  }

  var md5;

  try {
    md5 = crypto.createHash('md5');
  } catch (err) {
    if (crypto.getFips()) {
      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.
      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'
      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');
    }

    throw err;
  }

  md5.update("".concat(username, ":mongo:").concat(password), 'utf8');
  return md5.digest('hex');
} // XOR two buffers


function xor(a, b) {
  if (!Buffer.isBuffer(a)) {
    a = Buffer.from(a);
  }

  if (!Buffer.isBuffer(b)) {
    b = Buffer.from(b);
  }

  var length = Math.max(a.length, b.length);
  var res = [];

  for (var i = 0; i < length; i += 1) {
    res.push(a[i] ^ b[i]);
  }

  return Buffer.from(res).toString('base64');
}

function H(method, text) {
  return crypto.createHash(method).update(text).digest();
}

function HMAC(method, key, text) {
  return crypto.createHmac(method, key).update(text).digest();
}

var _hiCache = {};
var _hiCacheCount = 0;

function _hiCachePurge() {
  _hiCache = {};
  _hiCacheCount = 0;
}

var hiLengthMap = {
  sha256: 32,
  sha1: 20
};

function HI(data, salt, iterations, cryptoMethod) {
  // omit the work if already generated
  var key = [data, salt.toString('base64'), iterations].join('_');

  if (_hiCache[key] != null) {
    return _hiCache[key];
  } // generate the salt


  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth

  if (_hiCacheCount >= 200) {
    _hiCachePurge();
  }

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
}

function compareDigest(lhs, rhs) {
  if (lhs.length !== rhs.length) {
    return false;
  }

  if (typeof crypto.timingSafeEqual === 'function') {
    return crypto.timingSafeEqual(lhs, rhs);
  }

  var result = 0;

  for (var i = 0; i < lhs.length; i++) {
    result |= lhs[i] ^ rhs[i];
  }

  return result === 0;
}

var ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {
  _inherits(ScramSHA1, _ScramSHA);

  var _super2 = _createSuper(ScramSHA1);

  function ScramSHA1() {
    _classCallCheck(this, ScramSHA1);

    return _super2.call(this, 'sha1');
  }

  return _createClass(ScramSHA1);
}(ScramSHA);

exports.ScramSHA1 = ScramSHA1;

var ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {
  _inherits(ScramSHA256, _ScramSHA2);

  var _super3 = _createSuper(ScramSHA256);

  function ScramSHA256() {
    _classCallCheck(this, ScramSHA256);

    return _super3.call(this, 'sha256');
  }

  return _createClass(ScramSHA256);
}(ScramSHA);

exports.ScramSHA256 = ScramSHA256;

/***/ }),

/***/ 7223:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.X509 = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var X509 = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(X509, _auth_provider_1$Auth);

  var _super = _createSuper(X509);

  function X509() {
    _classCallCheck(this, X509);

    return _super.apply(this, arguments);
  }

  _createClass(X509, [{
    key: "prepare",
    value: function () {
      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handshakeDoc, authContext) {
        var credentials;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              credentials = authContext.credentials;

              if (credentials) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 3:
              return _context.abrupt("return", _objectSpread(_objectSpread({}, handshakeDoc), {}, {
                speculativeAuthenticate: x509AuthenticateCommand(credentials)
              }));

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function prepare(_x, _x2) {
        return _prepare.apply(this, arguments);
      }

      return prepare;
    }()
  }, {
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authContext) {
        var connection, credentials, response;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              connection = authContext.connection;
              credentials = authContext.credentials;

              if (credentials) {
                _context2.next = 4;
                break;
              }

              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');

            case 4:
              response = authContext.response;

              if (!(response !== null && response !== void 0 && response.speculativeAuthenticate)) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return");

            case 7:
              _context2.next = 9;
              return connection.commandAsync((0, utils_1.ns)('$external.$cmd'), x509AuthenticateCommand(credentials), undefined);

            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function auth(_x3) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
  }]);

  return X509;
}(auth_provider_1.AuthProvider);

exports.X509 = X509;

function x509AuthenticateCommand(credentials) {
  var command = {
    authenticate: 1,
    mechanism: 'MONGODB-X509'
  };

  if (credentials.username) {
    command.user = credentials.username;
  }

  return command;
}

/***/ }),

/***/ 4482:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;

var constants_1 = __webpack_require__(9592);

var utils_1 = __webpack_require__(672);

var commands_1 = __webpack_require__(7136);
/**
 * An event indicating the start of a given
 * @public
 * @category Event
 */


var CommandStartedEvent = /*#__PURE__*/function () {
  /**
   * Create a started event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   */
  function CommandStartedEvent(connection, command) {
    _classCallCheck(this, CommandStartedEvent);

    /** @internal */
    this.name = constants_1.COMMAND_STARTED;
    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet = extractConnectionDetails(connection),
        address = _extractConnectionDet.address,
        connectionId = _extractConnectionDet.connectionId,
        serviceId = _extractConnectionDet.serviceId; // TODO: remove in major revision, this is not spec behavior


    if (exports.SENSITIVE_COMMANDS.has(commandName)) {
      this.commandObj = {};
      this.commandObj[commandName] = true;
    }

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.databaseName = databaseName(command);
    this.commandName = commandName;
    this.command = maybeRedact(commandName, cmd, cmd);
  }
  /* @internal */


  _createClass(CommandStartedEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandStartedEvent;
}();

exports.CommandStartedEvent = CommandStartedEvent;
/**
 * An event indicating the success of a given command
 * @public
 * @category Event
 */

var CommandSucceededEvent = /*#__PURE__*/function () {
  /**
   * Create a succeeded event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   * @param reply - the reply for this command from the server
   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  function CommandSucceededEvent(connection, command, reply, started) {
    _classCallCheck(this, CommandSucceededEvent);

    /** @internal */
    this.name = constants_1.COMMAND_SUCCEEDED;
    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet2 = extractConnectionDetails(connection),
        address = _extractConnectionDet2.address,
        connectionId = _extractConnectionDet2.connectionId,
        serviceId = _extractConnectionDet2.serviceId;

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.commandName = commandName;
    this.duration = (0, utils_1.calculateDurationInMs)(started);
    this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
  }
  /* @internal */


  _createClass(CommandSucceededEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandSucceededEvent;
}();

exports.CommandSucceededEvent = CommandSucceededEvent;
/**
 * An event indicating the failure of a given command
 * @public
 * @category Event
 */

var CommandFailedEvent = /*#__PURE__*/function () {
  /**
   * Create a failure event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   * @param error - the generated error or a server error response
   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  function CommandFailedEvent(connection, command, error, started) {
    _classCallCheck(this, CommandFailedEvent);

    /** @internal */
    this.name = constants_1.COMMAND_FAILED;
    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet3 = extractConnectionDetails(connection),
        address = _extractConnectionDet3.address,
        connectionId = _extractConnectionDet3.connectionId,
        serviceId = _extractConnectionDet3.serviceId;

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.commandName = commandName;
    this.duration = (0, utils_1.calculateDurationInMs)(started);
    this.failure = maybeRedact(commandName, cmd, error);
  }
  /* @internal */


  _createClass(CommandFailedEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandFailedEvent;
}();

exports.CommandFailedEvent = CommandFailedEvent;
/**
 * Commands that we want to redact because of the sensitive nature of their contents
 * @internal
 */

exports.SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);
var HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]); // helper methods

var extractCommandName = function extractCommandName(commandDoc) {
  return Object.keys(commandDoc)[0];
};

var namespace = function namespace(command) {
  return command.ns;
};

var databaseName = function databaseName(command) {
  return command.ns.split('.')[0];
};

var collectionName = function collectionName(command) {
  return command.ns.split('.')[1];
};

var maybeRedact = function maybeRedact(commandName, commandDoc, result) {
  return exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
};

var LEGACY_FIND_QUERY_MAP = {
  $query: 'filter',
  $orderby: 'sort',
  $hint: 'hint',
  $comment: 'comment',
  $maxScan: 'maxScan',
  $max: 'max',
  $min: 'min',
  $returnKey: 'returnKey',
  $showDiskLoc: 'showRecordId',
  $maxTimeMS: 'maxTimeMS',
  $snapshot: 'snapshot'
};
var LEGACY_FIND_OPTIONS_MAP = {
  numberToSkip: 'skip',
  numberToReturn: 'batchSize',
  returnFieldSelector: 'projection'
};
var OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];
/** Extract the actual command from the query, possibly up-converting if it's a legacy format */

function extractCommand(command) {
  var _command$query;

  if (command instanceof commands_1.Msg) {
    return (0, utils_1.deepCopy)(command.command);
  }

  if ((_command$query = command.query) !== null && _command$query !== void 0 && _command$query.$query) {
    var result;

    if (command.ns === 'admin.$cmd') {
      // up-convert legacy command
      result = Object.assign({}, command.query.$query);
    } else {
      // up-convert legacy find command
      result = {
        find: collectionName(command)
      };
      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(function (key) {
        if (command.query[key] != null) {
          result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
        }
      });
    }

    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(function (key) {
      var legacyKey = key;

      if (command[legacyKey] != null) {
        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
      }
    });
    OP_QUERY_KEYS.forEach(function (key) {
      if (command[key]) {
        result[key] = command[key];
      }
    });

    if (command.pre32Limit != null) {
      result.limit = command.pre32Limit;
    }

    if (command.query.$explain) {
      return {
        explain: result
      };
    }

    return result;
  }

  var clonedQuery = {};
  var clonedCommand = {};

  if (command.query) {
    for (var k in command.query) {
      clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
    }

    clonedCommand.query = clonedQuery;
  }

  for (var _k2 in command) {
    if (_k2 === 'query') continue;
    clonedCommand[_k2] = (0, utils_1.deepCopy)(command[_k2]);
  }

  return command.query ? clonedQuery : clonedCommand;
}

function extractReply(command, reply) {
  if (!reply) {
    return reply;
  }

  if (command instanceof commands_1.Msg) {
    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
  } // is this a legacy find command?


  if (command.query && command.query.$query != null) {
    return {
      ok: 1,
      cursor: {
        id: (0, utils_1.deepCopy)(reply.cursorId),
        ns: namespace(command),
        firstBatch: (0, utils_1.deepCopy)(reply.documents)
      }
    };
  }

  return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
}

function extractConnectionDetails(connection) {
  var connectionId;

  if ('id' in connection) {
    connectionId = connection.id;
  }

  return {
    address: connection.address,
    serviceId: connection.serviceId,
    connectionId: connectionId
  };
}

/***/ }),

/***/ 7136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BinMsg = exports.Msg = exports.Response = exports.Query = void 0;

var BSON = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var constants_1 = __webpack_require__(7154); // Incrementing request id


var _requestId = 0; // Query flags

var OPTS_TAILABLE_CURSOR = 2;
var OPTS_SECONDARY = 4;
var OPTS_OPLOG_REPLAY = 8;
var OPTS_NO_CURSOR_TIMEOUT = 16;
var OPTS_AWAIT_DATA = 32;
var OPTS_EXHAUST = 64;
var OPTS_PARTIAL = 128; // Response flags

var CURSOR_NOT_FOUND = 1;
var QUERY_FAILURE = 2;
var SHARD_CONFIG_STALE = 4;
var AWAIT_CAPABLE = 8;
/**************************************************************
 * QUERY
 **************************************************************/

/** @internal */

var Query = /*#__PURE__*/function () {
  function Query(ns, query, options) {
    _classCallCheck(this, Query);

    // Basic options needed to be passed in
    // TODO(NODE-3483): Replace with MongoCommandError
    if (ns == null) throw new error_1.MongoRuntimeError('Namespace must be specified for query'); // TODO(NODE-3483): Replace with MongoCommandError

    if (query == null) throw new error_1.MongoRuntimeError('A query document must be specified for query'); // Validate that we are not passing 0x00 in the collection name

    if (ns.indexOf('\x00') !== -1) {
      // TODO(NODE-3483): Use MongoNamespace static method
      throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');
    } // Basic options


    this.ns = ns;
    this.query = query; // Additional options

    this.numberToSkip = options.numberToSkip || 0;
    this.numberToReturn = options.numberToReturn || 0;
    this.returnFieldSelector = options.returnFieldSelector || undefined;
    this.requestId = Query.getRequestId(); // special case for pre-3.2 find commands, delete ASAP

    this.pre32Limit = options.pre32Limit; // Serialization option

    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    this.batchSize = this.numberToReturn; // Flags

    this.tailable = false;
    this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;
    this.oplogReplay = false;
    this.noCursorTimeout = false;
    this.awaitData = false;
    this.exhaust = false;
    this.partial = false;
  }
  /** Assign next request Id. */


  _createClass(Query, [{
    key: "incRequestId",
    value: function incRequestId() {
      this.requestId = _requestId++;
    }
    /** Peek next request Id. */

  }, {
    key: "nextRequestId",
    value: function nextRequestId() {
      return _requestId + 1;
    }
    /** Increment then return next request Id. */

  }, {
    key: "toBin",
    value: // Uses a single allocated buffer for the process, avoiding multiple memory allocations
    function toBin() {
      var buffers = [];
      var projection = null; // Set up the flags

      var flags = 0;

      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }

      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }

      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }

      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }

      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }

      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }

      if (this.partial) {
        flags |= OPTS_PARTIAL;
      } // If batchSize is different to this.numberToReturn


      if (this.batchSize !== this.numberToReturn) this.numberToReturn = this.batchSize; // Allocate write protocol header buffer

      var header = Buffer.alloc(4 * 4 + // Header
      4 + // Flags
      Buffer.byteLength(this.ns) + 1 + // namespace
      4 + // numberToSkip
      4 // numberToReturn
      ); // Add header to buffers

      buffers.push(header); // Serialize the query

      var query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      }); // Add query document

      buffers.push(query);

      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        // Serialize the projection document
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        }); // Add projection document

        buffers.push(projection);
      } // Total message size


      var totalLength = header.length + query.length + (projection ? projection.length : 0); // Set up the index

      var index = 4; // Write total document length

      header[3] = totalLength >> 24 & 0xff;
      header[2] = totalLength >> 16 & 0xff;
      header[1] = totalLength >> 8 & 0xff;
      header[0] = totalLength & 0xff; // Write header information requestId

      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4; // Write header information responseTo

      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4; // Write header information OP_QUERY

      header[index + 3] = constants_1.OP_QUERY >> 24 & 0xff;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 0xff;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 0xff;
      header[index] = constants_1.OP_QUERY & 0xff;
      index = index + 4; // Write header information flags

      header[index + 3] = flags >> 24 & 0xff;
      header[index + 2] = flags >> 16 & 0xff;
      header[index + 1] = flags >> 8 & 0xff;
      header[index] = flags & 0xff;
      index = index + 4; // Write collection name

      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0; // Write header information flags numberToSkip

      header[index + 3] = this.numberToSkip >> 24 & 0xff;
      header[index + 2] = this.numberToSkip >> 16 & 0xff;
      header[index + 1] = this.numberToSkip >> 8 & 0xff;
      header[index] = this.numberToSkip & 0xff;
      index = index + 4; // Write header information flags numberToReturn

      header[index + 3] = this.numberToReturn >> 24 & 0xff;
      header[index + 2] = this.numberToReturn >> 16 & 0xff;
      header[index + 1] = this.numberToReturn >> 8 & 0xff;
      header[index] = this.numberToReturn & 0xff;
      index = index + 4; // Return the buffers

      return buffers;
    }
  }], [{
    key: "getRequestId",
    value: function getRequestId() {
      return ++_requestId;
    }
  }]);

  return Query;
}();

exports.Query = Query;
/** @internal */

var Response = /*#__PURE__*/function () {
  function Response(message, msgHeader, msgBody, opts) {
    _classCallCheck(this, Response);

    this.documents = new Array(0);
    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.opts = opts !== null && opts !== void 0 ? opts : {
      useBigInt64: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    }; // Read the message header

    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed; // Flag values

    this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
  }

  _createClass(Response, [{
    key: "isParsed",
    value: function isParsed() {
      return this.parsed;
    }
  }, {
    key: "parse",
    value: function parse(options) {
      var _options2, _options$useBigInt, _options$promoteLongs, _options$promoteValue, _options$promoteBuffe, _options$bsonRegExp;

      // Don't parse again if not needed
      if (this.parsed) return;
      options = (_options2 = options) !== null && _options2 !== void 0 ? _options2 : {}; // Allow the return of raw documents instead of parsing

      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var useBigInt64 = (_options$useBigInt = options.useBigInt64) !== null && _options$useBigInt !== void 0 ? _options$useBigInt : this.opts.useBigInt64;
      var promoteLongs = (_options$promoteLongs = options.promoteLongs) !== null && _options$promoteLongs !== void 0 ? _options$promoteLongs : this.opts.promoteLongs;
      var promoteValues = (_options$promoteValue = options.promoteValues) !== null && _options$promoteValue !== void 0 ? _options$promoteValue : this.opts.promoteValues;
      var promoteBuffers = (_options$promoteBuffe = options.promoteBuffers) !== null && _options$promoteBuffe !== void 0 ? _options$promoteBuffe : this.opts.promoteBuffers;
      var bsonRegExp = (_options$bsonRegExp = options.bsonRegExp) !== null && _options$bsonRegExp !== void 0 ? _options$bsonRegExp : this.opts.bsonRegExp;
      var bsonSize; // Set up the options

      var _options = {
        useBigInt64: useBigInt64,
        promoteLongs: promoteLongs,
        promoteValues: promoteValues,
        promoteBuffers: promoteBuffers,
        bsonRegExp: bsonRegExp
      }; // Position within OP_REPLY at which documents start
      // (See https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#wire-op-reply)

      this.index = 20; // Read the message body

      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16); // Preallocate document array

      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0; // Parse Body

      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24; // If we have raw results specified slice the return document

        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        } // Adjust the index


        this.index = this.index + bsonSize;
      }

      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        var fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        var doc = BSON.deserialize(this.documents[0], _options);
        this.documents = [doc];
      } // Set parsed


      this.parsed = true;
    }
  }]);

  return Response;
}();

exports.Response = Response; // Implementation of OP_MSG spec:
// https://github.com/mongodb/specifications/blob/master/source/message/OP_MSG.rst
//
// struct Section {
//   uint8 payloadType;
//   union payload {
//       document  document; // payloadType == 0
//       struct sequence { // payloadType == 1
//           int32      size;
//           cstring    identifier;
//           document*  documents;
//       };
//   };
// };
// struct OP_MSG {
//   struct MsgHeader {
//       int32  messageLength;
//       int32  requestID;
//       int32  responseTo;
//       int32  opCode = 2013;
//   };
//   uint32      flagBits;
//   Section+    sections;
//   [uint32     checksum;]
// };
// Msg Flags

var OPTS_CHECKSUM_PRESENT = 1;
var OPTS_MORE_TO_COME = 2;
var OPTS_EXHAUST_ALLOWED = 1 << 16;
/** @internal */

var Msg = /*#__PURE__*/function () {
  function Msg(ns, command, options) {
    _classCallCheck(this, Msg);

    // Basic options needed to be passed in
    if (command == null) throw new error_1.MongoInvalidArgumentError('Query document must be specified for query'); // Basic options

    this.ns = ns;
    this.command = command;
    this.command.$db = (0, utils_1.databaseNamespace)(ns);

    if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {
      this.command.$readPreference = options.readPreference.toJSON();
    } // Ensure empty options


    this.options = options !== null && options !== void 0 ? options : {}; // Additional options

    this.requestId = options.requestId ? options.requestId : Msg.getRequestId(); // Serialization option

    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16; // flags

    this.checksumPresent = false;
    this.moreToCome = options.moreToCome || false;
    this.exhaustAllowed = typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;
  }

  _createClass(Msg, [{
    key: "toBin",
    value: function toBin() {
      var buffers = [];
      var flags = 0;

      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }

      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }

      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }

      var header = Buffer.alloc(4 * 4 + // Header
      4 // Flags
      );
      buffers.push(header);
      var totalLength = header.length;
      var command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0); // messageLength

      header.writeInt32LE(this.requestId, 4); // requestID

      header.writeInt32LE(0, 8); // responseTo

      header.writeInt32LE(constants_1.OP_MSG, 12); // opCode

      header.writeUInt32LE(flags, 16); // flags

      return buffers;
    }
  }, {
    key: "makeDocumentSegment",
    value: function makeDocumentSegment(buffers, document) {
      var payloadTypeBuffer = Buffer.alloc(1);
      payloadTypeBuffer[0] = 0;
      var documentBuffer = this.serializeBson(document);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
  }, {
    key: "serializeBson",
    value: function serializeBson(document) {
      return BSON.serialize(document, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
  }], [{
    key: "getRequestId",
    value: function getRequestId() {
      _requestId = _requestId + 1 & 0x7fffffff;
      return _requestId;
    }
  }]);

  return Msg;
}();

exports.Msg = Msg;
/** @internal */

var BinMsg = /*#__PURE__*/function () {
  function BinMsg(message, msgHeader, msgBody, opts) {
    _classCallCheck(this, BinMsg);

    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.opts = opts !== null && opts !== void 0 ? opts : {
      useBigInt64: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    }; // Read the message header

    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed; // Read response flags

    this.responseFlags = msgBody.readInt32LE(0);
    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
    this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
    this.documents = [];
  }

  _createClass(BinMsg, [{
    key: "isParsed",
    value: function isParsed() {
      return this.parsed;
    }
  }, {
    key: "parse",
    value: function parse(options) {
      var _options3, _options$useBigInt2, _options$promoteLongs2, _options$promoteValue2, _options$promoteBuffe2, _options$bsonRegExp2;

      // Don't parse again if not needed
      if (this.parsed) return;
      options = (_options3 = options) !== null && _options3 !== void 0 ? _options3 : {};
      this.index = 4; // Allow the return of raw documents instead of parsing

      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var useBigInt64 = (_options$useBigInt2 = options.useBigInt64) !== null && _options$useBigInt2 !== void 0 ? _options$useBigInt2 : this.opts.useBigInt64;
      var promoteLongs = (_options$promoteLongs2 = options.promoteLongs) !== null && _options$promoteLongs2 !== void 0 ? _options$promoteLongs2 : this.opts.promoteLongs;
      var promoteValues = (_options$promoteValue2 = options.promoteValues) !== null && _options$promoteValue2 !== void 0 ? _options$promoteValue2 : this.opts.promoteValues;
      var promoteBuffers = (_options$promoteBuffe2 = options.promoteBuffers) !== null && _options$promoteBuffe2 !== void 0 ? _options$promoteBuffe2 : this.opts.promoteBuffers;
      var bsonRegExp = (_options$bsonRegExp2 = options.bsonRegExp) !== null && _options$bsonRegExp2 !== void 0 ? _options$bsonRegExp2 : this.opts.bsonRegExp;
      var validation = this.parseBsonSerializationOptions(options); // Set up the options

      var bsonOptions = {
        useBigInt64: useBigInt64,
        promoteLongs: promoteLongs,
        promoteValues: promoteValues,
        promoteBuffers: promoteBuffers,
        bsonRegExp: bsonRegExp,
        validation: validation // Due to the strictness of the BSON libraries validation option we need this cast

      };

      while (this.index < this.data.length) {
        var payloadType = this.data.readUInt8(this.index++);

        if (payloadType === 0) {
          var bsonSize = this.data.readUInt32LE(this.index);
          var bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));
          this.index += bsonSize;
        } else if (payloadType === 1) {
          // It was decided that no driver makes use of payload type 1
          // TODO(NODE-3483): Replace with MongoDeprecationError
          throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');
        }
      }

      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        var fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        bsonOptions.fieldsAsRaw = fieldsAsRaw;
        var doc = BSON.deserialize(this.documents[0], bsonOptions);
        this.documents = [doc];
      }

      this.parsed = true;
    }
  }, {
    key: "parseBsonSerializationOptions",
    value: function parseBsonSerializationOptions(_ref) {
      var enableUtf8Validation = _ref.enableUtf8Validation;

      if (enableUtf8Validation === false) {
        return {
          utf8: false
        };
      }

      return {
        utf8: {
          writeErrors: false
        }
      };
    }
  }]);

  return BinMsg;
}();

exports.BinMsg = BinMsg;

/***/ }),

/***/ 8338:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = void 0;

var net = __webpack_require__(1808);

var socks_1 = __webpack_require__(1048);

var tls = __webpack_require__(4404);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var auth_provider_1 = __webpack_require__(3264);

var gssapi_1 = __webpack_require__(7874);

var mongocr_1 = __webpack_require__(9406);

var mongodb_aws_1 = __webpack_require__(4406);

var mongodb_oidc_1 = __webpack_require__(8990);

var plain_1 = __webpack_require__(4889);

var providers_1 = __webpack_require__(4923);

var scram_1 = __webpack_require__(1001);

var x509_1 = __webpack_require__(7223);

var connection_1 = __webpack_require__(9532);

var constants_2 = __webpack_require__(7154);
/** @internal */


exports.AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);

function connect(options, callback) {
  makeConnection(_objectSpread(_objectSpread({}, options), {}, {
    existingSocket: undefined
  }), function (err, socket) {
    var _options$connectionTy;

    if (err || !socket) {
      return callback(err);
    }

    var ConnectionType = (_options$connectionTy = options.connectionType) !== null && _options$connectionTy !== void 0 ? _options$connectionTy : connection_1.Connection;

    if (options.autoEncrypter) {
      ConnectionType = connection_1.CryptoConnection;
    }

    var connection = new ConnectionType(socket, options);
    performInitialHandshake(connection, options).then(function () {
      return callback(undefined, connection);
    }, function (error) {
      connection.destroy({
        force: false
      });
      callback(error);
    });
  });
}

exports.connect = connect;

function checkSupportedServer(hello, options) {
  var _JSON$stringify;

  var maxWireVersion = Number(hello.maxWireVersion);
  var minWireVersion = Number(hello.minWireVersion);
  var serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
  var serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;

  if (serverVersionHighEnough) {
    if (serverVersionLowEnough) {
      return null;
    }

    var _message = "Server at ".concat(options.hostAddress, " reports minimum wire version ").concat(JSON.stringify(hello.minWireVersion), ", but this version of the Node.js Driver requires at most ").concat(constants_2.MAX_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(constants_2.MAX_SUPPORTED_SERVER_VERSION, ")");

    return new error_1.MongoCompatibilityError(_message);
  }

  var message = "Server at ".concat(options.hostAddress, " reports maximum wire version ").concat((_JSON$stringify = JSON.stringify(hello.maxWireVersion)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 0, ", but this version of the Node.js Driver requires at least ").concat(constants_2.MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(constants_2.MIN_SUPPORTED_SERVER_VERSION, ")");
  return new error_1.MongoCompatibilityError(message);
}

function performInitialHandshake(_x, _x2) {
  return _performInitialHandshake.apply(this, arguments);
}
/**
 * @internal
 *
 * This function is only exposed for testing purposes.
 */


function _performInitialHandshake() {
  _performInitialHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(conn, options) {
    var credentials, authContext, handshakeDoc, handshakeOptions, start, response, supportedServerErr, resolvedCredentials, provider;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          credentials = options.credentials;

          if (!credentials) {
            _context.next = 4;
            break;
          }

          if (!(!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism))) {
            _context.next = 4;
            break;
          }

          throw new error_1.MongoInvalidArgumentError("AuthMechanism '".concat(credentials.mechanism, "' not supported"));

        case 4:
          authContext = new auth_provider_1.AuthContext(conn, credentials, options);
          conn.authContext = authContext;
          _context.next = 8;
          return prepareHandshakeDocument(authContext);

        case 8:
          handshakeDoc = _context.sent;
          // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options
          handshakeOptions = _objectSpread({}, options);

          if (typeof options.connectTimeoutMS === 'number') {
            // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS
            handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
          }

          start = new Date().getTime();
          _context.next = 14;
          return conn.commandAsync((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);

        case 14:
          response = _context.sent;

          if (!('isWritablePrimary' in response)) {
            // Provide hello-style response document.
            response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
          }

          if (response.helloOk) {
            conn.helloOk = true;
          }

          supportedServerErr = checkSupportedServer(response, options);

          if (!supportedServerErr) {
            _context.next = 20;
            break;
          }

          throw supportedServerErr;

        case 20:
          if (!options.loadBalanced) {
            _context.next = 23;
            break;
          }

          if (response.serviceId) {
            _context.next = 23;
            break;
          }

          throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.');

        case 23:
          // NOTE: This is metadata attached to the connection while porting away from
          //       handshake being done in the `Server` class. Likely, it should be
          //       relocated, or at very least restructured.
          conn.hello = response;
          conn.lastHelloMS = new Date().getTime() - start;

          if (!(!response.arbiterOnly && credentials)) {
            _context.next = 40;
            break;
          }

          // store the response on auth context
          authContext.response = response;
          resolvedCredentials = credentials.resolveAuthMechanism(response);
          provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);

          if (provider) {
            _context.next = 31;
            break;
          }

          throw new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(resolvedCredentials.mechanism, " defined."));

        case 31:
          _context.prev = 31;
          _context.next = 34;
          return provider.auth(authContext);

        case 34:
          _context.next = 40;
          break;

        case 36:
          _context.prev = 36;
          _context.t0 = _context["catch"](31);

          if (_context.t0 instanceof error_1.MongoError) {
            _context.t0.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);

            if ((0, error_1.needsRetryableWriteLabel)(_context.t0, response.maxWireVersion)) {
              _context.t0.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
            }
          }

          throw _context.t0;

        case 40:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[31, 36]]);
  }));
  return _performInitialHandshake.apply(this, arguments);
}

function prepareHandshakeDocument(_x3) {
  return _prepareHandshakeDocument.apply(this, arguments);
}

function _prepareHandshakeDocument() {
  _prepareHandshakeDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authContext) {
    var _handshakeDoc;

    var options, compressors, serverApi, handshakeDoc, credentials, _provider, provider;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          options = authContext.options;
          compressors = options.compressors ? options.compressors : [];
          serverApi = authContext.connection.serverApi;
          handshakeDoc = (_handshakeDoc = {}, _defineProperty(_handshakeDoc, serverApi !== null && serverApi !== void 0 && serverApi.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, 1), _defineProperty(_handshakeDoc, "helloOk", true), _defineProperty(_handshakeDoc, "client", options.metadata), _defineProperty(_handshakeDoc, "compression", compressors), _handshakeDoc);

          if (options.loadBalanced === true) {
            handshakeDoc.loadBalanced = true;
          }

          credentials = authContext.credentials;

          if (!credentials) {
            _context2.next = 17;
            break;
          }

          if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username)) {
            _context2.next = 13;
            break;
          }

          handshakeDoc.saslSupportedMechs = "".concat(credentials.source, ".").concat(credentials.username);
          _provider = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);

          if (_provider) {
            _context2.next = 12;
            break;
          }

          throw new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, " defined."));

        case 12:
          return _context2.abrupt("return", _provider.prepare(handshakeDoc, authContext));

        case 13:
          provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);

          if (provider) {
            _context2.next = 16;
            break;
          }

          throw new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(credentials.mechanism, " defined."));

        case 16:
          return _context2.abrupt("return", provider.prepare(handshakeDoc, authContext));

        case 17:
          return _context2.abrupt("return", handshakeDoc);

        case 18:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _prepareHandshakeDocument.apply(this, arguments);
}

exports.prepareHandshakeDocument = prepareHandshakeDocument;
/** @public */

exports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];
/** @public */

exports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];

function parseConnectOptions(options) {
  var hostAddress = options.hostAddress;
  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
  var result = {};

  var _iterator = _createForOfIteratorHelper(exports.LEGAL_TCP_SOCKET_OPTIONS),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var name = _step.value;

      if (options[name] != null) {
        result[name] = options[name];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (typeof hostAddress.socketPath === 'string') {
    result.path = hostAddress.socketPath;
    return result;
  } else if (typeof hostAddress.host === 'string') {
    result.host = hostAddress.host;
    result.port = hostAddress.port;
    return result;
  } else {
    // This should never happen since we set up HostAddresses
    // But if we don't throw here the socket could hang until timeout
    // TODO(NODE-3483)
    throw new error_1.MongoRuntimeError("Unexpected HostAddress ".concat(JSON.stringify(hostAddress)));
  }
}

function parseSslOptions(options) {
  var result = parseConnectOptions(options); // Merge in valid SSL options

  var _iterator2 = _createForOfIteratorHelper(exports.LEGAL_TLS_SOCKET_OPTIONS),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var name = _step2.value;

      if (options[name] != null) {
        result[name] = options[name];
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (options.existingSocket) {
    result.socket = options.existingSocket;
  } // Set default sni servername to be the same as host


  if (result.servername == null && result.host && !net.isIP(result.host)) {
    result.servername = result.host;
  }

  return result;
}

var SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];
var SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);

function makeConnection(options, _callback) {
  var _options$tls, _options$keepAlive, _ref, _options$socketTimeou, _options$noDelay, _options$connectTimeo, _options$rejectUnauth, _ref2, _options$keepAliveIni;

  var useTLS = (_options$tls = options.tls) !== null && _options$tls !== void 0 ? _options$tls : false;
  var keepAlive = (_options$keepAlive = options.keepAlive) !== null && _options$keepAlive !== void 0 ? _options$keepAlive : true;
  var socketTimeoutMS = (_ref = (_options$socketTimeou = options.socketTimeoutMS) !== null && _options$socketTimeou !== void 0 ? _options$socketTimeou : Reflect.get(options, 'socketTimeout')) !== null && _ref !== void 0 ? _ref : 0;
  var noDelay = (_options$noDelay = options.noDelay) !== null && _options$noDelay !== void 0 ? _options$noDelay : true;
  var connectTimeoutMS = (_options$connectTimeo = options.connectTimeoutMS) !== null && _options$connectTimeo !== void 0 ? _options$connectTimeo : 30000;
  var rejectUnauthorized = (_options$rejectUnauth = options.rejectUnauthorized) !== null && _options$rejectUnauth !== void 0 ? _options$rejectUnauth : true;
  var keepAliveInitialDelay = (_ref2 = ((_options$keepAliveIni = options.keepAliveInitialDelay) !== null && _options$keepAliveIni !== void 0 ? _options$keepAliveIni : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _ref2 !== void 0 ? _ref2 : 120000;
  var existingSocket = options.existingSocket;
  var socket;

  var callback = function callback(err, ret) {
    if (err && socket) {
      socket.destroy();
    }

    _callback(err, ret);
  };

  if (options.proxyHost != null) {
    // Currently, only Socks5 is supported.
    return makeSocks5Connection(_objectSpread(_objectSpread({}, options), {}, {
      connectTimeoutMS: connectTimeoutMS // Should always be present for Socks5

    }), callback);
  }

  if (useTLS) {
    var tlsSocket = tls.connect(parseSslOptions(options));

    if (typeof tlsSocket.disableRenegotiation === 'function') {
      tlsSocket.disableRenegotiation();
    }

    socket = tlsSocket;
  } else if (existingSocket) {
    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,
    // so we only need to handle the non-TLS case here (where existingSocket
    // gives us all we need out of the box).
    socket = existingSocket;
  } else {
    socket = net.createConnection(parseConnectOptions(options));
  }

  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
  socket.setTimeout(connectTimeoutMS);
  socket.setNoDelay(noDelay);
  var connectEvent = useTLS ? 'secureConnect' : 'connect';
  var cancellationHandler;

  function errorHandler(eventName) {
    return function (err) {
      SOCKET_ERROR_EVENTS.forEach(function (event) {
        return socket.removeAllListeners(event);
      });

      if (cancellationHandler && options.cancellationToken) {
        options.cancellationToken.removeListener('cancel', cancellationHandler);
      }

      socket.removeListener(connectEvent, connectHandler);
      callback(connectionFailureError(eventName, err));
    };
  }

  function connectHandler() {
    SOCKET_ERROR_EVENTS.forEach(function (event) {
      return socket.removeAllListeners(event);
    });

    if (cancellationHandler && options.cancellationToken) {
      options.cancellationToken.removeListener('cancel', cancellationHandler);
    }

    if ('authorizationError' in socket) {
      if (socket.authorizationError && rejectUnauthorized) {
        // TODO(NODE-5192): wrap this with a MongoError subclass
        return callback(socket.authorizationError);
      }
    }

    socket.setTimeout(0);
    callback(undefined, socket);
  }

  SOCKET_ERROR_EVENTS.forEach(function (event) {
    return socket.once(event, errorHandler(event));
  });

  if (options.cancellationToken) {
    cancellationHandler = errorHandler('cancel');
    options.cancellationToken.once('cancel', cancellationHandler);
  }

  if (existingSocket) {
    process.nextTick(connectHandler);
  } else {
    socket.once(connectEvent, connectHandler);
  }
}

function makeSocks5Connection(options, callback) {
  var _options$proxyHost, _options$proxyPort;

  var hostAddress = utils_1.HostAddress.fromHostPort((_options$proxyHost = options.proxyHost) !== null && _options$proxyHost !== void 0 ? _options$proxyHost : '', // proxyHost is guaranteed to set here
  (_options$proxyPort = options.proxyPort) !== null && _options$proxyPort !== void 0 ? _options$proxyPort : 1080); // First, connect to the proxy server itself:

  makeConnection(_objectSpread(_objectSpread({}, options), {}, {
    hostAddress: hostAddress,
    tls: false,
    proxyHost: undefined
  }), function (err, rawSocket) {
    if (err) {
      return callback(err);
    }

    var destination = parseConnectOptions(options);

    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {
      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));
    } // Then, establish the Socks5 proxy connection:


    socks_1.SocksClient.createConnection({
      existing_socket: rawSocket,
      timeout: options.connectTimeoutMS,
      command: 'connect',
      destination: {
        host: destination.host,
        port: destination.port
      },
      proxy: {
        // host and port are ignored because we pass existing_socket
        host: 'iLoveJavaScript',
        port: 0,
        type: 5,
        userId: options.proxyUsername || undefined,
        password: options.proxyPassword || undefined
      }
    }).then(function (_ref3) {
      var socket = _ref3.socket;
      // Finally, now treat the resulting duplex stream as the
      // socket over which we send and receive wire protocol messages:
      makeConnection(_objectSpread(_objectSpread({}, options), {}, {
        existingSocket: socket,
        proxyHost: undefined
      }), callback);
    }, function (error) {
      return callback(connectionFailureError('error', error));
    });
  });
}

function connectionFailureError(type, err) {
  switch (type) {
    case 'error':
      return new error_1.MongoNetworkError(err);

    case 'timeout':
      return new error_1.MongoNetworkTimeoutError('connection timed out');

    case 'close':
      return new error_1.MongoNetworkError('connection closed');

    case 'cancel':
      return new error_1.MongoNetworkError('connection establishment was cancelled');

    default:
      return new error_1.MongoNetworkError('unknown network error');
  }
}

/***/ }),

/***/ 9532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;

var timers_1 = __webpack_require__(9512);

var util_1 = __webpack_require__(3837);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var sessions_1 = __webpack_require__(2516);

var utils_1 = __webpack_require__(672);

var command_monitoring_events_1 = __webpack_require__(4482);

var commands_1 = __webpack_require__(7136);

var message_stream_1 = __webpack_require__(4980);

var stream_description_1 = __webpack_require__(399);

var shared_1 = __webpack_require__(8118);
/** @internal */


var kStream = Symbol('stream');
/** @internal */

var kQueue = Symbol('queue');
/** @internal */

var kMessageStream = Symbol('messageStream');
/** @internal */

var kGeneration = Symbol('generation');
/** @internal */

var kLastUseTime = Symbol('lastUseTime');
/** @internal */

var kClusterTime = Symbol('clusterTime');
/** @internal */

var kDescription = Symbol('description');
/** @internal */

var kHello = Symbol('hello');
/** @internal */

var kAutoEncrypter = Symbol('autoEncrypter');
/** @internal */

var kDelayedTimeoutId = Symbol('delayedTimeoutId');
var INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';
/** @internal */

var Connection = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Connection, _mongo_types_1$TypedE);

  var _super = _createSuper(Connection);

  function Connection(stream, options) {
    var _options$socketTimeou, _this$hello;

    var _this;

    _classCallCheck(this, Connection);

    _this = _super.call(this);
    _this.commandAsync = (0, util_1.promisify)(function (ns, cmd, options, callback) {
      return _this.command(ns, cmd, options, callback);
    });
    _this.id = options.id;
    _this.address = streamIdentifier(stream, options);
    _this.socketTimeoutMS = (_options$socketTimeou = options.socketTimeoutMS) !== null && _options$socketTimeou !== void 0 ? _options$socketTimeou : 0;
    _this.monitorCommands = options.monitorCommands;
    _this.serverApi = options.serverApi;
    _this.closed = false;
    _this[kHello] = null;
    _this[kClusterTime] = null;
    _this[kDescription] = new stream_description_1.StreamDescription(_this.address, options);
    _this[kGeneration] = options.generation;
    _this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling

    _this[kQueue] = new Map();
    _this[kMessageStream] = new message_stream_1.MessageStream(_objectSpread(_objectSpread({}, options), {}, {
      maxBsonMessageSize: (_this$hello = _this.hello) === null || _this$hello === void 0 ? void 0 : _this$hello.maxBsonMessageSize
    }));
    _this[kStream] = stream;
    _this[kDelayedTimeoutId] = null;

    _this[kMessageStream].on('message', function (message) {
      return _this.onMessage(message);
    });

    _this[kMessageStream].on('error', function (error) {
      return _this.onError(error);
    });

    _this[kStream].on('close', function () {
      return _this.onClose();
    });

    _this[kStream].on('timeout', function () {
      return _this.onTimeout();
    });

    _this[kStream].on('error', function () {
      /* ignore errors, listen to `close` instead */
    }); // hook the message stream up to the passed in stream


    _this[kStream].pipe(_this[kMessageStream]);

    _this[kMessageStream].pipe(_this[kStream]);

    return _this;
  }

  _createClass(Connection, [{
    key: "description",
    get: function get() {
      return this[kDescription];
    }
  }, {
    key: "hello",
    get: function get() {
      return this[kHello];
    } // the `connect` method stores the result of the handshake hello on the connection
    ,
    set: function set(response) {
      this[kDescription].receiveResponse(response);
      this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future

      this[kHello] = response;
    } // Set the whether the message stream is for a monitoring connection.

  }, {
    key: "isMonitoringConnection",
    get: function get() {
      return this[kMessageStream].isMonitoringConnection;
    },
    set: function set(value) {
      this[kMessageStream].isMonitoringConnection = value;
    }
  }, {
    key: "serviceId",
    get: function get() {
      var _this$hello2;

      return (_this$hello2 = this.hello) === null || _this$hello2 === void 0 ? void 0 : _this$hello2.serviceId;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.description.loadBalanced;
    }
  }, {
    key: "generation",
    get: function get() {
      return this[kGeneration] || 0;
    },
    set: function set(generation) {
      this[kGeneration] = generation;
    }
  }, {
    key: "idleTime",
    get: function get() {
      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
    }
  }, {
    key: "clusterTime",
    get: function get() {
      return this[kClusterTime];
    }
  }, {
    key: "stream",
    get: function get() {
      return this[kStream];
    }
  }, {
    key: "markAvailable",
    value: function markAvailable() {
      this[kLastUseTime] = (0, utils_1.now)();
    }
  }, {
    key: "onError",
    value: function onError(error) {
      this.cleanup(true, error);
    }
  }, {
    key: "onClose",
    value: function onClose() {
      var message = "connection ".concat(this.id, " to ").concat(this.address, " closed");
      this.cleanup(true, new error_1.MongoNetworkError(message));
    }
  }, {
    key: "onTimeout",
    value: function onTimeout() {
      var _this2 = this;

      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(function () {
        var message = "connection ".concat(_this2.id, " to ").concat(_this2.address, " timed out");
        var beforeHandshake = _this2.hello == null;

        _this2.cleanup(true, new error_1.MongoNetworkTimeoutError(message, {
          beforeHandshake: beforeHandshake
        }));
      }, 1).unref(); // No need for this timer to hold the event loop open
    }
  }, {
    key: "onMessage",
    value: function onMessage(message) {
      var _this$kStream$timeout;

      var delayedTimeoutId = this[kDelayedTimeoutId];

      if (delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(delayedTimeoutId);
        this[kDelayedTimeoutId] = null;
      }

      var socketTimeoutMS = (_this$kStream$timeout = this[kStream].timeout) !== null && _this$kStream$timeout !== void 0 ? _this$kStream$timeout : 0;
      this[kStream].setTimeout(0); // always emit the message, in case we are streaming

      this.emit('message', message);
      var operationDescription = this[kQueue].get(message.responseTo);

      if (!operationDescription && this.isMonitoringConnection) {
        // This is how we recover when the initial hello's requestId is not
        // the responseTo when hello responses have been skipped:
        // First check if the map is of invalid size
        if (this[kQueue].size > 1) {
          this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));
        } else {
          // Get the first orphaned operation description.
          var entry = this[kQueue].entries().next();

          if (entry.value != null) {
            var _entry$value2 = _slicedToArray(entry.value, 2),
                requestId = _entry$value2[0],
                orphaned = _entry$value2[1]; // If the orphaned operation description exists then set it.


            operationDescription = orphaned; // Remove the entry with the bad request id from the queue.

            this[kQueue]["delete"](requestId);
          }
        }
      }

      if (!operationDescription) {
        return;
      }

      var callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to
      // track response, however the server currently synthetically produces remote requests
      // making the `responseTo` change on each response

      this[kQueue]["delete"](message.responseTo);

      if ('moreToCome' in message && message.moreToCome) {
        // If the operation description check above does find an orphaned
        // description and sets the operationDescription then this line will put one
        // back in the queue with the correct requestId and will resolve not being able
        // to find the next one via the responseTo of the next streaming hello.
        this[kQueue].set(message.requestId, operationDescription);
        this[kStream].setTimeout(socketTimeoutMS);
      }

      try {
        // Pass in the entire description because it has BSON parsing options
        message.parse(operationDescription);
      } catch (err) {
        // If this error is generated by our own code, it will already have the correct class applied
        // if it is not, then it is coming from a catastrophic data parse failure or the BSON library
        // in either case, it should not be wrapped
        callback(err);
        return;
      }

      if (message.documents[0]) {
        var document = message.documents[0];
        var session = operationDescription.session;

        if (session) {
          (0, sessions_1.updateSessionFromResponse)(session, document);
        }

        if (document.$clusterTime) {
          this[kClusterTime] = document.$clusterTime;
          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);
        }

        if (document.writeConcernError) {
          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);
          return;
        }

        if (document.ok === 0 || document.$err || document.errmsg || document.code) {
          callback(new error_1.MongoServerError(document));
          return;
        }
      }

      callback(undefined, message.documents[0]);
    }
  }, {
    key: "destroy",
    value: function destroy(options, callback) {
      if (this.closed) {
        process.nextTick(function () {
          return callback === null || callback === void 0 ? void 0 : callback();
        });
        return;
      }

      if (typeof callback === 'function') {
        this.once('close', function () {
          return process.nextTick(function () {
            return callback();
          });
        });
      } // load balanced mode requires that these listeners remain on the connection
      // after cleanup on timeouts, errors or close so we remove them before calling
      // cleanup.


      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      var message = "connection ".concat(this.id, " to ").concat(this.address, " closed");
      this.cleanup(options.force, new error_1.MongoNetworkError(message));
    }
    /**
     * A method that cleans up the connection.  When `force` is true, this method
     * forcibly destroys the socket.
     *
     * If an error is provided, any in-flight operations will be closed with the error.
     *
     * This method does nothing if the connection is already closed.
     */

  }, {
    key: "cleanup",
    value: function cleanup(force, error) {
      var _this3 = this;

      if (this.closed) {
        return;
      }

      this.closed = true;

      var completeCleanup = function completeCleanup() {
        var _iterator = _createForOfIteratorHelper(_this3[kQueue].values()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var op = _step.value;
            op.cb(error);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        _this3[kQueue].clear();

        _this3.emit(Connection.CLOSE);
      };

      this[kStream].removeAllListeners();
      this[kMessageStream].removeAllListeners();
      this[kMessageStream].destroy();

      if (force) {
        this[kStream].destroy();
        completeCleanup();
        return;
      }

      if (!this[kStream].writableEnded) {
        this[kStream].end(function () {
          _this3[kStream].destroy();

          completeCleanup();
        });
      } else {
        completeCleanup();
      }
    }
  }, {
    key: "command",
    value: function command(ns, _command, options, callback) {
      var cmd = _objectSpread({}, _command);

      var readPreference = (0, shared_1.getReadPreference)(options);
      var shouldUseOpMsg = supportsOpMsg(this);
      var session = options === null || options === void 0 ? void 0 : options.session;
      var clusterTime = this.clusterTime;

      if (this.serverApi) {
        var _this$serverApi2 = this.serverApi,
            version = _this$serverApi2.version,
            strict = _this$serverApi2.strict,
            deprecationErrors = _this$serverApi2.deprecationErrors;
        cmd.apiVersion = version;
        if (strict != null) cmd.apiStrict = strict;
        if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;
      }

      if (hasSessionSupport(this) && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }

        var err = (0, sessions_1.applySession)(session, cmd, options);

        if (err) {
          return callback(err);
        }
      } else if (session !== null && session !== void 0 && session.explicit) {
        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));
      } // if we have a known cluster time, gossip it


      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }

      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {
        cmd = {
          $query: cmd,
          $readPreference: readPreference.toJSON()
        };
      }

      var commandOptions = Object.assign({
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        // This value is not overridable
        secondaryOk: readPreference.secondaryOk()
      }, options);
      var cmdNs = "".concat(ns.db, ".$cmd");
      var message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, cmd, commandOptions) : new commands_1.Query(cmdNs, cmd, commandOptions);

      try {
        write(this, message, commandOptions, callback);
      } catch (err) {
        callback(err);
      }
    }
  }]);

  return Connection;
}(mongo_types_1.TypedEventEmitter);
/** @event */


Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
/** @event */

Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
/** @event */

Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
/** @event */

Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
/** @event */

Connection.CLOSE = constants_1.CLOSE;
/** @event */

Connection.MESSAGE = constants_1.MESSAGE;
/** @event */

Connection.PINNED = constants_1.PINNED;
/** @event */

Connection.UNPINNED = constants_1.UNPINNED;
exports.Connection = Connection;
/** @internal */

var CryptoConnection = /*#__PURE__*/function (_Connection) {
  _inherits(CryptoConnection, _Connection);

  var _super2 = _createSuper(CryptoConnection);

  function CryptoConnection(stream, options) {
    var _this4;

    _classCallCheck(this, CryptoConnection);

    _this4 = _super2.call(this, stream, options);
    _this4[kAutoEncrypter] = options.autoEncrypter;
    return _this4;
  }
  /** @internal @override */


  _createClass(CryptoConnection, [{
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var _this5 = this;

      var autoEncrypter = this[kAutoEncrypter];

      if (!autoEncrypter) {
        return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));
      }

      var serverWireVersion = (0, utils_1.maxWireVersion)(this);

      if (serverWireVersion === 0) {
        // This means the initial handshake hasn't happened yet
        return _get(_getPrototypeOf(CryptoConnection.prototype), "command", this).call(this, ns, cmd, options, callback);
      }

      if (serverWireVersion < 8) {
        callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));
        return;
      } // Save sort or indexKeys based on the command being run
      // the encrypt API serializes our JS objects to BSON to pass to the native code layer
      // and then deserializes the encrypted result, the protocol level components
      // of the command (ex. sort) are then converted to JS objects potentially losing
      // import key order information. These fields are never encrypted so we can save the values
      // from before the encryption and replace them after encryption has been performed


      var sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      var indexKeys = cmd.createIndexes ? cmd.indexes.map(function (index) {
        return index.key;
      }) : null;
      autoEncrypter.encrypt(ns.toString(), cmd, options, function (err, encrypted) {
        if (err || encrypted == null) {
          callback(err, null);
          return;
        } // Replace the saved values


        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }

        if (indexKeys != null && cmd.createIndexes) {
          var _iterator2 = _createForOfIteratorHelper(indexKeys.entries()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value2 = _slicedToArray(_step2.value, 2),
                  offset = _step2$value2[0],
                  index = _step2$value2[1];

              encrypted.indexes[offset].key = index;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }

        _get(_getPrototypeOf(CryptoConnection.prototype), "command", _this5).call(_this5, ns, encrypted, options, function (err, response) {
          if (err || response == null) {
            callback(err, response);
            return;
          }

          autoEncrypter.decrypt(response, options, callback);
        });
      });
    }
  }]);

  return CryptoConnection;
}(Connection);

exports.CryptoConnection = CryptoConnection;
/** @internal */

function hasSessionSupport(conn) {
  var description = conn.description;
  return description.logicalSessionTimeoutMinutes != null;
}

exports.hasSessionSupport = hasSessionSupport;

function supportsOpMsg(conn) {
  var description = conn.description;

  if (description == null) {
    return false;
  }

  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;
}

function streamIdentifier(stream, options) {
  if (options.proxyHost) {
    // If proxy options are specified, the properties of `stream` itself
    // will not accurately reflect what endpoint this is connected to.
    return options.hostAddress.toString();
  }

  var remoteAddress = stream.remoteAddress,
      remotePort = stream.remotePort;

  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {
    return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
  }

  return (0, utils_1.uuidV4)().toString('hex');
}

function write(conn, command, options, callback) {
  var _options;

  options = (_options = options) !== null && _options !== void 0 ? _options : {};
  var operationDescription = {
    requestId: command.requestId,
    cb: callback,
    session: options.session,
    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,
    documentsReturnedIn: options.documentsReturnedIn,
    // for BSON parsing
    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,
    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,
    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,
    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,
    raw: typeof options.raw === 'boolean' ? options.raw : false,
    started: 0
  };

  if (conn[kDescription] && conn[kDescription].compressor) {
    operationDescription.agreedCompressor = conn[kDescription].compressor;

    if (conn[kDescription].zlibCompressionLevel) {
      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;
    }
  }

  if (typeof options.socketTimeoutMS === 'number') {
    conn[kStream].setTimeout(options.socketTimeoutMS);
  } else if (conn.socketTimeoutMS !== 0) {
    conn[kStream].setTimeout(conn.socketTimeoutMS);
  } // if command monitoring is enabled we need to modify the callback here


  if (conn.monitorCommands) {
    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));
    operationDescription.started = (0, utils_1.now)();

    operationDescription.cb = function (err, reply) {
      // Command monitoring spec states that if ok is 1, then we must always emit
      // a command succeeded event, even if there's an error. Write concern errors
      // will have an ok: 1 in their reply.
      if (err && (reply === null || reply === void 0 ? void 0 : reply.ok) !== 1) {
        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));
      } else {
        if (reply && (reply.ok === 0 || reply.$err)) {
          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));
        } else {
          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));
        }
      }

      if (typeof callback === 'function') {
        // Since we're passing through the reply with the write concern error now, we
        // need it not to be provided to the original callback in this case so
        // retryability does not get tricked into thinking the command actually
        // succeeded.
        callback(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);
      }
    };
  }

  if (!operationDescription.noResponse) {
    conn[kQueue].set(operationDescription.requestId, operationDescription);
  }

  try {
    conn[kMessageStream].writeCommand(command, operationDescription);
  } catch (e) {
    if (!operationDescription.noResponse) {
      conn[kQueue]["delete"](operationDescription.requestId);
      operationDescription.cb(e);
      return;
    }
  }

  if (operationDescription.noResponse) {
    operationDescription.cb();
  }
}

/***/ }),

/***/ 2809:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPool = exports.PoolState = void 0;

var timers_1 = __webpack_require__(9512);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var utils_1 = __webpack_require__(672);

var connect_1 = __webpack_require__(8338);

var connection_1 = __webpack_require__(9532);

var connection_pool_events_1 = __webpack_require__(1027);

var errors_1 = __webpack_require__(2676);

var metrics_1 = __webpack_require__(1186);
/** @internal */


var kServer = Symbol('server');
/** @internal */

var kConnections = Symbol('connections');
/** @internal */

var kPending = Symbol('pending');
/** @internal */

var kCheckedOut = Symbol('checkedOut');
/** @internal */

var kMinPoolSizeTimer = Symbol('minPoolSizeTimer');
/** @internal */

var kGeneration = Symbol('generation');
/** @internal */

var kServiceGenerations = Symbol('serviceGenerations');
/** @internal */

var kConnectionCounter = Symbol('connectionCounter');
/** @internal */

var kCancellationToken = Symbol('cancellationToken');
/** @internal */

var kWaitQueue = Symbol('waitQueue');
/** @internal */

var kCancelled = Symbol('cancelled');
/** @internal */

var kMetrics = Symbol('metrics');
/** @internal */

var kProcessingWaitQueue = Symbol('processingWaitQueue');
/** @internal */

var kPoolState = Symbol('poolState');
/** @internal */

exports.PoolState = Object.freeze({
  paused: 'paused',
  ready: 'ready',
  closed: 'closed'
});
/**
 * A pool of connections which dynamically resizes, and emit events related to pool activity
 * @internal
 */

var ConnectionPool = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(ConnectionPool, _mongo_types_1$TypedE);

  var _super = _createSuper(ConnectionPool);

  function ConnectionPool(server, options) {
    var _options$maxPoolSize, _options$minPoolSize, _options$maxConnectin, _options$maxIdleTimeM, _options$waitQueueTim, _options$minPoolSizeC;

    var _this;

    _classCallCheck(this, ConnectionPool);

    _this = _super.call(this);
    _this.options = Object.freeze(_objectSpread(_objectSpread({}, options), {}, {
      connectionType: connection_1.Connection,
      maxPoolSize: (_options$maxPoolSize = options.maxPoolSize) !== null && _options$maxPoolSize !== void 0 ? _options$maxPoolSize : 100,
      minPoolSize: (_options$minPoolSize = options.minPoolSize) !== null && _options$minPoolSize !== void 0 ? _options$minPoolSize : 0,
      maxConnecting: (_options$maxConnectin = options.maxConnecting) !== null && _options$maxConnectin !== void 0 ? _options$maxConnectin : 2,
      maxIdleTimeMS: (_options$maxIdleTimeM = options.maxIdleTimeMS) !== null && _options$maxIdleTimeM !== void 0 ? _options$maxIdleTimeM : 0,
      waitQueueTimeoutMS: (_options$waitQueueTim = options.waitQueueTimeoutMS) !== null && _options$waitQueueTim !== void 0 ? _options$waitQueueTim : 0,
      minPoolSizeCheckFrequencyMS: (_options$minPoolSizeC = options.minPoolSizeCheckFrequencyMS) !== null && _options$minPoolSizeC !== void 0 ? _options$minPoolSizeC : 100,
      autoEncrypter: options.autoEncrypter,
      metadata: options.metadata
    }));

    if (_this.options.minPoolSize > _this.options.maxPoolSize) {
      throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');
    }

    _this[kPoolState] = exports.PoolState.paused;
    _this[kServer] = server;
    _this[kConnections] = new utils_1.List();
    _this[kPending] = 0;
    _this[kCheckedOut] = new Set();
    _this[kMinPoolSizeTimer] = undefined;
    _this[kGeneration] = 0;
    _this[kServiceGenerations] = new Map();
    _this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
    _this[kCancellationToken] = new mongo_types_1.CancellationToken();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kWaitQueue] = new utils_1.List();
    _this[kMetrics] = new metrics_1.ConnectionPoolMetrics();
    _this[kProcessingWaitQueue] = false;
    _this.mongoLogger = _this[kServer].topology.client.mongoLogger;
    _this.component = 'connection';
    process.nextTick(function () {
      _this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(_assertThisInitialized(_this)));
    });
    return _this;
  }
  /** The address of the endpoint the pool is connected to */


  _createClass(ConnectionPool, [{
    key: "address",
    get: function get() {
      return this.options.hostAddress.toString();
    }
    /**
     * Check if the pool has been closed
     *
     * TODO(NODE-3263): We can remove this property once shell no longer needs it
     */

  }, {
    key: "closed",
    get: function get() {
      return this[kPoolState] === exports.PoolState.closed;
    }
    /** An integer representing the SDAM generation of the pool */

  }, {
    key: "generation",
    get: function get() {
      return this[kGeneration];
    }
    /** An integer expressing how many total connections (available + pending + in use) the pool currently has */

  }, {
    key: "totalConnectionCount",
    get: function get() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    /** An integer expressing how many connections are currently available in the pool. */

  }, {
    key: "availableConnectionCount",
    get: function get() {
      return this[kConnections].length;
    }
  }, {
    key: "pendingConnectionCount",
    get: function get() {
      return this[kPending];
    }
  }, {
    key: "currentCheckedOutCount",
    get: function get() {
      return this[kCheckedOut].size;
    }
  }, {
    key: "waitQueueSize",
    get: function get() {
      return this[kWaitQueue].length;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.options.loadBalanced;
    }
  }, {
    key: "serviceGenerations",
    get: function get() {
      return this[kServiceGenerations];
    }
  }, {
    key: "serverError",
    get: function get() {
      return this[kServer].description.error;
    }
    /**
     * This is exposed ONLY for use in mongosh, to enable
     * killing all connections if a user quits the shell with
     * operations in progress.
     *
     * This property may be removed as a part of NODE-3263.
     */

  }, {
    key: "checkedOutConnections",
    get: function get() {
      return this[kCheckedOut];
    }
    /**
     * Get the metrics information for the pool when a wait queue timeout occurs.
     */

  }, {
    key: "waitQueueErrorMetrics",
    value: function waitQueueErrorMetrics() {
      return this[kMetrics].info(this.options.maxPoolSize);
    }
    /**
     * Set the pool state to "ready"
     */

  }, {
    key: "ready",
    value: function ready() {
      if (this[kPoolState] !== exports.PoolState.paused) {
        return;
      }

      this[kPoolState] = exports.PoolState.ready;
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
      (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
      this.ensureMinPoolSize();
    }
    /**
     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
     * explicitly destroyed by the new owner.
     */

  }, {
    key: "checkOut",
    value: function checkOut(callback) {
      var _this2 = this;

      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
      var waitQueueMember = {
        callback: callback
      };
      var waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;

      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;

          _this2.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this2, 'timeout'));

          waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(_this2.loadBalanced ? _this2.waitQueueErrorMetrics() : 'Timed out while checking out a connection from connection pool', _this2.address));
        }, waitQueueTimeoutMS);
      }

      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(function () {
        return _this2.processWaitQueue();
      });
    }
    /**
     * Check a connection into the pool.
     *
     * @param connection - The connection to check in
     */

  }, {
    key: "checkIn",
    value: function checkIn(connection) {
      var _this3 = this;

      if (!this[kCheckedOut].has(connection)) {
        return;
      }

      var poolClosed = this.closed;
      var stale = this.connectionIsStale(connection);
      var willDestroy = !!(poolClosed || stale || connection.closed);

      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].unshift(connection);
      }

      this[kCheckedOut]["delete"](connection);
      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));

      if (willDestroy) {
        var reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';
        this.destroyConnection(connection, reason);
      }

      process.nextTick(function () {
        return _this3.processWaitQueue();
      });
    }
    /**
     * Clear the pool
     *
     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
     * previous generation will eventually be pruned during subsequent checkouts.
     */

  }, {
    key: "clear",
    value: function clear() {
      var _options$interruptInU,
          _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.closed) {
        return;
      } // handle load balanced case


      if (this.loadBalanced) {
        var serviceId = options.serviceId;

        if (!serviceId) {
          throw new error_1.MongoRuntimeError('ConnectionPool.clear() called in load balanced mode with no serviceId.');
        }

        var sid = serviceId.toHexString();
        var generation = this.serviceGenerations.get(sid); // Only need to worry if the generation exists, since it should
        // always be there but typescript needs the check.

        if (generation == null) {
          throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');
        } else {
          // Increment the generation for the service id.
          this.serviceGenerations.set(sid, generation + 1);
        }

        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          serviceId: serviceId
        }));
        return;
      } // handle non load-balanced case


      var interruptInUseConnections = (_options$interruptInU = options.interruptInUseConnections) !== null && _options$interruptInU !== void 0 ? _options$interruptInU : false;
      var oldGeneration = this[kGeneration];
      this[kGeneration] += 1;
      var alreadyPaused = this[kPoolState] === exports.PoolState.paused;
      this[kPoolState] = exports.PoolState.paused;
      this.clearMinPoolSizeTimer();

      if (!alreadyPaused) {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          interruptInUseConnections: interruptInUseConnections
        }));
      }

      if (interruptInUseConnections) {
        process.nextTick(function () {
          return _this4.interruptInUseConnections(oldGeneration);
        });
      }

      this.processWaitQueue();
    }
    /**
     * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.
     *
     * Only connections where `connection.generation <= minGeneration` are killed.
     */

  }, {
    key: "interruptInUseConnections",
    value: function interruptInUseConnections(minGeneration) {
      var _iterator = _createForOfIteratorHelper(this[kCheckedOut]),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var connection = _step.value;

          if (connection.generation <= minGeneration) {
            this.checkIn(connection);
            connection.onError(new errors_1.PoolClearedOnNetworkError(this));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "close",
    value: function close(_options, _cb) {
      var _this5 = this;

      var options = _options;
      var callback = _cb !== null && _cb !== void 0 ? _cb : _options;

      if (typeof options === 'function') {
        options = {};
      }

      options = Object.assign({
        force: false
      }, options);

      if (this.closed) {
        return callback();
      } // immediately cancel any in-flight connections


      this[kCancellationToken].emit('cancel'); // end the connection counter

      if (typeof this[kConnectionCounter]["return"] === 'function') {
        this[kConnectionCounter]["return"](undefined);
      }

      this[kPoolState] = exports.PoolState.closed;
      this.clearMinPoolSizeTimer();
      this.processWaitQueue();
      (0, utils_1.eachAsync)(this[kConnections].toArray(), function (conn, cb) {
        _this5.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(_this5, conn, 'poolClosed'));

        conn.destroy({
          force: !!options.force
        }, cb);
      }, function (err) {
        _this5[kConnections].clear();

        _this5.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(_this5));

        callback(err);
      });
    }
    /**
     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
     * has completed by calling back.
     *
     * NOTE: please note the required signature of `fn`
     *
     * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.
     *   In these cases we pass the connection in to this method to ensure it is used and a new
     *   connection is not checked out.
     *
     * @param conn - A pinned connection for use in load balancing mode.
     * @param fn - A function which operates on a managed connection
     * @param callback - The original callback
     */

  }, {
    key: "withConnection",
    value: function withConnection(conn, fn, callback) {
      var _this6 = this;

      if (conn) {
        // use the provided connection, and do _not_ check it in after execution
        fn(undefined, conn, function (fnErr, result) {
          if (fnErr) {
            return _this6.withReauthentication(fnErr, conn, fn, callback);
          }

          callback(undefined, result);
        });
        return;
      }

      this.checkOut(function (err, conn) {
        // don't callback with `err` here, we might want to act upon it inside `fn`
        fn(err, conn, function (fnErr, result) {
          if (fnErr) {
            if (conn) {
              _this6.withReauthentication(fnErr, conn, fn, callback);
            } else {
              callback(fnErr);
            }
          } else {
            callback(undefined, result);
          }

          if (conn) {
            _this6.checkIn(conn);
          }
        });
      });
    }
  }, {
    key: "withReauthentication",
    value: function withReauthentication(fnErr, conn, fn, callback) {
      if (fnErr instanceof error_1.MongoError && fnErr.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
        this.reauthenticate(conn, fn, function (error, res) {
          if (error) {
            return callback(error);
          }

          callback(undefined, res);
        });
      } else {
        callback(fnErr);
      }
    }
    /**
     * Reauthenticate on the same connection and then retry the operation.
     */

  }, {
    key: "reauthenticate",
    value: function reauthenticate(connection, fn, callback) {
      var authContext = connection.authContext;

      if (!authContext) {
        return callback(new error_1.MongoRuntimeError('No auth context found on connection.'));
      }

      var credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('Connection is missing credentials when asked to reauthenticate'));
      }

      var resolvedCredentials = credentials.resolveAuthMechanism(connection.hello || undefined);
      var provider = connect_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);

      if (!provider) {
        return callback(new error_1.MongoMissingCredentialsError("Reauthenticate failed due to no auth provider for ".concat(credentials.mechanism)));
      }

      provider.reauth(authContext).then(function () {
        fn(undefined, connection, function (fnErr, fnResult) {
          if (fnErr) {
            return callback(fnErr);
          }

          callback(undefined, fnResult);
        });
      }, function (error) {
        return callback(error);
      });
    }
    /** Clear the min pool size timer */

  }, {
    key: "clearMinPoolSizeTimer",
    value: function clearMinPoolSizeTimer() {
      var minPoolSizeTimer = this[kMinPoolSizeTimer];

      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      }
    }
  }, {
    key: "destroyConnection",
    value: function destroyConnection(connection, reason) {
      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason)); // destroy the connection

      process.nextTick(function () {
        return connection.destroy({
          force: false
        });
      });
    }
  }, {
    key: "connectionIsStale",
    value: function connectionIsStale(connection) {
      var serviceId = connection.serviceId;

      if (this.loadBalanced && serviceId) {
        var sid = serviceId.toHexString();
        var generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }

      return connection.generation !== this[kGeneration];
    }
  }, {
    key: "connectionIsIdle",
    value: function connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
    /**
     * Destroys a connection if the connection is perished.
     *
     * @returns `true` if the connection was destroyed, `false` otherwise.
     */

  }, {
    key: "destroyConnectionIfPerished",
    value: function destroyConnectionIfPerished(connection) {
      var isStale = this.connectionIsStale(connection);
      var isIdle = this.connectionIsIdle(connection);

      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }

      var reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';
      this.destroyConnection(connection, reason);
      return true;
    }
  }, {
    key: "createConnection",
    value: function createConnection(callback) {
      var _this7 = this;

      var connectOptions = _objectSpread(_objectSpread({}, this.options), {}, {
        id: this[kConnectionCounter].next().value,
        generation: this[kGeneration],
        cancellationToken: this[kCancellationToken]
      });

      this[kPending]++; // This is our version of a "virtual" no-I/O connection as the spec requires

      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, {
        id: connectOptions.id
      }));
      (0, connect_1.connect)(connectOptions, function (err, connection) {
        if (err || !connection) {
          _this7[kPending]--;

          _this7.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(_this7, {
            id: connectOptions.id,
            serviceId: undefined
          }, 'error', // TODO(NODE-5192): Remove this cast
          err));

          if (err instanceof error_1.MongoNetworkError || err instanceof error_1.MongoServerError) {
            err.connectionGeneration = connectOptions.generation;
          }

          callback(err !== null && err !== void 0 ? err : new error_1.MongoRuntimeError('Connection creation failed without error'));
          return;
        } // The pool might have closed since we started trying to create a connection


        if (_this7[kPoolState] !== exports.PoolState.ready) {
          _this7[kPending]--;
          connection.destroy({
            force: true
          });
          callback(_this7.closed ? new errors_1.PoolClosedError(_this7) : new errors_1.PoolClearedError(_this7));
          return;
        } // forward all events from the connection to the pool


        var _loop = function _loop() {
          var event = _arr[_i];
          connection.on(event, function (e) {
            return _this7.emit(event, e);
          });
        };

        for (var _i = 0, _arr = [].concat(_toConsumableArray(constants_1.APM_EVENTS), [connection_1.Connection.CLUSTER_TIME_RECEIVED]); _i < _arr.length; _i++) {
          _loop();
        }

        if (_this7.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, function (pinType) {
            return _this7[kMetrics].markPinned(pinType);
          });
          connection.on(connection_1.Connection.UNPINNED, function (pinType) {
            return _this7[kMetrics].markUnpinned(pinType);
          });
          var serviceId = connection.serviceId;

          if (serviceId) {
            var generation;
            var sid = serviceId.toHexString();

            if (generation = _this7.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              _this7.serviceGenerations.set(sid, 0);

              connection.generation = 0;
            }
          }
        }

        connection.markAvailable();

        _this7.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(_this7, connection));

        _this7[kPending]--;
        callback(undefined, connection);
        return;
      });
    }
  }, {
    key: "ensureMinPoolSize",
    value: function ensureMinPoolSize() {
      var _this8 = this;

      var minPoolSize = this.options.minPoolSize;

      if (this[kPoolState] !== exports.PoolState.ready || minPoolSize === 0) {
        return;
      }

      this[kConnections].prune(function (connection) {
        return _this8.destroyConnectionIfPerished(connection);
      });

      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        // NOTE: ensureMinPoolSize should not try to get all the pending
        // connection permits because that potentially delays the availability of
        // the connection to a checkout request
        this.createConnection(function (err, connection) {
          if (err) {
            _this8[kServer].handleError(err);
          }

          if (!err && connection) {
            _this8[kConnections].push(connection);

            process.nextTick(function () {
              return _this8.processWaitQueue();
            });
          }

          if (_this8[kPoolState] === exports.PoolState.ready) {
            (0, timers_1.clearTimeout)(_this8[kMinPoolSizeTimer]);
            _this8[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {
              return _this8.ensureMinPoolSize();
            }, _this8.options.minPoolSizeCheckFrequencyMS);
          }
        });
      } else {
        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
        this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {
          return _this8.ensureMinPoolSize();
        }, this.options.minPoolSizeCheckFrequencyMS);
      }
    }
  }, {
    key: "processWaitQueue",
    value: function processWaitQueue() {
      var _this9 = this;

      if (this[kProcessingWaitQueue]) {
        return;
      }

      this[kProcessingWaitQueue] = true;

      while (this.waitQueueSize) {
        var waitQueueMember = this[kWaitQueue].first();

        if (!waitQueueMember) {
          this[kWaitQueue].shift();
          continue;
        }

        if (waitQueueMember[kCancelled]) {
          this[kWaitQueue].shift();
          continue;
        }

        if (this[kPoolState] !== exports.PoolState.ready) {
          var reason = this.closed ? 'poolClosed' : 'connectionError';
          var error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, error));

          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }

          this[kWaitQueue].shift();
          waitQueueMember.callback(error);
          continue;
        }

        if (!this.availableConnectionCount) {
          break;
        }

        var connection = this[kConnections].shift();

        if (!connection) {
          break;
        }

        if (!this.destroyConnectionIfPerished(connection)) {
          this[kCheckedOut].add(connection);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));

          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }

          this[kWaitQueue].shift();
          waitQueueMember.callback(undefined, connection);
        }
      }

      var _this$options = this.options,
          maxPoolSize = _this$options.maxPoolSize,
          maxConnecting = _this$options.maxConnecting;

      var _loop2 = function _loop2() {
        var waitQueueMember = _this9[kWaitQueue].shift();

        if (!waitQueueMember || waitQueueMember[kCancelled]) {
          return 1; // continue
        }

        _this9.createConnection(function (err, connection) {
          if (waitQueueMember[kCancelled]) {
            if (!err && connection) {
              _this9[kConnections].push(connection);
            }
          } else {
            if (err) {
              _this9.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, // TODO(NODE-5192): Remove this cast
              new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this9, 'connectionError', err));
            } else if (connection) {
              _this9[kCheckedOut].add(connection);

              _this9.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(_this9, connection));
            }

            if (waitQueueMember.timer) {
              (0, timers_1.clearTimeout)(waitQueueMember.timer);
            }

            waitQueueMember.callback(err, connection);
          }

          process.nextTick(function () {
            return _this9.processWaitQueue();
          });
        });
      };

      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        if (_loop2()) continue;
      }

      this[kProcessingWaitQueue] = false;
    }
  }]);

  return ConnectionPool;
}(mongo_types_1.TypedEventEmitter);
/**
 * Emitted when the connection pool is created.
 * @event
 */


ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
/**
 * Emitted once when the connection pool is closed
 * @event
 */

ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
/**
 * Emitted each time the connection pool is cleared and it's generation incremented
 * @event
 */

ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
/**
 * Emitted each time the connection pool is marked ready
 * @event
 */

ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
/**
 * Emitted when a connection is created.
 * @event
 */

ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
/**
 * Emitted when a connection becomes established, and is ready to use
 * @event
 */

ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
/**
 * Emitted when a connection is closed
 * @event
 */

ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
/**
 * Emitted when an attempt to check out a connection begins
 * @event
 */

ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
/**
 * Emitted when an attempt to check out a connection fails
 * @event
 */

ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
/**
 * Emitted each time a connection is successfully checked out of the connection pool
 * @event
 */

ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
/**
 * Emitted each time a connection is successfully checked into the connection pool
 * @event
 */

ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
exports.ConnectionPool = ConnectionPool;

/***/ }),

/***/ 1027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = void 0;

var constants_1 = __webpack_require__(9592);
/**
 * The base export class for all monitoring events published from the connection pool
 * @public
 * @category Event
 */


var ConnectionPoolMonitoringEvent = /*#__PURE__*/_createClass(
/** @internal */
function ConnectionPoolMonitoringEvent(pool) {
  _classCallCheck(this, ConnectionPoolMonitoringEvent);

  this.time = new Date();
  this.address = pool.address;
});

exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
/**
 * An event published when a connection pool is created
 * @public
 * @category Event
 */

var ConnectionPoolCreatedEvent = /*#__PURE__*/function (_ConnectionPoolMonito) {
  _inherits(ConnectionPoolCreatedEvent, _ConnectionPoolMonito);

  var _super = _createSuper(ConnectionPoolCreatedEvent);

  /** @internal */
  function ConnectionPoolCreatedEvent(pool) {
    var _this;

    _classCallCheck(this, ConnectionPoolCreatedEvent);

    _this = _super.call(this, pool);
    /** @internal */

    _this.name = constants_1.CONNECTION_POOL_CREATED;
    _this.options = pool.options;
    return _this;
  }

  return _createClass(ConnectionPoolCreatedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
/**
 * An event published when a connection pool is ready
 * @public
 * @category Event
 */

var ConnectionPoolReadyEvent = /*#__PURE__*/function (_ConnectionPoolMonito2) {
  _inherits(ConnectionPoolReadyEvent, _ConnectionPoolMonito2);

  var _super2 = _createSuper(ConnectionPoolReadyEvent);

  /** @internal */
  function ConnectionPoolReadyEvent(pool) {
    var _this2;

    _classCallCheck(this, ConnectionPoolReadyEvent);

    _this2 = _super2.call(this, pool);
    /** @internal */

    _this2.name = constants_1.CONNECTION_POOL_READY;
    return _this2;
  }

  return _createClass(ConnectionPoolReadyEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;
/**
 * An event published when a connection pool is closed
 * @public
 * @category Event
 */

var ConnectionPoolClosedEvent = /*#__PURE__*/function (_ConnectionPoolMonito3) {
  _inherits(ConnectionPoolClosedEvent, _ConnectionPoolMonito3);

  var _super3 = _createSuper(ConnectionPoolClosedEvent);

  /** @internal */
  function ConnectionPoolClosedEvent(pool) {
    var _this3;

    _classCallCheck(this, ConnectionPoolClosedEvent);

    _this3 = _super3.call(this, pool);
    /** @internal */

    _this3.name = constants_1.CONNECTION_POOL_CLOSED;
    return _this3;
  }

  return _createClass(ConnectionPoolClosedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
/**
 * An event published when a connection pool creates a new connection
 * @public
 * @category Event
 */

var ConnectionCreatedEvent = /*#__PURE__*/function (_ConnectionPoolMonito4) {
  _inherits(ConnectionCreatedEvent, _ConnectionPoolMonito4);

  var _super4 = _createSuper(ConnectionCreatedEvent);

  /** @internal */
  function ConnectionCreatedEvent(pool, connection) {
    var _this4;

    _classCallCheck(this, ConnectionCreatedEvent);

    _this4 = _super4.call(this, pool);
    /** @internal */

    _this4.name = constants_1.CONNECTION_CREATED;
    _this4.connectionId = connection.id;
    return _this4;
  }

  return _createClass(ConnectionCreatedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCreatedEvent = ConnectionCreatedEvent;
/**
 * An event published when a connection is ready for use
 * @public
 * @category Event
 */

var ConnectionReadyEvent = /*#__PURE__*/function (_ConnectionPoolMonito5) {
  _inherits(ConnectionReadyEvent, _ConnectionPoolMonito5);

  var _super5 = _createSuper(ConnectionReadyEvent);

  /** @internal */
  function ConnectionReadyEvent(pool, connection) {
    var _this5;

    _classCallCheck(this, ConnectionReadyEvent);

    _this5 = _super5.call(this, pool);
    /** @internal */

    _this5.name = constants_1.CONNECTION_READY;
    _this5.connectionId = connection.id;
    return _this5;
  }

  return _createClass(ConnectionReadyEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionReadyEvent = ConnectionReadyEvent;
/**
 * An event published when a connection is closed
 * @public
 * @category Event
 */

var ConnectionClosedEvent = /*#__PURE__*/function (_ConnectionPoolMonito6) {
  _inherits(ConnectionClosedEvent, _ConnectionPoolMonito6);

  var _super6 = _createSuper(ConnectionClosedEvent);

  /** @internal */
  function ConnectionClosedEvent(pool, connection, reason, error) {
    var _this6;

    _classCallCheck(this, ConnectionClosedEvent);

    _this6 = _super6.call(this, pool);
    /** @internal */

    _this6.name = constants_1.CONNECTION_CLOSED;
    _this6.connectionId = connection.id;
    _this6.reason = reason;
    _this6.serviceId = connection.serviceId;
    _this6.error = error !== null && error !== void 0 ? error : null;
    return _this6;
  }

  return _createClass(ConnectionClosedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionClosedEvent = ConnectionClosedEvent;
/**
 * An event published when a request to check a connection out begins
 * @public
 * @category Event
 */

var ConnectionCheckOutStartedEvent = /*#__PURE__*/function (_ConnectionPoolMonito7) {
  _inherits(ConnectionCheckOutStartedEvent, _ConnectionPoolMonito7);

  var _super7 = _createSuper(ConnectionCheckOutStartedEvent);

  /** @internal */
  function ConnectionCheckOutStartedEvent(pool) {
    var _this7;

    _classCallCheck(this, ConnectionCheckOutStartedEvent);

    _this7 = _super7.call(this, pool);
    /** @internal */

    _this7.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
    return _this7;
  }

  return _createClass(ConnectionCheckOutStartedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
/**
 * An event published when a request to check a connection out fails
 * @public
 * @category Event
 */

var ConnectionCheckOutFailedEvent = /*#__PURE__*/function (_ConnectionPoolMonito8) {
  _inherits(ConnectionCheckOutFailedEvent, _ConnectionPoolMonito8);

  var _super8 = _createSuper(ConnectionCheckOutFailedEvent);

  /** @internal */
  function ConnectionCheckOutFailedEvent(pool, reason, error) {
    var _this8;

    _classCallCheck(this, ConnectionCheckOutFailedEvent);

    _this8 = _super8.call(this, pool);
    /** @internal */

    _this8.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
    _this8.reason = reason;
    _this8.error = error;
    return _this8;
  }

  return _createClass(ConnectionCheckOutFailedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
/**
 * An event published when a connection is checked out of the connection pool
 * @public
 * @category Event
 */

var ConnectionCheckedOutEvent = /*#__PURE__*/function (_ConnectionPoolMonito9) {
  _inherits(ConnectionCheckedOutEvent, _ConnectionPoolMonito9);

  var _super9 = _createSuper(ConnectionCheckedOutEvent);

  /** @internal */
  function ConnectionCheckedOutEvent(pool, connection) {
    var _this9;

    _classCallCheck(this, ConnectionCheckedOutEvent);

    _this9 = _super9.call(this, pool);
    /** @internal */

    _this9.name = constants_1.CONNECTION_CHECKED_OUT;
    _this9.connectionId = connection.id;
    return _this9;
  }

  return _createClass(ConnectionCheckedOutEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
/**
 * An event published when a connection is checked into the connection pool
 * @public
 * @category Event
 */

var ConnectionCheckedInEvent = /*#__PURE__*/function (_ConnectionPoolMonito10) {
  _inherits(ConnectionCheckedInEvent, _ConnectionPoolMonito10);

  var _super10 = _createSuper(ConnectionCheckedInEvent);

  /** @internal */
  function ConnectionCheckedInEvent(pool, connection) {
    var _this10;

    _classCallCheck(this, ConnectionCheckedInEvent);

    _this10 = _super10.call(this, pool);
    /** @internal */

    _this10.name = constants_1.CONNECTION_CHECKED_IN;
    _this10.connectionId = connection.id;
    return _this10;
  }

  return _createClass(ConnectionCheckedInEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
/**
 * An event published when a connection pool is cleared
 * @public
 * @category Event
 */

var ConnectionPoolClearedEvent = /*#__PURE__*/function (_ConnectionPoolMonito11) {
  _inherits(ConnectionPoolClearedEvent, _ConnectionPoolMonito11);

  var _super11 = _createSuper(ConnectionPoolClearedEvent);

  /** @internal */
  function ConnectionPoolClearedEvent(pool) {
    var _this11;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConnectionPoolClearedEvent);

    _this11 = _super11.call(this, pool);
    /** @internal */

    _this11.name = constants_1.CONNECTION_POOL_CLEARED;
    _this11.serviceId = options.serviceId;
    _this11.interruptInUseConnections = options.interruptInUseConnections;
    return _this11;
  }

  return _createClass(ConnectionPoolClearedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;

/***/ }),

/***/ 2676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = void 0;

var error_1 = __webpack_require__(9525);
/**
 * An error indicating a connection pool is closed
 * @category Error
 */


var PoolClosedError = /*#__PURE__*/function (_error_1$MongoDriverE) {
  _inherits(PoolClosedError, _error_1$MongoDriverE);

  var _super = _createSuper(PoolClosedError);

  function PoolClosedError(pool) {
    var _this;

    _classCallCheck(this, PoolClosedError);

    _this = _super.call(this, 'Attempted to check out a connection from closed connection pool');
    _this.address = pool.address;
    return _this;
  }

  _createClass(PoolClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoPoolClosedError';
    }
  }]);

  return PoolClosedError;
}(error_1.MongoDriverError);

exports.PoolClosedError = PoolClosedError;
/**
 * An error indicating a connection pool is currently paused
 * @category Error
 */

var PoolClearedError = /*#__PURE__*/function (_error_1$MongoNetwork) {
  _inherits(PoolClearedError, _error_1$MongoNetwork);

  var _super2 = _createSuper(PoolClearedError);

  function PoolClearedError(pool, message) {
    var _pool$serverError;

    var _this2;

    _classCallCheck(this, PoolClearedError);

    var errorMessage = message ? message : "Connection pool for ".concat(pool.address, " was cleared because another operation failed with: \"").concat((_pool$serverError = pool.serverError) === null || _pool$serverError === void 0 ? void 0 : _pool$serverError.message, "\"");
    _this2 = _super2.call(this, errorMessage);
    _this2.address = pool.address;

    _this2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);

    return _this2;
  }

  _createClass(PoolClearedError, [{
    key: "name",
    get: function get() {
      return 'MongoPoolClearedError';
    }
  }]);

  return PoolClearedError;
}(error_1.MongoNetworkError);

exports.PoolClearedError = PoolClearedError;
/**
 * An error indicating that a connection pool has been cleared after the monitor for that server timed out.
 * @category Error
 */

var PoolClearedOnNetworkError = /*#__PURE__*/function (_PoolClearedError) {
  _inherits(PoolClearedOnNetworkError, _PoolClearedError);

  var _super3 = _createSuper(PoolClearedOnNetworkError);

  function PoolClearedOnNetworkError(pool) {
    _classCallCheck(this, PoolClearedOnNetworkError);

    return _super3.call(this, pool, "Connection to ".concat(pool.address, " interrupted due to server monitor timeout"));
  }

  _createClass(PoolClearedOnNetworkError, [{
    key: "name",
    get: function get() {
      return 'PoolClearedOnNetworkError';
    }
  }]);

  return PoolClearedOnNetworkError;
}(PoolClearedError);

exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;
/**
 * An error thrown when a request to check out a connection times out
 * @category Error
 */

var WaitQueueTimeoutError = /*#__PURE__*/function (_error_1$MongoDriverE2) {
  _inherits(WaitQueueTimeoutError, _error_1$MongoDriverE2);

  var _super4 = _createSuper(WaitQueueTimeoutError);

  function WaitQueueTimeoutError(message, address) {
    var _this3;

    _classCallCheck(this, WaitQueueTimeoutError);

    _this3 = _super4.call(this, message);
    _this3.address = address;
    return _this3;
  }

  _createClass(WaitQueueTimeoutError, [{
    key: "name",
    get: function get() {
      return 'MongoWaitQueueTimeoutError';
    }
  }]);

  return WaitQueueTimeoutError;
}(error_1.MongoDriverError);

exports.WaitQueueTimeoutError = WaitQueueTimeoutError;

/***/ }),

/***/ 5298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFAASEnv = exports.makeClientMetadata = exports.LimitedSizeDocument = void 0;

var os = __webpack_require__(2037);

var process = __webpack_require__(7282);

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525); // eslint-disable-next-line @typescript-eslint/no-var-requires


var NODE_DRIVER_VERSION = (__webpack_require__(1693)/* .version */ .i8);
/** @internal */


var LimitedSizeDocument = /*#__PURE__*/function () {
  function LimitedSizeDocument(maxSize) {
    _classCallCheck(this, LimitedSizeDocument);

    this.maxSize = maxSize;
    this.document = new Map();
    /** BSON overhead: Int32 + Null byte */

    this.documentSize = 5;
  }
  /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */


  _createClass(LimitedSizeDocument, [{
    key: "ifItFitsItSits",
    value: function ifItFitsItSits(key, value) {
      // The BSON byteLength of the new element is the same as serializing it to its own document
      // subtracting the document size int32 and the null terminator.
      var newElementSize = bson_1.BSON.serialize(new Map().set(key, value)).byteLength - 5;

      if (newElementSize + this.documentSize > this.maxSize) {
        return false;
      }

      this.documentSize += newElementSize;
      this.document.set(key, value);
      return true;
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
        promoteLongs: false,
        promoteBuffers: false,
        promoteValues: false,
        useBigInt64: false
      });
    }
  }]);

  return LimitedSizeDocument;
}();

exports.LimitedSizeDocument = LimitedSizeDocument;
/**
 * From the specs:
 * Implementors SHOULD cumulatively update fields in the following order until the document is under the size limit:
 * 1. Omit fields from `env` except `env.name`.
 * 2. Omit fields from `os` except `os.type`.
 * 3. Omit the `env` document entirely.
 * 4. Truncate `platform`. -- special we do not truncate this field
 */

function makeClientMetadata(options) {
  var metadataDocument = new LimitedSizeDocument(512);
  var _options$appName = options.appName,
      appName = _options$appName === void 0 ? '' : _options$appName; // Add app name first, it must be sent

  if (appName.length > 0) {
    var _name = Buffer.byteLength(appName, 'utf8') <= 128 ? options.appName : Buffer.from(appName, 'utf8').subarray(0, 128).toString('utf8');

    metadataDocument.ifItFitsItSits('application', {
      name: _name
    });
  }

  var _options$driverInfo = options.driverInfo,
      _options$driverInfo$n = _options$driverInfo.name,
      name = _options$driverInfo$n === void 0 ? '' : _options$driverInfo$n,
      _options$driverInfo$v = _options$driverInfo.version,
      version = _options$driverInfo$v === void 0 ? '' : _options$driverInfo$v,
      _options$driverInfo$p = _options$driverInfo.platform,
      platform = _options$driverInfo$p === void 0 ? '' : _options$driverInfo$p;
  var driverInfo = {
    name: name.length > 0 ? "nodejs|".concat(name) : 'nodejs',
    version: version.length > 0 ? "".concat(NODE_DRIVER_VERSION, "|").concat(version) : NODE_DRIVER_VERSION
  };

  if (!metadataDocument.ifItFitsItSits('driver', driverInfo)) {
    throw new error_1.MongoInvalidArgumentError('Unable to include driverInfo name and version, metadata cannot exceed 512 bytes');
  }

  var runtimeInfo = getRuntimeInfo();

  if (platform.length > 0) {
    runtimeInfo = "".concat(runtimeInfo, "|").concat(platform);
  }

  if (!metadataDocument.ifItFitsItSits('platform', runtimeInfo)) {
    throw new error_1.MongoInvalidArgumentError('Unable to include driverInfo platform, metadata cannot exceed 512 bytes');
  } // Note: order matters, os.type is last so it will be removed last if we're at maxSize


  var osInfo = new Map().set('name', process.platform).set('architecture', process.arch).set('version', os.release()).set('type', os.type());

  if (!metadataDocument.ifItFitsItSits('os', osInfo)) {
    var _iterator = _createForOfIteratorHelper(osInfo.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        osInfo["delete"](key);
        if (osInfo.size === 0) break;
        if (metadataDocument.ifItFitsItSits('os', osInfo)) break;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var faasEnv = getFAASEnv();

  if (faasEnv != null) {
    if (!metadataDocument.ifItFitsItSits('env', faasEnv)) {
      var _iterator2 = _createForOfIteratorHelper(faasEnv.keys()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _key = _step2.value;
          faasEnv["delete"](_key);
          if (faasEnv.size === 0) break;
          if (metadataDocument.ifItFitsItSits('env', faasEnv)) break;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }

  return metadataDocument.toObject();
}

exports.makeClientMetadata = makeClientMetadata;
/**
 * Collects FaaS metadata.
 * - `name` MUST be the last key in the Map returned.
 */

function getFAASEnv() {
  var _process$env = process.env,
      _process$env$AWS_EXEC = _process$env.AWS_EXECUTION_ENV,
      AWS_EXECUTION_ENV = _process$env$AWS_EXEC === void 0 ? '' : _process$env$AWS_EXEC,
      _process$env$AWS_LAMB = _process$env.AWS_LAMBDA_RUNTIME_API,
      AWS_LAMBDA_RUNTIME_API = _process$env$AWS_LAMB === void 0 ? '' : _process$env$AWS_LAMB,
      _process$env$FUNCTION = _process$env.FUNCTIONS_WORKER_RUNTIME,
      FUNCTIONS_WORKER_RUNTIME = _process$env$FUNCTION === void 0 ? '' : _process$env$FUNCTION,
      _process$env$K_SERVIC = _process$env.K_SERVICE,
      K_SERVICE = _process$env$K_SERVIC === void 0 ? '' : _process$env$K_SERVIC,
      _process$env$FUNCTION2 = _process$env.FUNCTION_NAME,
      FUNCTION_NAME = _process$env$FUNCTION2 === void 0 ? '' : _process$env$FUNCTION2,
      _process$env$VERCEL = _process$env.VERCEL,
      VERCEL = _process$env$VERCEL === void 0 ? '' : _process$env$VERCEL,
      _process$env$AWS_LAMB2 = _process$env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE,
      AWS_LAMBDA_FUNCTION_MEMORY_SIZE = _process$env$AWS_LAMB2 === void 0 ? '' : _process$env$AWS_LAMB2,
      _process$env$AWS_REGI = _process$env.AWS_REGION,
      AWS_REGION = _process$env$AWS_REGI === void 0 ? '' : _process$env$AWS_REGI,
      _process$env$FUNCTION3 = _process$env.FUNCTION_MEMORY_MB,
      FUNCTION_MEMORY_MB = _process$env$FUNCTION3 === void 0 ? '' : _process$env$FUNCTION3,
      _process$env$FUNCTION4 = _process$env.FUNCTION_REGION,
      FUNCTION_REGION = _process$env$FUNCTION4 === void 0 ? '' : _process$env$FUNCTION4,
      _process$env$FUNCTION5 = _process$env.FUNCTION_TIMEOUT_SEC,
      FUNCTION_TIMEOUT_SEC = _process$env$FUNCTION5 === void 0 ? '' : _process$env$FUNCTION5,
      _process$env$VERCEL_R = _process$env.VERCEL_REGION,
      VERCEL_REGION = _process$env$VERCEL_R === void 0 ? '' : _process$env$VERCEL_R;
  var isAWSFaaS = AWS_EXECUTION_ENV.startsWith('AWS_Lambda_') || AWS_LAMBDA_RUNTIME_API.length > 0;
  var isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
  var isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
  var isVercelFaaS = VERCEL.length > 0; // Note: order matters, name must always be the last key

  var faasEnv = new Map(); // When isVercelFaaS is true so is isAWSFaaS; Vercel inherits the AWS env

  if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
    if (VERCEL_REGION.length > 0) {
      faasEnv.set('region', VERCEL_REGION);
    }

    faasEnv.set('name', 'vercel');
    return faasEnv;
  }

  if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
    if (AWS_REGION.length > 0) {
      faasEnv.set('region', AWS_REGION);
    }

    if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
      faasEnv.set('memory_mb', new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
    }

    faasEnv.set('name', 'aws.lambda');
    return faasEnv;
  }

  if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
    faasEnv.set('name', 'azure.func');
    return faasEnv;
  }

  if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
    if (FUNCTION_REGION.length > 0) {
      faasEnv.set('region', FUNCTION_REGION);
    }

    if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
      faasEnv.set('memory_mb', new bson_1.Int32(FUNCTION_MEMORY_MB));
    }

    if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
      faasEnv.set('timeout_sec', new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
    }

    faasEnv.set('name', 'gcp.func');
    return faasEnv;
  }

  return null;
}

exports.getFAASEnv = getFAASEnv;
/**
 * @internal
 * Get current JavaScript runtime platform
 *
 * NOTE: The version information fetching is intentionally written defensively
 * to avoid having a released driver version that becomes incompatible
 * with a future change to these global objects.
 */

function getRuntimeInfo() {
  if ('Deno' in globalThis) {
    var _Deno, _Deno2;

    var version = typeof ((_Deno = Deno) === null || _Deno === void 0 || (_Deno = _Deno.version) === null || _Deno === void 0 ? void 0 : _Deno.deno) === 'string' ? (_Deno2 = Deno) === null || _Deno2 === void 0 || (_Deno2 = _Deno2.version) === null || _Deno2 === void 0 ? void 0 : _Deno2.deno : '0.0.0-unknown';
    return "Deno v".concat(version, ", ").concat(os.endianness());
  }

  if ('Bun' in globalThis) {
    var _Bun, _Bun2;

    var _version = typeof ((_Bun = Bun) === null || _Bun === void 0 ? void 0 : _Bun.version) === 'string' ? (_Bun2 = Bun) === null || _Bun2 === void 0 ? void 0 : _Bun2.version : '0.0.0-unknown';

    return "Bun v".concat(_version, ", ").concat(os.endianness());
  }

  return "Node.js ".concat(process.version, ", ").concat(os.endianness());
}

/***/ }),

/***/ 4980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageStream = void 0;

var stream_1 = __webpack_require__(2781);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var commands_1 = __webpack_require__(7136);

var compression_1 = __webpack_require__(435);

var constants_1 = __webpack_require__(7154);

var MESSAGE_HEADER_SIZE = 16;
var COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID

var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
/** @internal */

var kBuffer = Symbol('buffer');
/**
 * A duplex stream that is capable of reading and writing raw wire protocol messages, with
 * support for optional compression
 * @internal
 */

var MessageStream = /*#__PURE__*/function (_stream_1$Duplex) {
  _inherits(MessageStream, _stream_1$Duplex);

  var _super = _createSuper(MessageStream);

  function MessageStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MessageStream);

    _this = _super.call(this, options);
    /** @internal */

    _this.isMonitoringConnection = false;
    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
    _this[kBuffer] = new utils_1.BufferPool();
    return _this;
  }

  _createClass(MessageStream, [{
    key: "buffer",
    get: function get() {
      return this[kBuffer];
    }
  }, {
    key: "_write",
    value: function _write(chunk, _, callback) {
      this[kBuffer].append(chunk);
      processIncomingData(this, callback);
    }
  }, {
    key: "_read",
    value: function
      /* size */
    _read() {
      // NOTE: This implementation is empty because we explicitly push data to be read
      //       when `writeMessage` is called.
      return;
    }
  }, {
    key: "writeCommand",
    value: function writeCommand(command, operationDescription) {
      var _operationDescription,
          _operationDescription2,
          _this2 = this;

      var agreedCompressor = (_operationDescription = operationDescription.agreedCompressor) !== null && _operationDescription !== void 0 ? _operationDescription : 'none';

      if (agreedCompressor === 'none' || !canCompress(command)) {
        var data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      } // otherwise, compress the message


      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message

      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      var options = {
        agreedCompressor: agreedCompressor,
        zlibCompressionLevel: (_operationDescription2 = operationDescription.zlibCompressionLevel) !== null && _operationDescription2 !== void 0 ? _operationDescription2 : 0
      }; // Compress the message body

      (0, compression_1.compress)(options, messageToBeCompressed).then(function (compressedMessage) {
        // Create the msgHeader of OP_COMPRESSED
        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength

        msgHeader.writeInt32LE(command.requestId, 4); // requestID

        msgHeader.writeInt32LE(0, 8); // responseTo (zero)

        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode
        // Create the compression details of OP_COMPRESSED

        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode

        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader

        compressionDetails.writeUInt8(compression_1.Compressor[agreedCompressor], 8); // compressorID

        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      }, function (error) {
        operationDescription.cb(error);
      });
    }
  }]);

  return MessageStream;
}(stream_1.Duplex);

exports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term
// Will return true if command contains no uncompressible command terms

function canCompress(command) {
  var commandDoc = command instanceof commands_1.Msg ? command.command : command.query;
  var commandName = Object.keys(commandDoc)[0];
  return !compression_1.uncompressibleCommands.has(commandName);
}

function processIncomingData(stream, callback) {
  var buffer = stream[kBuffer];
  var sizeOfMessage = buffer.getInt32();

  if (sizeOfMessage == null) {
    return callback();
  }

  if (sizeOfMessage < 0) {
    return callback(new error_1.MongoParseError("Invalid message size: ".concat(sizeOfMessage)));
  }

  if (sizeOfMessage > stream.maxBsonMessageSize) {
    return callback(new error_1.MongoParseError("Invalid message size: ".concat(sizeOfMessage, ", max allowed: ").concat(stream.maxBsonMessageSize)));
  }

  if (sizeOfMessage > buffer.length) {
    return callback();
  }

  var message = buffer.read(sizeOfMessage);
  var messageHeader = {
    length: message.readInt32LE(0),
    requestId: message.readInt32LE(4),
    responseTo: message.readInt32LE(8),
    opCode: message.readInt32LE(12)
  };

  var monitorHasAnotherHello = function monitorHasAnotherHello() {
    if (stream.isMonitoringConnection) {
      // Can we read the next message size?
      var _sizeOfMessage = buffer.getInt32();

      if (_sizeOfMessage != null && _sizeOfMessage <= buffer.length) {
        return true;
      }
    }

    return false;
  };

  var ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;

  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {
    var messageBody = message.subarray(MESSAGE_HEADER_SIZE); // If we are a monitoring connection message stream and
    // there is more in the buffer that can be read, skip processing since we
    // want the last hello command response that is in the buffer.

    if (monitorHasAnotherHello()) {
      return processIncomingData(stream, callback);
    }

    stream.emit('message', new ResponseType(message, messageHeader, messageBody));

    if (buffer.length >= 4) {
      return processIncomingData(stream, callback);
    }

    return callback();
  }

  messageHeader.fromCompressed = true;
  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
  var compressorID = message[MESSAGE_HEADER_SIZE + 8];
  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode

  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
  (0, compression_1.decompress)(compressorID, compressedBuffer).then(function (messageBody) {
    if (messageBody.length !== messageHeader.length) {
      return callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));
    } // If we are a monitoring connection message stream and
    // there is more in the buffer that can be read, skip processing since we
    // want the last hello command response that is in the buffer.


    if (monitorHasAnotherHello()) {
      return processIncomingData(stream, callback);
    }

    stream.emit('message', new ResponseType(message, messageHeader, messageBody));

    if (buffer.length >= 4) {
      return processIncomingData(stream, callback);
    }

    return callback();
  }, function (error) {
    return callback(error);
  });
}

/***/ }),

/***/ 1186:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPoolMetrics = void 0;
/** @internal */

var ConnectionPoolMetrics = /*#__PURE__*/function () {
  function ConnectionPoolMetrics() {
    _classCallCheck(this, ConnectionPoolMetrics);

    this.txnConnections = 0;
    this.cursorConnections = 0;
    this.otherConnections = 0;
  }
  /**
   * Mark a connection as pinned for a specific operation.
   */


  _createClass(ConnectionPoolMetrics, [{
    key: "markPinned",
    value: function markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    /**
     * Unmark a connection as pinned for an operation.
     */

  }, {
    key: "markUnpinned",
    value: function markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    /**
     * Return information about the cmap metrics as a string.
     */

  }, {
    key: "info",
    value: function info(maxPoolSize) {
      return 'Timed out while checking out a connection from connection pool: ' + "maxPoolSize: ".concat(maxPoolSize, ", ") + "connections in use by cursors: ".concat(this.cursorConnections, ", ") + "connections in use by transactions: ".concat(this.txnConnections, ", ") + "connections in use by other operations: ".concat(this.otherConnections);
    }
    /**
     * Reset the metrics to the initial values.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }]);

  return ConnectionPoolMetrics;
}();

ConnectionPoolMetrics.TXN = 'txn';
ConnectionPoolMetrics.CURSOR = 'cursor';
ConnectionPoolMetrics.OTHER = 'other';
exports.ConnectionPoolMetrics = ConnectionPoolMetrics;

/***/ }),

/***/ 399:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamDescription = void 0;

var common_1 = __webpack_require__(2801);

var server_description_1 = __webpack_require__(3509);

var RESPONSE_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', 'logicalSessionTimeoutMinutes'];
/** @public */

var StreamDescription = /*#__PURE__*/function () {
  function StreamDescription(address, options) {
    _classCallCheck(this, StreamDescription);

    this.address = address;
    this.type = common_1.ServerType.Unknown;
    this.minWireVersion = undefined;
    this.maxWireVersion = undefined;
    this.maxBsonObjectSize = 16777216;
    this.maxMessageSizeBytes = 48000000;
    this.maxWriteBatchSize = 100000;
    this.logicalSessionTimeoutMinutes = options === null || options === void 0 ? void 0 : options.logicalSessionTimeoutMinutes;
    this.loadBalanced = !!(options !== null && options !== void 0 && options.loadBalanced);
    this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
  }

  _createClass(StreamDescription, [{
    key: "receiveResponse",
    value: function receiveResponse(response) {
      if (response == null) {
        return;
      }

      this.type = (0, server_description_1.parseServerType)(response);

      var _iterator = _createForOfIteratorHelper(RESPONSE_FIELDS),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;

          if (response[field] != null) {
            this[field] = response[field];
          } // testing case


          if ('__nodejs_mock_server__' in response) {
            this.__nodejs_mock_server__ = response['__nodejs_mock_server__'];
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (response.compression) {
        this.compressor = this.compressors.filter(function (c) {
          var _response$compression;

          return (_response$compression = response.compression) === null || _response$compression === void 0 ? void 0 : _response$compression.includes(c);
        })[0];
      }
    }
  }]);

  return StreamDescription;
}();

exports.StreamDescription = StreamDescription;

/***/ }),

/***/ 435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;

var util_1 = __webpack_require__(3837);

var zlib = __webpack_require__(9796);

var constants_1 = __webpack_require__(9592);

var deps_1 = __webpack_require__(8310);

var error_1 = __webpack_require__(9525);
/** @public */


exports.Compressor = Object.freeze({
  none: 0,
  snappy: 1,
  zlib: 2,
  zstd: 3
});
exports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);
var ZSTD_COMPRESSION_LEVEL = 3;
var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
var zstd;
var Snappy = null;

function loadSnappy() {
  if (Snappy == null) {
    var snappyImport = (0, deps_1.getSnappy)();

    if ('kModuleError' in snappyImport) {
      throw snappyImport.kModuleError;
    }

    Snappy = snappyImport;
  }

  return Snappy;
} // Facilitate compressing a message using an agreed compressor


function compress(_x, _x2) {
  return _compress.apply(this, arguments);
}

function _compress() {
  _compress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, dataToBeCompressed) {
    var zlibOptions, _Snappy;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          zlibOptions = {};
          _context.t0 = options.agreedCompressor;
          _context.next = _context.t0 === 'snappy' ? 4 : _context.t0 === 'zstd' ? 6 : _context.t0 === 'zlib' ? 10 : 12;
          break;

        case 4:
          (_Snappy = Snappy) !== null && _Snappy !== void 0 ? _Snappy : Snappy = loadSnappy();
          return _context.abrupt("return", Snappy.compress(dataToBeCompressed));

        case 6:
          loadZstd();

          if (!('kModuleError' in zstd)) {
            _context.next = 9;
            break;
          }

          throw zstd['kModuleError'];

        case 9:
          return _context.abrupt("return", zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL));

        case 10:
          if (options.zlibCompressionLevel) {
            zlibOptions.level = options.zlibCompressionLevel;
          }

          return _context.abrupt("return", zlibDeflate(dataToBeCompressed, zlibOptions));

        case 12:
          throw new error_1.MongoInvalidArgumentError("Unknown compressor ".concat(options.agreedCompressor, " failed to compress"));

        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _compress.apply(this, arguments);
}

exports.compress = compress; // Decompress a message using the given compressor

function decompress(_x3, _x4) {
  return _decompress.apply(this, arguments);
}

function _decompress() {
  _decompress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(compressorID, compressedData) {
    var _Snappy2;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none)) {
            _context2.next = 2;
            break;
          }

          throw new error_1.MongoDecompressionError("Server sent message compressed using an unsupported compressor. (Received compressor ID ".concat(compressorID, ")"));

        case 2:
          _context2.t0 = compressorID;
          _context2.next = _context2.t0 === exports.Compressor.snappy ? 5 : _context2.t0 === exports.Compressor.zstd ? 7 : _context2.t0 === exports.Compressor.zlib ? 11 : 12;
          break;

        case 5:
          (_Snappy2 = Snappy) !== null && _Snappy2 !== void 0 ? _Snappy2 : Snappy = loadSnappy();
          return _context2.abrupt("return", Snappy.uncompress(compressedData, {
            asBuffer: true
          }));

        case 7:
          loadZstd();

          if (!('kModuleError' in zstd)) {
            _context2.next = 10;
            break;
          }

          throw zstd['kModuleError'];

        case 10:
          return _context2.abrupt("return", zstd.decompress(compressedData));

        case 11:
          return _context2.abrupt("return", zlibInflate(compressedData));

        case 12:
          return _context2.abrupt("return", compressedData);

        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _decompress.apply(this, arguments);
}

exports.decompress = decompress;
/**
 * Load ZStandard if it is not already set.
 */

function loadZstd() {
  if (!zstd) {
    zstd = (0, deps_1.getZstdLibrary)();
  }
}

/***/ }),

/***/ 7154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = void 0;
exports.MIN_SUPPORTED_SERVER_VERSION = '3.6';
exports.MAX_SUPPORTED_SERVER_VERSION = '7.0';
exports.MIN_SUPPORTED_WIRE_VERSION = 6;
exports.MAX_SUPPORTED_WIRE_VERSION = 21;
exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
exports.MIN_SUPPORTED_QE_SERVER_VERSION = '7.0';
exports.OP_REPLY = 1;
exports.OP_UPDATE = 2001;
exports.OP_INSERT = 2002;
exports.OP_QUERY = 2004;
exports.OP_DELETE = 2006;
exports.OP_COMPRESSED = 2012;
exports.OP_MSG = 2013;

/***/ }),

/***/ 8118:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isSharded = exports.getReadPreference = void 0;

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var common_1 = __webpack_require__(2801);

var topology_description_1 = __webpack_require__(8707);

function getReadPreference(options) {
  var _options$readPreferen;

  // Default to command version of the readPreference
  var readPreference = (_options$readPreferen = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one

  if (options !== null && options !== void 0 && options.readPreference) {
    readPreference = options.readPreference;
  }

  if (typeof readPreference === 'string') {
    readPreference = read_preference_1.ReadPreference.fromString(readPreference);
  }

  if (!(readPreference instanceof read_preference_1.ReadPreference)) {
    throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
  }

  return readPreference;
}

exports.getReadPreference = getReadPreference;

function isSharded(topologyOrServer) {
  if (topologyOrServer == null) {
    return false;
  }

  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
    return true;
  } // NOTE: This is incredibly inefficient, and should be removed once command construction
  //       happens based on `Server` not `Topology`.


  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
    var servers = Array.from(topologyOrServer.description.servers.values());
    return servers.some(function (server) {
      return server.type === common_1.ServerType.Mongos;
    });
  }

  return false;
}

exports.isSharded = isSharded;

/***/ }),

/***/ 9816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Collection = void 0;

var bson_1 = __webpack_require__(4356);

var ordered_1 = __webpack_require__(5873);

var unordered_1 = __webpack_require__(2325);

var change_stream_1 = __webpack_require__(7944);

var aggregation_cursor_1 = __webpack_require__(334);

var find_cursor_1 = __webpack_require__(246);

var list_indexes_cursor_1 = __webpack_require__(1512);

var list_search_indexes_cursor_1 = __webpack_require__(8422);

var error_1 = __webpack_require__(9525);

var bulk_write_1 = __webpack_require__(847);

var count_1 = __webpack_require__(5129);

var count_documents_1 = __webpack_require__(2411);

var delete_1 = __webpack_require__(4371);

var distinct_1 = __webpack_require__(4629);

var drop_1 = __webpack_require__(4149);

var estimated_document_count_1 = __webpack_require__(2421);

var execute_operation_1 = __webpack_require__(5756);

var find_and_modify_1 = __webpack_require__(1253);

var indexes_1 = __webpack_require__(240);

var insert_1 = __webpack_require__(3583);

var is_capped_1 = __webpack_require__(4785);

var options_operation_1 = __webpack_require__(6687);

var rename_1 = __webpack_require__(116);

var create_1 = __webpack_require__(9471);

var drop_2 = __webpack_require__(8655);

var update_1 = __webpack_require__(1391);

var stats_1 = __webpack_require__(5142);

var update_2 = __webpack_require__(8679);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);
/**
 * The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/find/update/delete and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @public
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * interface Pet {
 *   name: string;
 *   kind: 'dog' | 'cat' | 'fish';
 * }
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * const pets = client.db().collection<Pet>('pets');
 *
 * const petCursor = pets.find();
 *
 * for await (const pet of petCursor) {
 *   console.log(`${pet.name} is a ${pet.kind}!`);
 * }
 * ```
 */


var Collection = /*#__PURE__*/function () {
  /**
   * Create a new Collection instance
   * @internal
   */
  function Collection(db, name, options) {
    var _db$options$pkFactory, _db$options;

    _classCallCheck(this, Collection);

    (0, utils_1.checkCollectionName)(name); // Internal state

    this.s = {
      db: db,
      options: options,
      namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
      pkFactory: (_db$options$pkFactory = (_db$options = db.options) === null || _db$options === void 0 ? void 0 : _db$options.pkFactory) !== null && _db$options$pkFactory !== void 0 ? _db$options$pkFactory : utils_1.DEFAULT_PK_FACTORY,
      readPreference: read_preference_1.ReadPreference.fromOptions(options),
      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
      readConcern: read_concern_1.ReadConcern.fromOptions(options),
      writeConcern: write_concern_1.WriteConcern.fromOptions(options)
    };
    this.client = db.client;
  }
  /**
   * The name of the database this collection belongs to
   */


  _createClass(Collection, [{
    key: "dbName",
    get: function get() {
      return this.s.namespace.db;
    }
    /**
     * The name of this collection
     */

  }, {
    key: "collectionName",
    get: function get() {
      return this.s.namespace.collection;
    }
    /**
     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
     */

  }, {
    key: "namespace",
    get: function get() {
      return this.fullNamespace.toString();
    }
    /**
     *  @internal
     *
     * The `MongoDBNamespace` for the collection.
     */

  }, {
    key: "fullNamespace",
    get: function get() {
      return this.s.namespace;
    }
    /**
     * The current readConcern of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "readConcern",
    get: function get() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }

      return this.s.readConcern;
    }
    /**
     * The current readPreference of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "readPreference",
    get: function get() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }

      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
    /**
     * The current writeConcern of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "writeConcern",
    get: function get() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }

      return this.s.writeConcern;
    }
    /** The current index hint for the collection */

  }, {
    key: "hint",
    get: function get() {
      return this.s.collectionHint;
    },
    set: function set(v) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
    }
    /**
     * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param doc - The document to insert
     * @param options - Optional settings for the command
     */

  }, {
    key: "insertOne",
    value: function () {
      var _insertOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(doc, options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function insertOne(_x, _x2) {
        return _insertOne.apply(this, arguments);
      }

      return insertOne;
    }()
    /**
     * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param docs - The documents to insert
     * @param options - Optional settings for the command
     */

  }, {
    key: "insertMany",
    value: function () {
      var _insertMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(docs, options) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options !== null && options !== void 0 ? options : {
                ordered: true
              }))));

            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function insertMany(_x3, _x4) {
        return _insertMany.apply(this, arguments);
      }

      return insertMany;
    }()
    /**
     * Perform a bulkWrite operation without a fluent API
     *
     * Legal operation types are
     * - `insertOne`
     * - `replaceOne`
     * - `updateOne`
     * - `updateMany`
     * - `deleteOne`
     * - `deleteMany`
     *
     * If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param operations - Bulk operations to perform
     * @param options - Optional settings for the command
     * @throws MongoDriverError if operations is not an array
     */

  }, {
    key: "bulkWrite",
    value: function () {
      var _bulkWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operations, options) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (Array.isArray(operations)) {
                _context3.next = 2;
                break;
              }

              throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');

            case 2:
              return _context3.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options !== null && options !== void 0 ? options : {
                ordered: true
              }))));

            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function bulkWrite(_x5, _x6) {
        return _bulkWrite.apply(this, arguments);
      }

      return bulkWrite;
    }()
    /**
     * Update a single document in a collection
     *
     * @param filter - The filter used to select the document to update
     * @param update - The update operations to be applied to the document
     * @param options - Optional settings for the command
     */

  }, {
    key: "updateOne",
    value: function () {
      var _updateOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filter, update, options) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function updateOne(_x7, _x8, _x9) {
        return _updateOne.apply(this, arguments);
      }

      return updateOne;
    }()
    /**
     * Replace a document in a collection with another document
     *
     * @param filter - The filter used to select the document to replace
     * @param replacement - The Document that replaces the matching document
     * @param options - Optional settings for the command
     */

  }, {
    key: "replaceOne",
    value: function () {
      var _replaceOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(filter, replacement, options) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function replaceOne(_x10, _x11, _x12) {
        return _replaceOne.apply(this, arguments);
      }

      return replaceOne;
    }()
    /**
     * Update multiple documents in a collection
     *
     * @param filter - The filter used to select the documents to update
     * @param update - The update operations to be applied to the documents
     * @param options - Optional settings for the command
     */

  }, {
    key: "updateMany",
    value: function () {
      var _updateMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(filter, update, options) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function updateMany(_x13, _x14, _x15) {
        return _updateMany.apply(this, arguments);
      }

      return updateMany;
    }()
    /**
     * Delete a document from a collection
     *
     * @param filter - The filter used to select the document to remove
     * @param options - Optional settings for the command
     */

  }, {
    key: "deleteOne",
    value: function () {
      var _deleteOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var filter,
            options,
            _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              filter = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
              options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
              return _context7.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function deleteOne() {
        return _deleteOne.apply(this, arguments);
      }

      return deleteOne;
    }()
    /**
     * Delete multiple documents from a collection
     *
     * @param filter - The filter used to select the documents to remove
     * @param options - Optional settings for the command
     */

  }, {
    key: "deleteMany",
    value: function () {
      var _deleteMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var filter,
            options,
            _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              filter = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
              options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
              return _context8.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function deleteMany() {
        return _deleteMany.apply(this, arguments);
      }

      return deleteMany;
    }()
    /**
     * Rename the collection.
     *
     * @remarks
     * This operation does not inherit options from the Db or MongoClient.
     *
     * @param newName - New name of of the collection.
     * @param options - Optional settings for the command
     */

  }, {
    key: "rename",
    value: function () {
      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(newName, options) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, _objectSpread(_objectSpread({}, options), {}, {
                readPreference: read_preference_1.ReadPreference.PRIMARY
              }))));

            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function rename(_x16, _x17) {
        return _rename.apply(this, arguments);
      }

      return rename;
    }()
    /**
     * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "drop",
    value: function () {
      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options)));

            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function drop(_x18) {
        return _drop.apply(this, arguments);
      }

      return drop;
    }()
  }, {
    key: "findOne",
    value: function () {
      var _findOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var filter,
            options,
            _args11 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              filter = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};
              options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};
              return _context11.abrupt("return", this.find(filter, options).limit(-1).batchSize(1).next());

            case 3:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      function findOne() {
        return _findOne.apply(this, arguments);
      }

      return findOne;
    }()
  }, {
    key: "find",
    value: function find() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Returns the options of the collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "options",
    value: function () {
      var _options2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_options) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, _options))));

            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));

      function options(_x19) {
        return _options2.apply(this, arguments);
      }

      return options;
    }()
    /**
     * Returns if the collection is a capped collection
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "isCapped",
    value: function () {
      var _isCapped = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));

      function isCapped(_x20) {
        return _isCapped.apply(this, arguments);
      }

      return isCapped;
    }()
    /**
     * Creates an index on the db and collection collection.
     *
     * @param indexSpec - The field name or index specification to create an index for
     * @param options - Optional settings for the command
     *
     * @example
     * ```ts
     * const collection = client.db('foo').collection('bar');
     *
     * await collection.createIndex({ a: 1, b: -1 });
     *
     * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes
     * await collection.createIndex([ [c, 1], [d, -1] ]);
     *
     * // Equivalent to { e: 1 }
     * await collection.createIndex('e');
     *
     * // Equivalent to { f: 1, g: 1 }
     * await collection.createIndex(['f', 'g'])
     *
     * // Equivalent to { h: 1, i: -1 }
     * await collection.createIndex([ { h: 1 }, { i: -1 } ]);
     *
     * // Equivalent to { j: 1, k: -1, l: 2d }
     * await collection.createIndex(['j', ['k', -1], { l: '2d' }])
     * ```
     */

  }, {
    key: "createIndex",
    value: function () {
      var _createIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(indexSpec, options) {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));

      function createIndex(_x21, _x22) {
        return _createIndex.apply(this, arguments);
      }

      return createIndex;
    }()
    /**
     * Creates multiple indexes in the collection, this method is only supported for
     * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
     * error.
     *
     * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.
     * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.
     *
     * @param indexSpecs - An array of index specifications to be created
     * @param options - Optional settings for the command
     *
     * @example
     * ```ts
     * const collection = client.db('foo').collection('bar');
     * await collection.createIndexes([
     *   // Simple index on field fizz
     *   {
     *     key: { fizz: 1 },
     *   }
     *   // wildcard index
     *   {
     *     key: { '$**': 1 }
     *   },
     *   // named index on darmok and jalad
     *   {
     *     key: { darmok: 1, jalad: -1 }
     *     name: 'tanagra'
     *   }
     * ]);
     * ```
     */

  }, {
    key: "createIndexes",
    value: function () {
      var _createIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(indexSpecs, options) {
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              return _context15.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, _objectSpread(_objectSpread({}, options), {}, {
                maxTimeMS: undefined
              })))));

            case 1:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));

      function createIndexes(_x23, _x24) {
        return _createIndexes.apply(this, arguments);
      }

      return createIndexes;
    }()
    /**
     * Drops an index from this collection.
     *
     * @param indexName - Name of the index to drop.
     * @param options - Optional settings for the command
     */

  }, {
    key: "dropIndex",
    value: function () {
      var _dropIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(indexName, options) {
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              return _context16.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, _objectSpread(_objectSpread({}, (0, utils_1.resolveOptions)(this, options)), {}, {
                readPreference: read_preference_1.ReadPreference.primary
              }))));

            case 1:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));

      function dropIndex(_x25, _x26) {
        return _dropIndex.apply(this, arguments);
      }

      return dropIndex;
    }()
    /**
     * Drops all indexes from this collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "dropIndexes",
    value: function () {
      var _dropIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(options) {
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              return _context17.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));

      function dropIndexes(_x27) {
        return _dropIndexes.apply(this, arguments);
      }

      return dropIndexes;
    }()
    /**
     * Get the list of all indexes information for the collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "listIndexes",
    value: function listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Checks if one or more indexes exist on the collection, fails on first non-existing index
     *
     * @param indexes - One or more index names to check.
     * @param options - Optional settings for the command
     */

  }, {
    key: "indexExists",
    value: function () {
      var _indexExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(indexes, options) {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              return _context18.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));

      function indexExists(_x28, _x29) {
        return _indexExists.apply(this, arguments);
      }

      return indexExists;
    }()
    /**
     * Retrieves this collections index info.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "indexInformation",
    value: function () {
      var _indexInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(options) {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              return _context19.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));

      function indexInformation(_x30) {
        return _indexInformation.apply(this, arguments);
      }

      return indexInformation;
    }()
    /**
     * Gets an estimate of the count of documents in a collection using collection metadata.
     * This will always run a count command on all server versions.
     *
     * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,
     * which estimatedDocumentCount uses in its implementation, was not included in v1 of
     * the Stable API, and so users of the Stable API with estimatedDocumentCount are
     * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid
     * encountering errors.
     *
     * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}
     * @param options - Optional settings for the command
     */

  }, {
    key: "estimatedDocumentCount",
    value: function () {
      var _estimatedDocumentCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(options) {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              return _context20.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));

      function estimatedDocumentCount(_x31) {
        return _estimatedDocumentCount.apply(this, arguments);
      }

      return estimatedDocumentCount;
    }()
    /**
     * Gets the number of documents matching the filter.
     * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
     * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}
     * the following query operators must be replaced:
     *
     * | Operator | Replacement |
     * | -------- | ----------- |
     * | `$where`   | [`$expr`][1] |
     * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
     * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
     *
     * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/
     * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
     * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
     * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
     *
     * @param filter - The filter for the count
     * @param options - Optional settings for the command
     *
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
     */

  }, {
    key: "countDocuments",
    value: function () {
      var _countDocuments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        var filter,
            options,
            _args21 = arguments;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              filter = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : {};
              options = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};
              return _context21.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));

      function countDocuments() {
        return _countDocuments.apply(this, arguments);
      }

      return countDocuments;
    }()
  }, {
    key: "distinct",
    value: function () {
      var _distinct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(key) {
        var filter,
            options,
            _args22 = arguments;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              filter = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {};
              options = _args22.length > 2 && _args22[2] !== undefined ? _args22[2] : {};
              return _context22.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));

      function distinct(_x32) {
        return _distinct.apply(this, arguments);
      }

      return distinct;
    }()
    /**
     * Retrieve all the indexes on the collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "indexes",
    value: function () {
      var _indexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(options) {
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              return _context23.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));

      function indexes(_x33) {
        return _indexes.apply(this, arguments);
      }

      return indexes;
    }()
    /**
     * Get all the collection statistics.
     *
     * @deprecated the `collStats` operation will be removed in the next major release.  Please
     * use an aggregation pipeline with the [`$collStats`](https://www.mongodb.com/docs/manual/reference/operator/aggregation/collStats/) stage instead
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "stats",
    value: function () {
      var _stats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(options) {
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              return _context24.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new stats_1.CollStatsOperation(this, options)));

            case 1:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));

      function stats(_x34) {
        return _stats.apply(this, arguments);
      }

      return stats;
    }()
  }, {
    key: "findOneAndDelete",
    value: function () {
      var _findOneAndDelete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(filter, options) {
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              return _context25.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));

      function findOneAndDelete(_x35, _x36) {
        return _findOneAndDelete.apply(this, arguments);
      }

      return findOneAndDelete;
    }()
  }, {
    key: "findOneAndReplace",
    value: function () {
      var _findOneAndReplace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(filter, replacement, options) {
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              return _context26.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));

      function findOneAndReplace(_x37, _x38, _x39) {
        return _findOneAndReplace.apply(this, arguments);
      }

      return findOneAndReplace;
    }()
  }, {
    key: "findOneAndUpdate",
    value: function () {
      var _findOneAndUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(filter, update, options) {
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              return _context27.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));

      function findOneAndUpdate(_x40, _x41, _x42) {
        return _findOneAndUpdate.apply(this, arguments);
      }

      return findOneAndUpdate;
    }()
    /**
     * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
     *
     * @param pipeline - An array of aggregation pipelines to execute
     * @param options - Optional settings for the command
     */

  }, {
    key: "aggregate",
    value: function aggregate() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (!Array.isArray(pipeline)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }

      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to override the schema that may be defined for this specific collection
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     * @example
     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
     * ```ts
     * collection.watch<{ _id: number }>()
     *   .on('change', change => console.log(change._id.toFixed(4)));
     * ```
     *
     * @example
     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
     * No need start from scratch on the ChangeStreamInsertDocument type!
     * By using an intersection we can save time and ensure defaults remain the same type!
     * ```ts
     * collection
     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
     *     { $addFields: { comment: 'big changes' } },
     *     { $match: { operationType: 'insert' } }
     *   ])
     *   .on('change', change => {
     *     change.comment.startsWith('big');
     *     change.operationType === 'insert';
     *     // No need to narrow in code because the generics did that for us!
     *     expectType<Schema>(change.fullDocument);
     *   });
     * ```
     *
     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TLocal - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */

  }, {
    key: "initializeUnorderedBulkOp",
    value: function initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */

  }, {
    key: "initializeOrderedBulkOp",
    value: function initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * An estimated count of matching documents in the db to a filter.
     *
     * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents
     * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.
     * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
     *
     * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead
     *
     * @param filter - The filter for the count.
     * @param options - Optional settings for the command
     */

  }, {
    key: "count",
    value: function () {
      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        var filter,
            options,
            _args28 = arguments;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              filter = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {};
              options = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : {};
              return _context28.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));

      function count() {
        return _count.apply(this, arguments);
      }

      return count;
    }()
  }, {
    key: "listSearchIndexes",
    value: function listSearchIndexes(indexNameOrOptions, options) {
      options = _typeof(indexNameOrOptions) === 'object' ? indexNameOrOptions : options == null ? {} : options;
      var indexName = indexNameOrOptions == null ? null : _typeof(indexNameOrOptions) === 'object' ? null : indexNameOrOptions;
      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    }
    /**
     * Creates a single search index for the collection.
     *
     * @param description - The index description for the new search index.
     * @returns A promise that resolves to the name of the new search index.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */

  }, {
    key: "createSearchIndex",
    value: function () {
      var _createSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(description) {
        var _yield$this$createSea, _yield$this$createSea2, index;

        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.createSearchIndexes([description]);

            case 2:
              _yield$this$createSea = _context29.sent;
              _yield$this$createSea2 = _slicedToArray(_yield$this$createSea, 1);
              index = _yield$this$createSea2[0];
              return _context29.abrupt("return", index);

            case 6:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));

      function createSearchIndex(_x43) {
        return _createSearchIndex.apply(this, arguments);
      }

      return createSearchIndex;
    }()
    /**
     * Creates multiple search indexes for the current collection.
     *
     * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.
     * @returns A promise that resolves to an array of the newly created search index names.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     * @returns
     */

  }, {
    key: "createSearchIndexes",
    value: function () {
      var _createSearchIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(descriptions) {
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              return _context30.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions)));

            case 1:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));

      function createSearchIndexes(_x44) {
        return _createSearchIndexes.apply(this, arguments);
      }

      return createSearchIndexes;
    }()
    /**
     * Deletes a search index by index name.
     *
     * @param name - The name of the search index to be deleted.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */

  }, {
    key: "dropSearchIndex",
    value: function () {
      var _dropSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(name) {
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              return _context31.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name)));

            case 1:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));

      function dropSearchIndex(_x45) {
        return _dropSearchIndex.apply(this, arguments);
      }

      return dropSearchIndex;
    }()
    /**
     * Updates a search index by replacing the existing index definition with the provided definition.
     *
     * @param name - The name of the search index to update.
     * @param definition - The new search index definition.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */

  }, {
    key: "updateSearchIndex",
    value: function () {
      var _updateSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(name, definition) {
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              return _context32.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition)));

            case 1:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));

      function updateSearchIndex(_x46, _x47) {
        return _updateSearchIndex.apply(this, arguments);
      }

      return updateSearchIndex;
    }()
  }]);

  return Collection;
}();

exports.Collection = Collection;

/***/ }),

/***/ 1825:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

var _marked = /*#__PURE__*/_regeneratorRuntime().mark(entriesFromString);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = exports.parseOptions = exports.resolveSRVRecord = void 0;

var dns = __webpack_require__(9523);

var fs = __webpack_require__(7147);

var mongodb_connection_string_url_1 = __webpack_require__(7578);

var url_1 = __webpack_require__(7310);

var mongo_credentials_1 = __webpack_require__(7739);

var providers_1 = __webpack_require__(4923);

var client_metadata_1 = __webpack_require__(5298);

var compression_1 = __webpack_require__(435);

var encrypter_1 = __webpack_require__(816);

var error_1 = __webpack_require__(9525);

var mongo_client_1 = __webpack_require__(3094);

var mongo_logger_1 = __webpack_require__(1274);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);

var VALID_TXT_RECORDS = ['authSource', 'replicaSet', 'loadBalanced'];
var LB_SINGLE_HOST_ERROR = 'loadBalanced option only supported with a single host in the URI';
var LB_REPLICA_SET_ERROR = 'loadBalanced option not supported with a replicaSet option';
var LB_DIRECT_CONNECTION_ERROR = 'loadBalanced option not supported when directConnection is provided';
/**
 * Lookup a `mongodb+srv` connection string, combine the parts and reparse it as a normal
 * connection string.
 *
 * @param uri - The connection string to parse
 * @param options - Optional user provided connection string options
 */

function resolveSRVRecord(_x) {
  return _resolveSRVRecord.apply(this, arguments);
}

function _resolveSRVRecord() {
  _resolveSRVRecord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
    var _txtRecordOptions$get, _txtRecordOptions$get2, _txtRecordOptions$get3;

    var lookupAddress, addresses, _iterator12, _step12, name, hostAddresses, record, txtRecordOptions, txtRecordOptionKeys, source, replicaSet, loadBalanced;

    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof options.srvHost !== 'string')) {
            _context2.next = 2;
            break;
          }

          throw new error_1.MongoAPIError('Option "srvHost" must not be empty');

        case 2:
          if (!(options.srvHost.split('.').length < 3)) {
            _context2.next = 4;
            break;
          }

          throw new error_1.MongoAPIError('URI must include hostname, domain name, and tld');

        case 4:
          // Resolve the SRV record and use the result as the list of hosts to connect to.
          lookupAddress = options.srvHost;
          _context2.next = 7;
          return dns.promises.resolveSrv("_".concat(options.srvServiceName, "._tcp.").concat(lookupAddress));

        case 7:
          addresses = _context2.sent;

          if (!(addresses.length === 0)) {
            _context2.next = 10;
            break;
          }

          throw new error_1.MongoAPIError('No addresses found at host');

        case 10:
          _iterator12 = _createForOfIteratorHelper(addresses);
          _context2.prev = 11;

          _iterator12.s();

        case 13:
          if ((_step12 = _iterator12.n()).done) {
            _context2.next = 19;
            break;
          }

          name = _step12.value.name;

          if ((0, utils_1.matchesParentDomain)(name, lookupAddress)) {
            _context2.next = 17;
            break;
          }

          throw new error_1.MongoAPIError('Server record does not share hostname with parent URI');

        case 17:
          _context2.next = 13;
          break;

        case 19:
          _context2.next = 24;
          break;

        case 21:
          _context2.prev = 21;
          _context2.t0 = _context2["catch"](11);

          _iterator12.e(_context2.t0);

        case 24:
          _context2.prev = 24;

          _iterator12.f();

          return _context2.finish(24);

        case 27:
          hostAddresses = addresses.map(function (r) {
            var _r$port;

            return utils_1.HostAddress.fromString("".concat(r.name, ":").concat((_r$port = r.port) !== null && _r$port !== void 0 ? _r$port : 27017));
          });
          validateLoadBalancedOptions(hostAddresses, options, true); // Resolve TXT record and add options from there if they exist.

          _context2.prev = 29;
          _context2.next = 32;
          return dns.promises.resolveTxt(lookupAddress);

        case 32:
          record = _context2.sent;
          _context2.next = 40;
          break;

        case 35:
          _context2.prev = 35;
          _context2.t1 = _context2["catch"](29);

          if (!(_context2.t1.code !== 'ENODATA' && _context2.t1.code !== 'ENOTFOUND')) {
            _context2.next = 39;
            break;
          }

          throw _context2.t1;

        case 39:
          return _context2.abrupt("return", hostAddresses);

        case 40:
          if (!(record.length > 1)) {
            _context2.next = 42;
            break;
          }

          throw new error_1.MongoParseError('Multiple text records not allowed');

        case 42:
          txtRecordOptions = new url_1.URLSearchParams(record[0].join(''));
          txtRecordOptionKeys = _toConsumableArray(txtRecordOptions.keys());

          if (!txtRecordOptionKeys.some(function (key) {
            return !VALID_TXT_RECORDS.includes(key);
          })) {
            _context2.next = 46;
            break;
          }

          throw new error_1.MongoParseError("Text record may only set any of: ".concat(VALID_TXT_RECORDS.join(', ')));

        case 46:
          if (!VALID_TXT_RECORDS.some(function (option) {
            return txtRecordOptions.get(option) === '';
          })) {
            _context2.next = 48;
            break;
          }

          throw new error_1.MongoParseError('Cannot have empty URI params in DNS TXT Record');

        case 48:
          source = (_txtRecordOptions$get = txtRecordOptions.get('authSource')) !== null && _txtRecordOptions$get !== void 0 ? _txtRecordOptions$get : undefined;
          replicaSet = (_txtRecordOptions$get2 = txtRecordOptions.get('replicaSet')) !== null && _txtRecordOptions$get2 !== void 0 ? _txtRecordOptions$get2 : undefined;
          loadBalanced = (_txtRecordOptions$get3 = txtRecordOptions.get('loadBalanced')) !== null && _txtRecordOptions$get3 !== void 0 ? _txtRecordOptions$get3 : undefined;

          if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
            options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, {
              source: source
            });
          }

          if (!options.userSpecifiedReplicaSet && replicaSet) {
            options.replicaSet = replicaSet;
          }

          if (loadBalanced === 'true') {
            options.loadBalanced = true;
          }

          if (!(options.replicaSet && options.srvMaxHosts > 0)) {
            _context2.next = 56;
            break;
          }

          throw new error_1.MongoParseError('Cannot combine replicaSet option with srvMaxHosts');

        case 56:
          validateLoadBalancedOptions(hostAddresses, options, true);
          return _context2.abrupt("return", hostAddresses);

        case 58:
        case "end":
          return _context2.stop();
      }
    }, _callee, null, [[11, 21, 24, 27], [29, 35]]);
  }));
  return _resolveSRVRecord.apply(this, arguments);
}

exports.resolveSRVRecord = resolveSRVRecord;
/**
 * Checks if TLS options are valid
 *
 * @param allOptions - All options provided by user or included in default options map
 * @throws MongoAPIError if TLS options are invalid
 */

function checkTLSOptions(allOptions) {
  if (!allOptions) return;

  var check = function check(a, b) {
    if (allOptions.has(a) && allOptions.has(b)) {
      throw new error_1.MongoAPIError("The '".concat(a, "' option cannot be used with the '").concat(b, "' option"));
    }
  };

  check('tlsInsecure', 'tlsAllowInvalidCertificates');
  check('tlsInsecure', 'tlsAllowInvalidHostnames');
  check('tlsInsecure', 'tlsDisableCertificateRevocationCheck');
  check('tlsInsecure', 'tlsDisableOCSPEndpointCheck');
  check('tlsAllowInvalidCertificates', 'tlsDisableCertificateRevocationCheck');
  check('tlsAllowInvalidCertificates', 'tlsDisableOCSPEndpointCheck');
  check('tlsDisableCertificateRevocationCheck', 'tlsDisableOCSPEndpointCheck');
}

var TRUTHS = new Set(['true', 't', '1', 'y', 'yes']);
var FALSEHOODS = new Set(['false', 'f', '0', 'n', 'no', '-1']);

function getBoolean(name, value) {
  if (typeof value === 'boolean') return value;
  var valueString = String(value).toLowerCase();

  if (TRUTHS.has(valueString)) {
    if (valueString !== 'true') {
      (0, utils_1.emitWarningOnce)("deprecated value for ".concat(name, " : ").concat(valueString, " - please update to ").concat(name, " : true instead"));
    }

    return true;
  }

  if (FALSEHOODS.has(valueString)) {
    if (valueString !== 'false') {
      (0, utils_1.emitWarningOnce)("deprecated value for ".concat(name, " : ").concat(valueString, " - please update to ").concat(name, " : false instead"));
    }

    return false;
  }

  throw new error_1.MongoParseError("Expected ".concat(name, " to be stringified boolean value, got: ").concat(value));
}

function getIntFromOptions(name, value) {
  var parsedInt = (0, utils_1.parseInteger)(value);

  if (parsedInt != null) {
    return parsedInt;
  }

  throw new error_1.MongoParseError("Expected ".concat(name, " to be stringified int value, got: ").concat(value));
}

function getUIntFromOptions(name, value) {
  var parsedValue = getIntFromOptions(name, value);

  if (parsedValue < 0) {
    throw new error_1.MongoParseError("".concat(name, " can only be a positive int value, got: ").concat(value));
  }

  return parsedValue;
}

function entriesFromString(value) {
  var keyValuePairs, _iterator, _step, keyValue, _keyValue$split3, _keyValue$split4, key, _value;

  return _regeneratorRuntime().wrap(function entriesFromString$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        keyValuePairs = value.split(',');
        _iterator = _createForOfIteratorHelper(keyValuePairs);
        _context.prev = 2;

        _iterator.s();

      case 4:
        if ((_step = _iterator.n()).done) {
          _context.next = 13;
          break;
        }

        keyValue = _step.value;
        _keyValue$split3 = keyValue.split(/:(.*)/), _keyValue$split4 = _slicedToArray(_keyValue$split3, 2), key = _keyValue$split4[0], _value = _keyValue$split4[1];

        if (!(_value == null)) {
          _context.next = 9;
          break;
        }

        throw new error_1.MongoParseError('Cannot have undefined values in key value pairs');

      case 9:
        _context.next = 11;
        return [key, _value];

      case 11:
        _context.next = 4;
        break;

      case 13:
        _context.next = 18;
        break;

      case 15:
        _context.prev = 15;
        _context.t0 = _context["catch"](2);

        _iterator.e(_context.t0);

      case 18:
        _context.prev = 18;

        _iterator.f();

        return _context.finish(18);

      case 21:
      case "end":
        return _context.stop();
    }
  }, _marked, null, [[2, 15, 18, 21]]);
}

var CaseInsensitiveMap = /*#__PURE__*/function (_Map) {
  _inherits(CaseInsensitiveMap, _Map);

  var _super = _createSuper(CaseInsensitiveMap);

  function CaseInsensitiveMap() {
    var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, CaseInsensitiveMap);

    return _super.call(this, entries.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return [k.toLowerCase(), v];
    }));
  }

  _createClass(CaseInsensitiveMap, [{
    key: "has",
    value: function has(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "has", this).call(this, k.toLowerCase());
    }
  }, {
    key: "get",
    value: function get(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "get", this).call(this, k.toLowerCase());
    }
  }, {
    key: "set",
    value: function set(k, v) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "set", this).call(this, k.toLowerCase(), v);
    }
  }, {
    key: "delete",
    value: function _delete(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "delete", this).call(this, k.toLowerCase());
    }
  }]);

  return CaseInsensitiveMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));

function parseOptions(uri) {
  var _mongoOptions$loggerF;

  var mongoClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
    options = mongoClient;
    mongoClient = undefined;
  } // validate BSONOptions


  if (options.useBigInt64 && typeof options.promoteLongs === 'boolean' && !options.promoteLongs) {
    throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
  }

  if (options.useBigInt64 && typeof options.promoteValues === 'boolean' && !options.promoteValues) {
    throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
  }

  var url = new mongodb_connection_string_url_1["default"](uri);
  var hosts = url.hosts,
      isSRV = url.isSRV;
  var mongoOptions = Object.create(null); // Feature flags

  var _iterator2 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(options)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var flag = _step2.value;

      if (exports.FEATURE_FLAGS.has(flag)) {
        mongoOptions[flag] = options[flag];
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
  var urlOptions = new CaseInsensitiveMap();

  if (url.pathname !== '/' && url.pathname !== '') {
    var dbName = decodeURIComponent(url.pathname[0] === '/' ? url.pathname.slice(1) : url.pathname);

    if (dbName) {
      urlOptions.set('dbName', [dbName]);
    }
  }

  if (url.username !== '') {
    var auth = {
      username: decodeURIComponent(url.username)
    };

    if (typeof url.password === 'string') {
      auth.password = decodeURIComponent(url.password);
    }

    urlOptions.set('auth', [auth]);
  }

  var _iterator3 = _createForOfIteratorHelper(url.searchParams.keys()),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _key = _step3.value;

      var _values = _toConsumableArray(url.searchParams.getAll(_key));

      if (_values.includes('')) {
        throw new error_1.MongoAPIError('URI cannot contain options with no value');
      }

      if (!urlOptions.has(_key)) {
        urlOptions.set(_key, _values);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        v = _ref4[1];

    return v != null;
  })); // Validate options that can only be provided by one of uri or object

  if (urlOptions.has('serverApi')) {
    throw new error_1.MongoParseError('URI cannot contain `serverApi`, it can only be passed to the client');
  }

  var uriMechanismProperties = urlOptions.get('authMechanismProperties');

  if (uriMechanismProperties) {
    var _iterator4 = _createForOfIteratorHelper(uriMechanismProperties),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var property = _step4.value;

        if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
          throw new error_1.MongoParseError('Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.');
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }

  if (objectOptions.has('loadBalanced')) {
    throw new error_1.MongoParseError('loadBalanced is only a valid option in the URI');
  } // All option collection


  var allProvidedOptions = new CaseInsensitiveMap();
  var allProvidedKeys = new Set([].concat(_toConsumableArray(urlOptions.keys()), _toConsumableArray(objectOptions.keys())));

  var _iterator5 = _createForOfIteratorHelper(allProvidedKeys),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _urlOptions$get2;

      var _key2 = _step5.value;
      var _values2 = [];
      var objectOptionValue = objectOptions.get(_key2);

      if (objectOptionValue != null) {
        _values2.push(objectOptionValue);
      }

      var urlValues = (_urlOptions$get2 = urlOptions.get(_key2)) !== null && _urlOptions$get2 !== void 0 ? _urlOptions$get2 : [];

      _values2.push.apply(_values2, _toConsumableArray(urlValues));

      allProvidedOptions.set(_key2, _values2);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (allProvidedOptions.has('tlsCertificateKeyFile') && !allProvidedOptions.has('tlsCertificateFile')) {
    allProvidedOptions.set('tlsCertificateFile', allProvidedOptions.get('tlsCertificateKeyFile'));
  }

  if (allProvidedOptions.has('tls') || allProvidedOptions.has('ssl')) {
    var tlsAndSslOpts = (allProvidedOptions.get('tls') || []).concat(allProvidedOptions.get('ssl') || []).map(getBoolean.bind(null, 'tls/ssl'));

    if (new Set(tlsAndSslOpts).size !== 1) {
      throw new error_1.MongoParseError('All values of tls/ssl must be the same.');
    }
  }

  checkTLSOptions(allProvidedOptions);
  var unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map(function (s) {
    return s.toLowerCase();
  }));

  if (unsupportedOptions.size !== 0) {
    var optionWord = unsupportedOptions.size > 1 ? 'options' : 'option';
    var isOrAre = unsupportedOptions.size > 1 ? 'are' : 'is';
    throw new error_1.MongoParseError("".concat(optionWord, " ").concat(Array.from(unsupportedOptions).join(', '), " ").concat(isOrAre, " not supported"));
  } // Option parsing and setting


  for (var _i2 = 0, _Object$entries = Object.entries(exports.OPTIONS); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i2 = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i2[0],
        descriptor = _Object$entries$_i2[1];

    var values = allProvidedOptions.get(key);

    if (!values || values.length === 0) {
      if (exports.DEFAULT_OPTIONS.has(key)) {
        setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
      }
    } else {
      var deprecated = descriptor.deprecated;

      if (deprecated) {
        var deprecatedMsg = typeof deprecated === 'string' ? ": ".concat(deprecated) : '';
        (0, utils_1.emitWarning)("".concat(key, " is a deprecated option").concat(deprecatedMsg));
      }

      setOption(mongoOptions, key, descriptor, values);
    }
  }

  if (mongoOptions.credentials) {
    var isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
    var isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
    var isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
    var isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;

    if ((isGssapi || isX509) && allProvidedOptions.has('authSource') && mongoOptions.credentials.source !== '$external') {
      // If authSource was explicitly given and its incorrect, we error
      throw new error_1.MongoParseError("authMechanism ".concat(mongoOptions.credentials.mechanism, " requires an authSource of '$external'"));
    }

    if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has('authSource')) {
      // inherit the dbName unless GSSAPI or X509, then silently ignore dbName
      // and there was no specific authSource given
      mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
        source: mongoOptions.dbName
      });
    }

    if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
      throw new error_1.MongoMissingCredentialsError("When using ".concat(mongoOptions.credentials.mechanism, " password must be set when a username is specified"));
    }

    mongoOptions.credentials.validate(); // Check if the only auth related option provided was authSource, if so we can remove credentials

    if (mongoOptions.credentials.password === '' && mongoOptions.credentials.username === '' && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
      delete mongoOptions.credentials;
    }
  }

  if (!mongoOptions.dbName) {
    // dbName default is applied here because of the credential validation above
    mongoOptions.dbName = 'test';
  }

  validateLoadBalancedOptions(hosts, mongoOptions, isSRV);

  if (mongoClient && mongoOptions.autoEncryption) {
    encrypter_1.Encrypter.checkForMongoCrypt();
    mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
    mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
  } // Potential SRV Overrides and SRV connection string validations


  mongoOptions.userSpecifiedAuthSource = objectOptions.has('authSource') || urlOptions.has('authSource');
  mongoOptions.userSpecifiedReplicaSet = objectOptions.has('replicaSet') || urlOptions.has('replicaSet');

  if (isSRV) {
    // SRV Record is resolved upon connecting
    mongoOptions.srvHost = hosts[0];

    if (mongoOptions.directConnection) {
      throw new error_1.MongoAPIError('SRV URI does not support directConnection');
    }

    if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === 'string') {
      throw new error_1.MongoParseError('Cannot use srvMaxHosts option with replicaSet');
    } // SRV turns on TLS by default, but users can override and turn it off


    var noUserSpecifiedTLS = !objectOptions.has('tls') && !urlOptions.has('tls');
    var noUserSpecifiedSSL = !objectOptions.has('ssl') && !urlOptions.has('ssl');

    if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
      mongoOptions.tls = true;
    }
  } else {
    var userSpecifiedSrvOptions = urlOptions.has('srvMaxHosts') || objectOptions.has('srvMaxHosts') || urlOptions.has('srvServiceName') || objectOptions.has('srvServiceName');

    if (userSpecifiedSrvOptions) {
      throw new error_1.MongoParseError('Cannot use srvMaxHosts or srvServiceName with a non-srv connection string');
    }
  }

  if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
    throw new error_1.MongoParseError('directConnection option requires exactly one host');
  }

  if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
    throw new error_1.MongoParseError('Must specify proxyHost if other proxy options are passed');
  }

  if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
    throw new error_1.MongoParseError('Can only specify both of proxy username/password or neither');
  }

  var proxyOptions = ['proxyHost', 'proxyPort', 'proxyUsername', 'proxyPassword'].map(function (key) {
    var _urlOptions$get;

    return (_urlOptions$get = urlOptions.get(key)) !== null && _urlOptions$get !== void 0 ? _urlOptions$get : [];
  });

  if (proxyOptions.some(function (options) {
    return options.length > 1;
  })) {
    throw new error_1.MongoParseError('Proxy options cannot be specified multiple times in the connection string');
  }

  var loggerFeatureFlag = Symbol["for"]('@@mdb.enableMongoLogger');
  mongoOptions[loggerFeatureFlag] = (_mongoOptions$loggerF = mongoOptions[loggerFeatureFlag]) !== null && _mongoOptions$loggerF !== void 0 ? _mongoOptions$loggerF : false;
  var loggerEnvOptions = {};
  var loggerClientOptions = {};

  if (mongoOptions[loggerFeatureFlag]) {
    loggerEnvOptions = _objectSpread({
      MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
      MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
      MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
      MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
      MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
      MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
      MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
    }, mongoOptions[Symbol["for"]('@@mdb.internalLoggerConfig')]);
    loggerClientOptions = {
      mongodbLogPath: mongoOptions.mongodbLogPath
    };
  }

  mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
  mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
  return mongoOptions;
}

exports.parseOptions = parseOptions;
/**
 * #### Throws if LB mode is true:
 * - hosts contains more than one host
 * - there is a replicaSet name set
 * - directConnection is set
 * - if srvMaxHosts is used when an srv connection string is passed in
 *
 * @throws MongoParseError
 */

function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
  if (mongoOptions.loadBalanced) {
    if (hosts.length > 1) {
      throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
    }

    if (mongoOptions.replicaSet) {
      throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
    }

    if (mongoOptions.directConnection) {
      throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
    }

    if (isSrv && mongoOptions.srvMaxHosts > 0) {
      throw new error_1.MongoParseError('Cannot limit srv hosts with loadBalanced enabled');
    }
  }

  return;
}

function setOption(mongoOptions, key, descriptor, values) {
  var target = descriptor.target,
      type = descriptor.type,
      transform = descriptor.transform;
  var name = target !== null && target !== void 0 ? target : key;

  switch (type) {
    case 'boolean':
      mongoOptions[name] = getBoolean(name, values[0]);
      break;

    case 'int':
      mongoOptions[name] = getIntFromOptions(name, values[0]);
      break;

    case 'uint':
      mongoOptions[name] = getUIntFromOptions(name, values[0]);
      break;

    case 'string':
      if (values[0] == null) {
        break;
      }

      mongoOptions[name] = String(values[0]);
      break;

    case 'record':
      if (!(0, utils_1.isRecord)(values[0])) {
        throw new error_1.MongoParseError("".concat(name, " must be an object"));
      }

      mongoOptions[name] = values[0];
      break;

    case 'any':
      mongoOptions[name] = values[0];
      break;

    default:
      {
        if (!transform) {
          throw new error_1.MongoParseError('Descriptors missing a type must define a transform');
        }

        var transformValue = transform({
          name: name,
          options: mongoOptions,
          values: values
        });
        mongoOptions[name] = transformValue;
        break;
      }
  }
}

exports.OPTIONS = {
  appName: {
    type: 'string'
  },
  auth: {
    target: 'credentials',
    transform: function transform(_ref5) {
      var name = _ref5.name,
          options = _ref5.options,
          _ref5$values = _slicedToArray(_ref5.values, 1),
          value = _ref5$values[0];

      if (!(0, utils_1.isRecord)(value, ['username', 'password'])) {
        throw new error_1.MongoParseError("".concat(name, " must be an object with 'username' and 'password' properties"));
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        username: value.username,
        password: value.password
      });
    }
  },
  authMechanism: {
    target: 'credentials',
    transform: function transform(_ref6) {
      var _options$credentials, _options$credentials2;

      var options = _ref6.options,
          _ref6$values = _slicedToArray(_ref6.values, 1),
          value = _ref6$values[0];

      var mechanisms = Object.values(providers_1.AuthMechanism);

      var _mechanisms$filter = mechanisms.filter(function (m) {
        return m.match(RegExp(String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral(["\b", "\b"], ["\\b", "\\b"])), value), 'i'));
      }),
          _mechanisms$filter2 = _slicedToArray(_mechanisms$filter, 1),
          mechanism = _mechanisms$filter2[0];

      if (!mechanism) {
        throw new error_1.MongoParseError("authMechanism one of ".concat(mechanisms, ", got ").concat(value));
      }

      var source = (_options$credentials = options.credentials) === null || _options$credentials === void 0 ? void 0 : _options$credentials.source;

      if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
        // some mechanisms have '$external' as the Auth Source
        source = '$external';
      }

      var password = (_options$credentials2 = options.credentials) === null || _options$credentials2 === void 0 ? void 0 : _options$credentials2.password;

      if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === '') {
        password = undefined;
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        mechanism: mechanism,
        source: source,
        password: password
      });
    }
  },
  authMechanismProperties: {
    target: 'credentials',
    transform: function transform(_ref7) {
      var options = _ref7.options,
          values = _ref7.values;
      // We can have a combination of options passed in the URI and options passed
      // as an object to the MongoClient. So we must transform the string options
      // as well as merge them together with a potentially provided object.
      var mechanismProperties = Object.create(null);

      var _iterator6 = _createForOfIteratorHelper(values),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var optionValue = _step6.value;

          if (typeof optionValue === 'string') {
            var _iterator7 = _createForOfIteratorHelper(entriesFromString(optionValue)),
                _step7;

            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _step7$value2 = _slicedToArray(_step7.value, 2),
                    key = _step7$value2[0],
                    value = _step7$value2[1];

                try {
                  mechanismProperties[key] = getBoolean(key, value);
                } catch (_unused) {
                  mechanismProperties[key] = value;
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          } else {
            if (!(0, utils_1.isRecord)(optionValue)) {
              throw new error_1.MongoParseError('AuthMechanismProperties must be an object');
            }

            mechanismProperties = _objectSpread({}, optionValue);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        mechanismProperties: mechanismProperties
      });
    }
  },
  authSource: {
    target: 'credentials',
    transform: function transform(_ref8) {
      var options = _ref8.options,
          _ref8$values = _slicedToArray(_ref8.values, 1),
          value = _ref8$values[0];

      var source = String(value);
      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        source: source
      });
    }
  },
  autoEncryption: {
    type: 'record'
  },
  bsonRegExp: {
    type: 'boolean'
  },
  serverApi: {
    target: 'serverApi',
    transform: function transform(_ref9) {
      var _ref9$values = _slicedToArray(_ref9.values, 1),
          version = _ref9$values[0];

      var serverApiToValidate = typeof version === 'string' ? {
        version: version
      } : version;
      var versionToValidate = serverApiToValidate && serverApiToValidate.version;

      if (!versionToValidate) {
        throw new error_1.MongoParseError("Invalid `serverApi` property; must specify a version from the following enum: [\"".concat(Object.values(mongo_client_1.ServerApiVersion).join('", "'), "\"]"));
      }

      if (!Object.values(mongo_client_1.ServerApiVersion).some(function (v) {
        return v === versionToValidate;
      })) {
        throw new error_1.MongoParseError("Invalid server API version=".concat(versionToValidate, "; must be in the following enum: [\"").concat(Object.values(mongo_client_1.ServerApiVersion).join('", "'), "\"]"));
      }

      return serverApiToValidate;
    }
  },
  checkKeys: {
    type: 'boolean'
  },
  compressors: {
    "default": 'none',
    target: 'compressors',
    transform: function transform(_ref10) {
      var values = _ref10.values;
      var compressionList = new Set();

      var _iterator8 = _createForOfIteratorHelper(values),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var compVal = _step8.value;
          var compValArray = typeof compVal === 'string' ? compVal.split(',') : compVal;

          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError('compressors must be an array or a comma-delimited list of strings');
          }

          var _iterator9 = _createForOfIteratorHelper(compValArray),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var c = _step9.value;

              if (Object.keys(compression_1.Compressor).includes(String(c))) {
                compressionList.add(String(c));
              } else {
                throw new error_1.MongoInvalidArgumentError("".concat(c, " is not a valid compression mechanism. Must be one of: ").concat(Object.keys(compression_1.Compressor), "."));
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return _toConsumableArray(compressionList);
    }
  },
  connectTimeoutMS: {
    "default": 30000,
    type: 'uint'
  },
  dbName: {
    type: 'string'
  },
  directConnection: {
    "default": false,
    type: 'boolean'
  },
  driverInfo: {
    "default": {},
    type: 'record'
  },
  enableUtf8Validation: {
    type: 'boolean',
    "default": true
  },
  family: {
    transform: function transform(_ref11) {
      var name = _ref11.name,
          _ref11$values = _slicedToArray(_ref11.values, 1),
          value = _ref11$values[0];

      var transformValue = getIntFromOptions(name, value);

      if (transformValue === 4 || transformValue === 6) {
        return transformValue;
      }

      throw new error_1.MongoParseError("Option 'family' must be 4 or 6 got ".concat(transformValue, "."));
    }
  },
  fieldsAsRaw: {
    type: 'record'
  },
  forceServerObjectId: {
    "default": false,
    type: 'boolean'
  },
  fsync: {
    deprecated: 'Please use journal instead',
    target: 'writeConcern',
    transform: function transform(_ref12) {
      var name = _ref12.name,
          options = _ref12.options,
          _ref12$values = _slicedToArray(_ref12.values, 1),
          value = _ref12$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          fsync: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from fsync=".concat(value));
      return wc;
    }
  },
  heartbeatFrequencyMS: {
    "default": 10000,
    type: 'uint'
  },
  ignoreUndefined: {
    type: 'boolean'
  },
  j: {
    deprecated: 'Please use journal instead',
    target: 'writeConcern',
    transform: function transform(_ref13) {
      var name = _ref13.name,
          options = _ref13.options,
          _ref13$values = _slicedToArray(_ref13.values, 1),
          value = _ref13$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          journal: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from journal=".concat(value));
      return wc;
    }
  },
  journal: {
    target: 'writeConcern',
    transform: function transform(_ref14) {
      var name = _ref14.name,
          options = _ref14.options,
          _ref14$values = _slicedToArray(_ref14.values, 1),
          value = _ref14$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          journal: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from journal=".concat(value));
      return wc;
    }
  },
  keepAlive: {
    "default": true,
    type: 'boolean',
    deprecated: 'Will not be able to turn off in the future.'
  },
  keepAliveInitialDelay: {
    "default": 120000,
    type: 'uint',
    deprecated: 'Will not be configurable in the future.'
  },
  loadBalanced: {
    "default": false,
    type: 'boolean'
  },
  localThresholdMS: {
    "default": 15,
    type: 'uint'
  },
  maxConnecting: {
    "default": 2,
    transform: function transform(_ref15) {
      var name = _ref15.name,
          _ref15$values = _slicedToArray(_ref15.values, 1),
          value = _ref15$values[0];

      var maxConnecting = getUIntFromOptions(name, value);

      if (maxConnecting === 0) {
        throw new error_1.MongoInvalidArgumentError('maxConnecting must be > 0 if specified');
      }

      return maxConnecting;
    }
  },
  maxIdleTimeMS: {
    "default": 0,
    type: 'uint'
  },
  maxPoolSize: {
    "default": 100,
    type: 'uint'
  },
  maxStalenessSeconds: {
    target: 'readPreference',
    transform: function transform(_ref16) {
      var name = _ref16.name,
          options = _ref16.options,
          _ref16$values = _slicedToArray(_ref16.values, 1),
          value = _ref16$values[0];

      var maxStalenessSeconds = getUIntFromOptions(name, value);

      if (options.readPreference) {
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), {}, {
            maxStalenessSeconds: maxStalenessSeconds
          })
        });
      } else {
        return new read_preference_1.ReadPreference('secondary', undefined, {
          maxStalenessSeconds: maxStalenessSeconds
        });
      }
    }
  },
  minInternalBufferSize: {
    type: 'uint'
  },
  minPoolSize: {
    "default": 0,
    type: 'uint'
  },
  minHeartbeatFrequencyMS: {
    "default": 500,
    type: 'uint'
  },
  monitorCommands: {
    "default": false,
    type: 'boolean'
  },
  name: {
    target: 'driverInfo',
    transform: function transform(_ref17) {
      var _ref17$values = _slicedToArray(_ref17.values, 1),
          value = _ref17$values[0],
          options = _ref17.options;

      return _objectSpread(_objectSpread({}, options.driverInfo), {}, {
        name: String(value)
      });
    }
  },
  noDelay: {
    "default": true,
    type: 'boolean'
  },
  pkFactory: {
    "default": utils_1.DEFAULT_PK_FACTORY,
    transform: function transform(_ref18) {
      var _ref18$values = _slicedToArray(_ref18.values, 1),
          value = _ref18$values[0];

      if ((0, utils_1.isRecord)(value, ['createPk']) && typeof value.createPk === 'function') {
        return value;
      }

      throw new error_1.MongoParseError("Option pkFactory must be an object with a createPk function, got ".concat(value));
    }
  },
  promoteBuffers: {
    type: 'boolean'
  },
  promoteLongs: {
    type: 'boolean'
  },
  promoteValues: {
    type: 'boolean'
  },
  useBigInt64: {
    type: 'boolean'
  },
  proxyHost: {
    type: 'string'
  },
  proxyPassword: {
    type: 'string'
  },
  proxyPort: {
    type: 'uint'
  },
  proxyUsername: {
    type: 'string'
  },
  raw: {
    "default": false,
    type: 'boolean'
  },
  readConcern: {
    transform: function transform(_ref19) {
      var _ref19$values = _slicedToArray(_ref19.values, 1),
          value = _ref19$values[0],
          options = _ref19.options;

      if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ['level'])) {
        return read_concern_1.ReadConcern.fromOptions(_objectSpread(_objectSpread({}, options.readConcern), value));
      }

      throw new error_1.MongoParseError("ReadConcern must be an object, got ".concat(JSON.stringify(value)));
    }
  },
  readConcernLevel: {
    target: 'readConcern',
    transform: function transform(_ref20) {
      var _ref20$values = _slicedToArray(_ref20.values, 1),
          level = _ref20$values[0],
          options = _ref20.options;

      return read_concern_1.ReadConcern.fromOptions(_objectSpread(_objectSpread({}, options.readConcern), {}, {
        level: level
      }));
    }
  },
  readPreference: {
    "default": read_preference_1.ReadPreference.primary,
    transform: function transform(_ref21) {
      var _ref21$values = _slicedToArray(_ref21.values, 1),
          value = _ref21$values[0],
          options = _ref21.options;

      if (value instanceof read_preference_1.ReadPreference) {
        return read_preference_1.ReadPreference.fromOptions(_objectSpread({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), value)
        }, value));
      }

      if ((0, utils_1.isRecord)(value, ['mode'])) {
        var rp = read_preference_1.ReadPreference.fromOptions(_objectSpread({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), value)
        }, value));
        if (rp) return rp;else throw new error_1.MongoParseError("Cannot make read preference from ".concat(JSON.stringify(value)));
      }

      if (typeof value === 'string') {
        var _options$readPreferen, _options$readPreferen2, _options$readPreferen3;

        var rpOpts = {
          hedge: (_options$readPreferen = options.readPreference) === null || _options$readPreferen === void 0 ? void 0 : _options$readPreferen.hedge,
          maxStalenessSeconds: (_options$readPreferen2 = options.readPreference) === null || _options$readPreferen2 === void 0 ? void 0 : _options$readPreferen2.maxStalenessSeconds
        };
        return new read_preference_1.ReadPreference(value, (_options$readPreferen3 = options.readPreference) === null || _options$readPreferen3 === void 0 ? void 0 : _options$readPreferen3.tags, rpOpts);
      }

      throw new error_1.MongoParseError("Unknown ReadPreference value: ".concat(value));
    }
  },
  readPreferenceTags: {
    target: 'readPreference',
    transform: function transform(_ref22) {
      var values = _ref22.values,
          options = _ref22.options;
      var tags = Array.isArray(values[0]) ? values[0] : values;
      var readPreferenceTags = [];

      var _iterator10 = _createForOfIteratorHelper(tags),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var tag = _step10.value;
          var readPreferenceTag = Object.create(null);

          if (typeof tag === 'string') {
            var _iterator11 = _createForOfIteratorHelper(entriesFromString(tag)),
                _step11;

            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var _step11$value2 = _slicedToArray(_step11.value, 2),
                    k = _step11$value2[0],
                    v = _step11$value2[1];

                readPreferenceTag[k] = v;
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
          }

          if ((0, utils_1.isRecord)(tag)) {
            for (var _i3 = 0, _Object$entries2 = Object.entries(tag); _i3 < _Object$entries2.length; _i3++) {
              var _Object$entries2$_i2 = _slicedToArray(_Object$entries2[_i3], 2),
                  _k = _Object$entries2$_i2[0],
                  _v = _Object$entries2$_i2[1];

              readPreferenceTag[_k] = _v;
            }
          }

          readPreferenceTags.push(readPreferenceTag);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return read_preference_1.ReadPreference.fromOptions({
        readPreference: options.readPreference,
        readPreferenceTags: readPreferenceTags
      });
    }
  },
  replicaSet: {
    type: 'string'
  },
  retryReads: {
    "default": true,
    type: 'boolean'
  },
  retryWrites: {
    "default": true,
    type: 'boolean'
  },
  serializeFunctions: {
    type: 'boolean'
  },
  serverSelectionTimeoutMS: {
    "default": 30000,
    type: 'uint'
  },
  servername: {
    type: 'string'
  },
  socketTimeoutMS: {
    "default": 0,
    type: 'uint'
  },
  srvMaxHosts: {
    type: 'uint',
    "default": 0
  },
  srvServiceName: {
    type: 'string',
    "default": 'mongodb'
  },
  ssl: {
    target: 'tls',
    type: 'boolean'
  },
  sslCA: {
    deprecated: 'sslCA is deprecated and will be removed in the next major version. Please use tlsCAFile instead.',
    target: 'ca',
    transform: function transform(_ref23) {
      var _ref23$values = _slicedToArray(_ref23.values, 1),
          value = _ref23$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslCRL: {
    deprecated: 'sslCRL is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.',
    target: 'crl',
    transform: function transform(_ref24) {
      var _ref24$values = _slicedToArray(_ref24.values, 1),
          value = _ref24$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslCert: {
    deprecated: 'sslCert is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.',
    target: 'cert',
    transform: function transform(_ref25) {
      var _ref25$values = _slicedToArray(_ref25.values, 1),
          value = _ref25$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslKey: {
    deprecated: 'sslKey is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.',
    target: 'key',
    transform: function transform(_ref26) {
      var _ref26$values = _slicedToArray(_ref26.values, 1),
          value = _ref26$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslPass: {
    deprecated: 'sslPass is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFilePassword instead.',
    target: 'passphrase',
    type: 'string'
  },
  sslValidate: {
    deprecated: 'sslValidate is deprecated and will be removed in the next major version. Please use tlsAllowInvalidCertificates instead.',
    target: 'rejectUnauthorized',
    type: 'boolean'
  },
  tls: {
    type: 'boolean'
  },
  tlsAllowInvalidCertificates: {
    target: 'rejectUnauthorized',
    transform: function transform(_ref27) {
      var name = _ref27.name,
          _ref27$values = _slicedToArray(_ref27.values, 1),
          value = _ref27$values[0];

      // allowInvalidCertificates is the inverse of rejectUnauthorized
      return !getBoolean(name, value);
    }
  },
  tlsAllowInvalidHostnames: {
    target: 'checkServerIdentity',
    transform: function transform(_ref28) {
      var name = _ref28.name,
          _ref28$values = _slicedToArray(_ref28.values, 1),
          value = _ref28$values[0];

      // tlsAllowInvalidHostnames means setting the checkServerIdentity function to a noop
      return getBoolean(name, value) ? function () {
        return undefined;
      } : undefined;
    }
  },
  tlsCAFile: {
    target: 'ca',
    transform: function transform(_ref29) {
      var _ref29$values = _slicedToArray(_ref29.values, 1),
          value = _ref29$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateFile: {
    deprecated: 'tlsCertificateFile is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.',
    target: 'cert',
    transform: function transform(_ref30) {
      var _ref30$values = _slicedToArray(_ref30.values, 1),
          value = _ref30$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateKeyFile: {
    target: 'key',
    transform: function transform(_ref31) {
      var _ref31$values = _slicedToArray(_ref31.values, 1),
          value = _ref31$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateKeyFilePassword: {
    target: 'passphrase',
    type: 'any'
  },
  tlsInsecure: {
    transform: function transform(_ref32) {
      var name = _ref32.name,
          options = _ref32.options,
          _ref32$values = _slicedToArray(_ref32.values, 1),
          value = _ref32$values[0];

      var tlsInsecure = getBoolean(name, value);

      if (tlsInsecure) {
        options.checkServerIdentity = function () {
          return undefined;
        };

        options.rejectUnauthorized = false;
      } else {
        options.checkServerIdentity = options.tlsAllowInvalidHostnames ? function () {
          return undefined;
        } : undefined;
        options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
      }

      return tlsInsecure;
    }
  },
  w: {
    target: 'writeConcern',
    transform: function transform(_ref33) {
      var _ref33$values = _slicedToArray(_ref33.values, 1),
          value = _ref33$values[0],
          options = _ref33.options;

      return write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          w: value
        })
      });
    }
  },
  waitQueueTimeoutMS: {
    "default": 0,
    type: 'uint'
  },
  writeConcern: {
    target: 'writeConcern',
    transform: function transform(_ref34) {
      var _ref34$values = _slicedToArray(_ref34.values, 1),
          value = _ref34$values[0],
          options = _ref34.options;

      if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
        return write_concern_1.WriteConcern.fromOptions({
          writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), value)
        });
      } else if (value === 'majority' || typeof value === 'number') {
        return write_concern_1.WriteConcern.fromOptions({
          writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
            w: value
          })
        });
      }

      throw new error_1.MongoParseError("Invalid WriteConcern cannot parse: ".concat(JSON.stringify(value)));
    }
  },
  wtimeout: {
    deprecated: 'Please use wtimeoutMS instead',
    target: 'writeConcern',
    transform: function transform(_ref35) {
      var _ref35$values = _slicedToArray(_ref35.values, 1),
          value = _ref35$values[0],
          options = _ref35.options;

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          wtimeout: getUIntFromOptions('wtimeout', value)
        })
      });
      if (wc) return wc;
      throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
    }
  },
  wtimeoutMS: {
    target: 'writeConcern',
    transform: function transform(_ref36) {
      var _ref36$values = _slicedToArray(_ref36.values, 1),
          value = _ref36$values[0],
          options = _ref36.options;

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          wtimeoutMS: getUIntFromOptions('wtimeoutMS', value)
        })
      });
      if (wc) return wc;
      throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
    }
  },
  zlibCompressionLevel: {
    "default": 0,
    type: 'int'
  },
  // Custom types for modifying core behavior
  connectionType: {
    type: 'any'
  },
  srvPoller: {
    type: 'any'
  },
  // Accepted NodeJS Options
  minDHSize: {
    type: 'any'
  },
  pskCallback: {
    type: 'any'
  },
  secureContext: {
    type: 'any'
  },
  enableTrace: {
    type: 'any'
  },
  requestCert: {
    type: 'any'
  },
  rejectUnauthorized: {
    type: 'any'
  },
  checkServerIdentity: {
    type: 'any'
  },
  ALPNProtocols: {
    type: 'any'
  },
  SNICallback: {
    type: 'any'
  },
  session: {
    type: 'any'
  },
  requestOCSP: {
    type: 'any'
  },
  localAddress: {
    type: 'any'
  },
  localPort: {
    type: 'any'
  },
  hints: {
    type: 'any'
  },
  lookup: {
    type: 'any'
  },
  ca: {
    type: 'any'
  },
  cert: {
    type: 'any'
  },
  ciphers: {
    type: 'any'
  },
  crl: {
    type: 'any'
  },
  ecdhCurve: {
    type: 'any'
  },
  key: {
    type: 'any'
  },
  passphrase: {
    type: 'any'
  },
  pfx: {
    type: 'any'
  },
  secureProtocol: {
    type: 'any'
  },
  index: {
    type: 'any'
  },
  // Legacy Options, these are unused but left here to avoid errors with CSFLE lib
  useNewUrlParser: {
    type: 'boolean'
  },
  useUnifiedTopology: {
    type: 'boolean'
  },
  // MongoLogger
  // TODO(NODE-4849): Tighten the type of mongodbLogPath
  mongodbLogPath: {
    type: 'any'
  }
};
exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(function (_ref37) {
  var _ref38 = _slicedToArray(_ref37, 2),
      descriptor = _ref38[1];

  return descriptor["default"] != null;
}).map(function (_ref39) {
  var _ref40 = _slicedToArray(_ref39, 2),
      k = _ref40[0],
      d = _ref40[1];

  return [k, d["default"]];
}));
/**
 * Set of permitted feature flags
 * @internal
 */

exports.FEATURE_FLAGS = new Set([Symbol["for"]('@@mdb.skipPingOnConnect'), Symbol["for"]('@@mdb.enableMongoLogger'), Symbol["for"]('@@mdb.internalLoggerConfig')]);

/***/ }),

/***/ 9592:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = void 0;
exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = void 0;
exports.SYSTEM_NAMESPACE_COLLECTION = 'system.namespaces';
exports.SYSTEM_INDEX_COLLECTION = 'system.indexes';
exports.SYSTEM_PROFILE_COLLECTION = 'system.profile';
exports.SYSTEM_USER_COLLECTION = 'system.users';
exports.SYSTEM_COMMAND_COLLECTION = '$cmd';
exports.SYSTEM_JS_COLLECTION = 'system.js'; // events

exports.ERROR = 'error';
exports.TIMEOUT = 'timeout';
exports.CLOSE = 'close';
exports.OPEN = 'open';
exports.CONNECT = 'connect';
exports.CLOSED = 'closed';
exports.ENDED = 'ended';
exports.MESSAGE = 'message';
exports.PINNED = 'pinned';
exports.UNPINNED = 'unpinned';
exports.DESCRIPTION_RECEIVED = 'descriptionReceived';
exports.SERVER_OPENING = 'serverOpening';
exports.SERVER_CLOSED = 'serverClosed';
exports.SERVER_DESCRIPTION_CHANGED = 'serverDescriptionChanged';
exports.TOPOLOGY_OPENING = 'topologyOpening';
exports.TOPOLOGY_CLOSED = 'topologyClosed';
exports.TOPOLOGY_DESCRIPTION_CHANGED = 'topologyDescriptionChanged';
/** @internal */

exports.CONNECTION_POOL_CREATED = 'connectionPoolCreated';
/** @internal */

exports.CONNECTION_POOL_CLOSED = 'connectionPoolClosed';
/** @internal */

exports.CONNECTION_POOL_CLEARED = 'connectionPoolCleared';
/** @internal */

exports.CONNECTION_POOL_READY = 'connectionPoolReady';
/** @internal */

exports.CONNECTION_CREATED = 'connectionCreated';
/** @internal */

exports.CONNECTION_READY = 'connectionReady';
/** @internal */

exports.CONNECTION_CLOSED = 'connectionClosed';
/** @internal */

exports.CONNECTION_CHECK_OUT_STARTED = 'connectionCheckOutStarted';
/** @internal */

exports.CONNECTION_CHECK_OUT_FAILED = 'connectionCheckOutFailed';
/** @internal */

exports.CONNECTION_CHECKED_OUT = 'connectionCheckedOut';
/** @internal */

exports.CONNECTION_CHECKED_IN = 'connectionCheckedIn';
exports.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';
exports.COMMAND_STARTED = 'commandStarted';
exports.COMMAND_SUCCEEDED = 'commandSucceeded';
exports.COMMAND_FAILED = 'commandFailed';
exports.SERVER_HEARTBEAT_STARTED = 'serverHeartbeatStarted';
exports.SERVER_HEARTBEAT_SUCCEEDED = 'serverHeartbeatSucceeded';
exports.SERVER_HEARTBEAT_FAILED = 'serverHeartbeatFailed';
exports.RESPONSE = 'response';
exports.MORE = 'more';
exports.INIT = 'init';
exports.CHANGE = 'change';
exports.END = 'end';
exports.RESUME_TOKEN_CHANGED = 'resumeTokenChanged';
/** @public */

exports.HEARTBEAT_EVENTS = Object.freeze([exports.SERVER_HEARTBEAT_STARTED, exports.SERVER_HEARTBEAT_SUCCEEDED, exports.SERVER_HEARTBEAT_FAILED]);
/** @public */

exports.CMAP_EVENTS = Object.freeze([exports.CONNECTION_POOL_CREATED, exports.CONNECTION_POOL_READY, exports.CONNECTION_POOL_CLEARED, exports.CONNECTION_POOL_CLOSED, exports.CONNECTION_CREATED, exports.CONNECTION_READY, exports.CONNECTION_CLOSED, exports.CONNECTION_CHECK_OUT_STARTED, exports.CONNECTION_CHECK_OUT_FAILED, exports.CONNECTION_CHECKED_OUT, exports.CONNECTION_CHECKED_IN]);
/** @public */

exports.TOPOLOGY_EVENTS = Object.freeze([exports.SERVER_OPENING, exports.SERVER_CLOSED, exports.SERVER_DESCRIPTION_CHANGED, exports.TOPOLOGY_OPENING, exports.TOPOLOGY_CLOSED, exports.TOPOLOGY_DESCRIPTION_CHANGED, exports.ERROR, exports.TIMEOUT, exports.CLOSE]);
/** @public */

exports.APM_EVENTS = Object.freeze([exports.COMMAND_STARTED, exports.COMMAND_SUCCEEDED, exports.COMMAND_FAILED]);
/**
 * All events that we relay to the `Topology`
 * @internal
 */

exports.SERVER_RELAY_EVENTS = Object.freeze([exports.SERVER_HEARTBEAT_STARTED, exports.SERVER_HEARTBEAT_SUCCEEDED, exports.SERVER_HEARTBEAT_FAILED, exports.COMMAND_STARTED, exports.COMMAND_SUCCEEDED, exports.COMMAND_FAILED].concat(_toConsumableArray(exports.CMAP_EVENTS)));
/**
 * All events we listen to from `Server` instances, but do not forward to the client
 * @internal
 */

exports.LOCAL_SERVER_EVENTS = Object.freeze([exports.CONNECT, exports.DESCRIPTION_RECEIVED, exports.CLOSED, exports.ENDED]);
/** @public */

exports.MONGO_CLIENT_EVENTS = Object.freeze([].concat(_toConsumableArray(exports.CMAP_EVENTS), _toConsumableArray(exports.APM_EVENTS), _toConsumableArray(exports.TOPOLOGY_EVENTS), _toConsumableArray(exports.HEARTBEAT_EVENTS)));
/**
 * @internal
 * The legacy hello command that was deprecated in MongoDB 5.0.
 */

exports.LEGACY_HELLO_COMMAND = 'ismaster';
/**
 * @internal
 * The legacy hello command that was deprecated in MongoDB 5.0.
 */

exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = 'isMaster';

/***/ }),

/***/ 9800:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }

function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen["return"] !== "function") { this["return"] = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;

var stream_1 = __webpack_require__(2781);

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var execute_operation_1 = __webpack_require__(5756);

var get_more_1 = __webpack_require__(4275);

var kill_cursors_1 = __webpack_require__(7165);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var sessions_1 = __webpack_require__(2516);

var utils_1 = __webpack_require__(672);
/** @internal */


var kId = Symbol('id');
/** @internal */

var kDocuments = Symbol('documents');
/** @internal */

var kServer = Symbol('server');
/** @internal */

var kNamespace = Symbol('namespace');
/** @internal */

var kClient = Symbol('client');
/** @internal */

var kSession = Symbol('session');
/** @internal */

var kOptions = Symbol('options');
/** @internal */

var kTransform = Symbol('transform');
/** @internal */

var kInitialized = Symbol('initialized');
/** @internal */

var kClosed = Symbol('closed');
/** @internal */

var kKilled = Symbol('killed');
/** @internal */

var kInit = Symbol('kInit');
/** @public */

exports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
/** @public */

var AbstractCursor = /*#__PURE__*/function (_mongo_types_1$TypedE, _Symbol$asyncIterator) {
  _inherits(AbstractCursor, _mongo_types_1$TypedE);

  var _super = _createSuper(AbstractCursor);

  /** @internal */
  function AbstractCursor(client, namespace) {
    var _this2;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, AbstractCursor);

    _this2 = _super.call(this);

    if (!client.s.isMongoClient) {
      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');
    }

    _this2[kClient] = client;
    _this2[kNamespace] = namespace;
    _this2[kId] = null;
    _this2[kDocuments] = new utils_1.List();
    _this2[kInitialized] = false;
    _this2[kClosed] = false;
    _this2[kKilled] = false;
    _this2[kOptions] = _objectSpread({
      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary
    }, (0, bson_1.pluckBSONSerializeOptions)(options));
    var readConcern = read_concern_1.ReadConcern.fromOptions(options);

    if (readConcern) {
      _this2[kOptions].readConcern = readConcern;
    }

    if (typeof options.batchSize === 'number') {
      _this2[kOptions].batchSize = options.batchSize;
    } // we check for undefined specifically here to allow falsy values
    // eslint-disable-next-line no-restricted-syntax


    if (options.comment !== undefined) {
      _this2[kOptions].comment = options.comment;
    }

    if (typeof options.maxTimeMS === 'number') {
      _this2[kOptions].maxTimeMS = options.maxTimeMS;
    }

    if (typeof options.maxAwaitTimeMS === 'number') {
      _this2[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;
    }

    if (options.session instanceof sessions_1.ClientSession) {
      _this2[kSession] = options.session;
    } else {
      _this2[kSession] = _this2[kClient].startSession({
        owner: _assertThisInitialized(_this2),
        explicit: false
      });
    }

    return _this2;
  }

  _createClass(AbstractCursor, [{
    key: "id",
    get: function get() {
      var _this$kId;

      return (_this$kId = this[kId]) !== null && _this$kId !== void 0 ? _this$kId : undefined;
    }
    /** @internal */

  }, {
    key: "client",
    get: function get() {
      return this[kClient];
    }
    /** @internal */

  }, {
    key: "server",
    get: function get() {
      return this[kServer];
    }
  }, {
    key: "namespace",
    get: function get() {
      return this[kNamespace];
    }
  }, {
    key: "readPreference",
    get: function get() {
      return this[kOptions].readPreference;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this[kOptions].readConcern;
    }
    /** @internal */

  }, {
    key: "session",
    get: function get() {
      return this[kSession];
    },
    set: function set(clientSession) {
      this[kSession] = clientSession;
    }
    /** @internal */

  }, {
    key: "cursorOptions",
    get: function get() {
      return this[kOptions];
    }
  }, {
    key: "closed",
    get: function get() {
      return this[kClosed];
    }
  }, {
    key: "killed",
    get: function get() {
      return this[kKilled];
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      var _this$kClient$topolog;

      return !!((_this$kClient$topolog = this[kClient].topology) !== null && _this$kClient$topolog !== void 0 && _this$kClient$topolog.loadBalanced);
    }
    /** Returns current buffered documents length */

  }, {
    key: "bufferedCount",
    value: function bufferedCount() {
      return this[kDocuments].length;
    }
    /** Returns current buffered documents */

  }, {
    key: "readBufferedDocuments",
    value: function readBufferedDocuments(number) {
      var bufferedDocs = [];
      var documentsToRead = Math.min(number !== null && number !== void 0 ? number : this[kDocuments].length, this[kDocuments].length);

      for (var count = 0; count < documentsToRead; count++) {
        var document = this[kDocuments].shift();

        if (document != null) {
          bufferedDocs.push(document);
        }
      }

      return bufferedDocs;
    }
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      var _this = this;

      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var document, message;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!_this.closed) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.prev = 2;

            case 3:
              if (false) {}

              _context.next = 6;
              return _awaitAsyncGenerator(_this.next());

            case 6:
              document = _context.sent;

              if (!(document === null)) {
                _context.next = 14;
                break;
              }

              if (_this.closed) {
                _context.next = 13;
                break;
              }

              message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';
              _context.next = 12;
              return _awaitAsyncGenerator(cleanupCursorAsync(_this, {
                needsToEmitClosed: true
              })["catch"](function () {
                return null;
              }));

            case 12:
              throw new error_1.MongoAPIError(message);

            case 13:
              return _context.abrupt("break", 20);

            case 14:
              _context.next = 16;
              return document;

            case 16:
              if (!(_this[kId] === bson_1.Long.ZERO)) {
                _context.next = 18;
                break;
              }

              return _context.abrupt("break", 20);

            case 18:
              _context.next = 3;
              break;

            case 20:
              _context.prev = 20;

              if (_this.closed) {
                _context.next = 24;
                break;
              }

              _context.next = 24;
              return _awaitAsyncGenerator(_this.close()["catch"](function () {
                return null;
              }));

            case 24:
              return _context.finish(20);

            case 25:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2,, 20, 25]]);
      }))();
    }
  }, {
    key: "stream",
    value: function stream(options) {
      if (options !== null && options !== void 0 && options.transform) {
        var _transform = options.transform;
        var readable = new ReadableCursorStream(this);
        return readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform: function transform(chunk, _, callback) {
            try {
              var transformed = _transform(chunk);

              callback(undefined, transformed);
            } catch (err) {
              callback(err);
            }
          }
        }));
      }

      return new ReadableCursorStream(this);
    }
  }, {
    key: "hasNext",
    value: function () {
      var _hasNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var doc;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this[kId] === bson_1.Long.ZERO)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", false);

            case 2:
              if (!(this[kDocuments].length !== 0)) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", true);

            case 4:
              _context2.next = 6;
              return _next(this, {
                blocking: true,
                transform: false
              });

            case 6:
              doc = _context2.sent;

              if (!doc) {
                _context2.next = 10;
                break;
              }

              this[kDocuments].unshift(doc);
              return _context2.abrupt("return", true);

            case 10:
              return _context2.abrupt("return", false);

            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function hasNext() {
        return _hasNext.apply(this, arguments);
      }

      return hasNext;
    }()
    /** Get the next available document from the cursor, returns null if no more documents are available. */

  }, {
    key: "next",
    value: function () {
      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this[kId] === bson_1.Long.ZERO)) {
                _context3.next = 2;
                break;
              }

              throw new error_1.MongoCursorExhaustedError();

            case 2:
              return _context3.abrupt("return", _next(this, {
                blocking: true,
                transform: true
              }));

            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function next() {
        return _next2.apply(this, arguments);
      }

      return next;
    }()
    /**
     * Try to get the next available document from the cursor or `null` if an empty batch is returned
     */

  }, {
    key: "tryNext",
    value: function () {
      var _tryNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(this[kId] === bson_1.Long.ZERO)) {
                _context4.next = 2;
                break;
              }

              throw new error_1.MongoCursorExhaustedError();

            case 2:
              return _context4.abrupt("return", _next(this, {
                blocking: false,
                transform: true
              }));

            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function tryNext() {
        return _tryNext.apply(this, arguments);
      }

      return tryNext;
    }()
    /**
     * Iterates over all the documents for this cursor using the iterator, callback pattern.
     *
     * If the iterator returns `false`, iteration will stop.
     *
     * @param iterator - The iteration callback.
     * @deprecated - Will be removed in a future release. Use for await...of instead.
     */

  }, {
    key: "forEach",
    value: function () {
      var _forEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(iterator) {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, document, result;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(typeof iterator !== 'function')) {
                _context5.next = 2;
                break;
              }

              throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');

            case 2:
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context5.prev = 4;
              _iterator = _asyncIterator(this);

            case 6:
              _context5.next = 8;
              return _iterator.next();

            case 8:
              if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {
                _context5.next = 16;
                break;
              }

              document = _step.value;
              result = iterator(document);

              if (!(result === false)) {
                _context5.next = 13;
                break;
              }

              return _context5.abrupt("break", 16);

            case 13:
              _iteratorAbruptCompletion = false;
              _context5.next = 6;
              break;

            case 16:
              _context5.next = 22;
              break;

            case 18:
              _context5.prev = 18;
              _context5.t0 = _context5["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context5.t0;

            case 22:
              _context5.prev = 22;
              _context5.prev = 23;

              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context5.next = 27;
                break;
              }

              _context5.next = 27;
              return _iterator["return"]();

            case 27:
              _context5.prev = 27;

              if (!_didIteratorError) {
                _context5.next = 30;
                break;
              }

              throw _iteratorError;

            case 30:
              return _context5.finish(27);

            case 31:
              return _context5.finish(22);

            case 32:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[4, 18, 22, 32], [23,, 27, 31]]);
      }));

      function forEach(_x) {
        return _forEach.apply(this, arguments);
      }

      return forEach;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var needsToEmitClosed;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              needsToEmitClosed = !this[kClosed];
              this[kClosed] = true;
              _context6.next = 4;
              return cleanupCursorAsync(this, {
                needsToEmitClosed: needsToEmitClosed
              });

            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Returns an array of documents. The caller is responsible for making sure that there
     * is enough memory to store the results. Note that the array only contains partial
     * results when this cursor had been previously accessed. In that case,
     * cursor.rewind() can be used to reset the cursor.
     */

  }, {
    key: "toArray",
    value: function () {
      var _toArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var array, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, document;

        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              array = [];
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context7.prev = 3;
              _iterator2 = _asyncIterator(this);

            case 5:
              _context7.next = 7;
              return _iterator2.next();

            case 7:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context7.sent).done)) {
                _context7.next = 13;
                break;
              }

              document = _step2.value;
              array.push(document);

            case 10:
              _iteratorAbruptCompletion2 = false;
              _context7.next = 5;
              break;

            case 13:
              _context7.next = 19;
              break;

            case 15:
              _context7.prev = 15;
              _context7.t0 = _context7["catch"](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context7.t0;

            case 19:
              _context7.prev = 19;
              _context7.prev = 20;

              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context7.next = 24;
                break;
              }

              _context7.next = 24;
              return _iterator2["return"]();

            case 24:
              _context7.prev = 24;

              if (!_didIteratorError2) {
                _context7.next = 27;
                break;
              }

              throw _iteratorError2;

            case 27:
              return _context7.finish(24);

            case 28:
              return _context7.finish(19);

            case 29:
              return _context7.abrupt("return", array);

            case 30:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[3, 15, 19, 29], [20,, 24, 28]]);
      }));

      function toArray() {
        return _toArray.apply(this, arguments);
      }

      return toArray;
    }()
    /**
     * Add a cursor flag to the cursor
     *
     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
     * @param value - The flag boolean value.
     */

  }, {
    key: "addCursorFlag",
    value: function addCursorFlag(flag, value) {
      assertUninitialized(this);

      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError("Flag ".concat(flag, " is not one of ").concat(exports.CURSOR_FLAGS));
      }

      if (typeof value !== 'boolean') {
        throw new error_1.MongoInvalidArgumentError("Flag ".concat(flag, " must be a boolean value"));
      }

      this[kOptions][flag] = value;
      return this;
    }
    /**
     * Map all documents using the provided function
     * If there is a transform set on the cursor, that will be called first and the result passed to
     * this function's transform.
     *
     * @remarks
     *
     * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
     * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
     * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
     *
     * ```typescript
     * const cursor = collection.find({});
     * cursor.map(() => null);
     *
     * const documents = await cursor.toArray();
     * // documents is always [], regardless of how many documents are in the collection.
     * ```
     *
     * Other falsey values are allowed:
     *
     * ```typescript
     * const cursor = collection.find({});
     * cursor.map(() => '');
     *
     * const documents = await cursor.toArray();
     * // documents is now an array of empty strings
     * ```
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling map,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<Document> = coll.find();
     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
     * ```
     * @param transform - The mapping transformation method.
     */

  }, {
    key: "map",
    value: function map(transform) {
      assertUninitialized(this);
      var oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing

      if (oldTransform) {
        this[kTransform] = function (doc) {
          return transform(oldTransform(doc));
        };
      } else {
        this[kTransform] = transform;
      }

      return this;
    }
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */

  }, {
    key: "withReadPreference",
    value: function withReadPreference(readPreference) {
      assertUninitialized(this);

      if (readPreference instanceof read_preference_1.ReadPreference) {
        this[kOptions].readPreference = readPreference;
      } else if (typeof readPreference === 'string') {
        this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference: ".concat(readPreference));
      }

      return this;
    }
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */

  }, {
    key: "withReadConcern",
    value: function withReadConcern(readConcern) {
      assertUninitialized(this);
      var resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({
        readConcern: readConcern
      });

      if (resolvedReadConcern) {
        this[kOptions].readConcern = resolvedReadConcern;
      }

      return this;
    }
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */

  }, {
    key: "maxTimeMS",
    value: function maxTimeMS(value) {
      assertUninitialized(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
      }

      this[kOptions].maxTimeMS = value;
      return this;
    }
    /**
     * Set the batch size for the cursor.
     *
     * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.
     */

  }, {
    key: "batchSize",
    value: function batchSize(value) {
      assertUninitialized(this);

      if (this[kOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }

      this[kOptions].batchSize = value;
      return this;
    }
    /**
     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
     * if the resultant data has already been retrieved by this cursor.
     */

  }, {
    key: "rewind",
    value: function rewind() {
      if (!this[kInitialized]) {
        return;
      }

      this[kId] = null;
      this[kDocuments].clear();
      this[kClosed] = false;
      this[kKilled] = false;
      this[kInitialized] = false;
      var session = this[kSession];

      if (session) {
        // We only want to end this session if we created it, and it hasn't ended yet
        if (session.explicit === false) {
          if (!session.hasEnded) {
            session.endSession()["catch"](function () {
              return null;
            });
          }

          this[kSession] = this.client.startSession({
            owner: this,
            explicit: false
          });
        }
      }
    }
    /** @internal */

  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], _objectSpread(_objectSpread({}, this[kOptions]), {}, {
        session: this[kSession],
        batchSize: batchSize
      }));
      (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);
    }
    /**
     * @internal
     *
     * This function is exposed for the unified test runner's createChangeStream
     * operation.  We cannot refactor to use the abstract _initialize method without
     * a significant refactor.
     */

  }, {
    key: kInit,
    value: function value(callback) {
      var _this3 = this;

      this._initialize(this[kSession], function (error, state) {
        if (state) {
          var response = state.response;
          _this3[kServer] = state.server;

          if (response.cursor) {
            // TODO(NODE-2674): Preserve int64 sent from MongoDB
            _this3[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;

            if (response.cursor.ns) {
              _this3[kNamespace] = (0, utils_1.ns)(response.cursor.ns);
            }

            _this3[kDocuments].pushMany(response.cursor.firstBatch);
          } // When server responses return without a cursor document, we close this cursor
          // and return the raw server response. This is often the case for explain commands
          // for example


          if (_this3[kId] == null) {
            _this3[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter

            _this3[kDocuments].push(state.response);
          }
        } // the cursor is now initialized, even if an error occurred or it is dead


        _this3[kInitialized] = true;

        if (error) {
          return cleanupCursor(_this3, {
            error: error
          }, function () {
            return callback(error, undefined);
          });
        }

        if (cursorIsDead(_this3)) {
          return cleanupCursor(_this3, undefined, function () {
            return callback();
          });
        }

        callback();
      });
    }
  }]);

  return AbstractCursor;
}(mongo_types_1.TypedEventEmitter, Symbol.asyncIterator);
/** @event */


AbstractCursor.CLOSE = 'close';
exports.AbstractCursor = AbstractCursor;
/**
 * @param cursor - the cursor on which to call `next`
 * @param blocking - a boolean indicating whether or not the cursor should `block` until data
 *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,
 *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and
 *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does
 *     not indicate the end of the cursor.
 * @param transform - if true, the cursor's transform function is applied to the result document (if the transform exists)
 * @returns the next document in the cursor, or `null`.  When `blocking` is `true`, a `null` document means
 * the cursor has been exhausted.  Otherwise, it means that there is no document available in the cursor's buffer.
 */

function _next(_x2, _x3) {
  return _next3.apply(this, arguments);
}

function _next3() {
  _next3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(cursor, _ref) {
    var blocking, transform, cursorId, doc, init, batchSize, getMore, response, _cursorId;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          blocking = _ref.blocking, transform = _ref.transform;
          cursorId = cursor[kId];

          if (!cursor.closed) {
            _context8.next = 4;
            break;
          }

          return _context8.abrupt("return", null);

        case 4:
          if (!(cursor[kDocuments].length !== 0)) {
            _context8.next = 17;
            break;
          }

          doc = cursor[kDocuments].shift();

          if (!(doc != null && transform && cursor[kTransform])) {
            _context8.next = 16;
            break;
          }

          _context8.prev = 7;
          return _context8.abrupt("return", cursor[kTransform](doc));

        case 11:
          _context8.prev = 11;
          _context8.t0 = _context8["catch"](7);
          _context8.next = 15;
          return cleanupCursorAsync(cursor, {
            error: _context8.t0,
            needsToEmitClosed: true
          })["catch"](function () {// `cleanupCursorAsync` should never throw, but if it does we want to throw the original
            // error instead.
          });

        case 15:
          throw _context8.t0;

        case 16:
          return _context8.abrupt("return", doc);

        case 17:
          if (!(cursorId == null)) {
            _context8.next = 22;
            break;
          }

          // All cursors must operate within a session, one must be made implicitly if not explicitly provided
          init = (0, util_1.promisify)(function (cb) {
            return cursor[kInit](cb);
          });
          _context8.next = 21;
          return init();

        case 21:
          return _context8.abrupt("return", _next(cursor, {
            blocking: blocking,
            transform: transform
          }));

        case 22:
          if (!cursorIsDead(cursor)) {
            _context8.next = 26;
            break;
          }

          _context8.next = 25;
          return cleanupCursorAsync(cursor, {});

        case 25:
          return _context8.abrupt("return", null);

        case 26:
          // otherwise need to call getMore
          batchSize = cursor[kOptions].batchSize || 1000;
          getMore = (0, util_1.promisify)(function (batchSize, cb) {
            return cursor._getMore(batchSize, cb);
          });
          _context8.prev = 28;
          _context8.next = 31;
          return getMore(batchSize);

        case 31:
          response = _context8.sent;
          _context8.next = 40;
          break;

        case 34:
          _context8.prev = 34;
          _context8.t1 = _context8["catch"](28);

          if (!_context8.t1) {
            _context8.next = 40;
            break;
          }

          _context8.next = 39;
          return cleanupCursorAsync(cursor, {
            error: _context8.t1
          })["catch"](function () {// `cleanupCursorAsync` should never throw, but if it does we want to throw the original
            // error instead.
          });

        case 39:
          throw _context8.t1;

        case 40:
          if (response) {
            _cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;
            cursor[kDocuments].pushMany(response.cursor.nextBatch);
            cursor[kId] = _cursorId;
          }

          if (!cursorIsDead(cursor)) {
            _context8.next = 44;
            break;
          }

          _context8.next = 44;
          return cleanupCursorAsync(cursor, {});

        case 44:
          if (!(cursor[kDocuments].length === 0 && blocking === false)) {
            _context8.next = 46;
            break;
          }

          return _context8.abrupt("return", null);

        case 46:
          return _context8.abrupt("return", _next(cursor, {
            blocking: blocking,
            transform: transform
          }));

        case 47:
        case "end":
          return _context8.stop();
      }
    }, _callee8, null, [[7, 11], [28, 34]]);
  }));
  return _next3.apply(this, arguments);
}

function cursorIsDead(cursor) {
  var cursorId = cursor[kId];
  return !!cursorId && cursorId.isZero();
}

var cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);

function cleanupCursor(cursor, options, callback) {
  var _options$needsToEmitC;

  var cursorId = cursor[kId];
  var cursorNs = cursor[kNamespace];
  var server = cursor[kServer];
  var session = cursor[kSession];
  var error = options === null || options === void 0 ? void 0 : options.error; // Cursors only emit closed events once the client-side cursor has been exhausted fully or there
  // was an error.  Notably, when the server returns a cursor id of 0 and a non-empty batch, we
  // cleanup the cursor but don't emit a `close` event.

  var needsToEmitClosed = (_options$needsToEmitC = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _options$needsToEmitC !== void 0 ? _options$needsToEmitC : cursor[kDocuments].length === 0;

  if (error) {
    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {
      return completeCleanup();
    }
  }

  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {
    if (needsToEmitClosed) {
      cursor[kClosed] = true;
      cursor[kId] = bson_1.Long.ZERO;
      cursor.emit(AbstractCursor.CLOSE);
    }

    if (session) {
      if (session.owner === cursor) {
        session.endSession({
          error: error
        })["finally"](function () {
          callback();
        });
        return;
      }

      if (!session.inTransaction()) {
        (0, sessions_1.maybeClearPinnedConnection)(session, {
          error: error
        });
      }
    }

    return callback();
  }

  function completeCleanup() {
    if (session) {
      if (session.owner === cursor) {
        session.endSession({
          error: error
        })["finally"](function () {
          cursor.emit(AbstractCursor.CLOSE);
          callback();
        });
        return;
      }

      if (!session.inTransaction()) {
        (0, sessions_1.maybeClearPinnedConnection)(session, {
          error: error
        });
      }
    }

    cursor.emit(AbstractCursor.CLOSE);
    return callback();
  }

  cursor[kKilled] = true;

  if (session.hasEnded) {
    return completeCleanup();
  }

  (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {
    session: session
  }))["catch"](function () {
    return null;
  })["finally"](completeCleanup);
}
/** @internal */


function assertUninitialized(cursor) {
  if (cursor[kInitialized]) {
    throw new error_1.MongoCursorInUseError();
  }
}

exports.assertUninitialized = assertUninitialized;

var ReadableCursorStream = /*#__PURE__*/function (_stream_1$Readable) {
  _inherits(ReadableCursorStream, _stream_1$Readable);

  var _super2 = _createSuper(ReadableCursorStream);

  function ReadableCursorStream(cursor) {
    var _this4;

    _classCallCheck(this, ReadableCursorStream);

    _this4 = _super2.call(this, {
      objectMode: true,
      autoDestroy: false,
      highWaterMark: 1
    });
    _this4._readInProgress = false;
    _this4._cursor = cursor;
    return _this4;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _createClass(ReadableCursorStream, [{
    key: "_read",
    value: function _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;

        this._readNext();
      }
    }
  }, {
    key: "_destroy",
    value: function _destroy(error, callback) {
      this._cursor.close().then(function () {
        return callback(error);
      }, function (closeError) {
        return callback(closeError);
      });
    }
  }, {
    key: "_readNext",
    value: function _readNext() {
      var _this5 = this;

      _next(this._cursor, {
        blocking: true,
        transform: true
      }).then(function (result) {
        if (result == null) {
          _this5.push(null);
        } else if (_this5.destroyed) {
          _this5._cursor.close()["catch"](function () {
            return null;
          });
        } else {
          if (_this5.push(result)) {
            return _this5._readNext();
          }

          _this5._readInProgress = false;
        }
      }, function (err) {
        // NOTE: This is questionable, but we have a test backing the behavior. It seems the
        //       desired behavior is that a stream ends cleanly when a user explicitly closes
        //       a client during iteration. Alternatively, we could do the "right" thing and
        //       propagate the error message by removing this special case.
        if (err.message.match(/server is closed/)) {
          _this5._cursor.close()["catch"](function () {
            return null;
          });

          return _this5.push(null);
        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend
        //       to be "operation was interrupted", where a cursor has been closed but there is an
        //       active getMore in-flight. This used to check if the cursor was killed but once
        //       that changed to happen in cleanup legitimate errors would not destroy the
        //       stream. There are change streams test specifically test these cases.


        if (err.message.match(/operation was interrupted/)) {
          return _this5.push(null);
        } // NOTE: The two above checks on the message of the error will cause a null to be pushed
        //       to the stream, thus closing the stream before the destroy call happens. This means
        //       that either of those error messages on a change stream will not get a proper
        //       'error' event to be emitted (the error passed to destroy). Change stream resumability
        //       relies on that error event to be emitted to create its new cursor and thus was not
        //       working on 4.4 servers because the error emitted on failover was "interrupted at
        //       shutdown" while on 5.0+ it is "The server is in quiesce mode and will shut down".
        //       See NODE-4475.


        return _this5.destroy(err);
      });
    }
  }]);

  return ReadableCursorStream;
}(stream_1.Readable);

/***/ }),

/***/ 334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AggregationCursor = void 0;

var aggregate_1 = __webpack_require__(9356);

var execute_operation_1 = __webpack_require__(5756);

var utils_1 = __webpack_require__(672);

var abstract_cursor_1 = __webpack_require__(9800);
/** @internal */


var kPipeline = Symbol('pipeline');
/** @internal */

var kOptions = Symbol('options');
/**
 * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
 * or higher stream
 * @public
 */

var AggregationCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(AggregationCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(AggregationCursor);

  /** @internal */
  function AggregationCursor(client, namespace) {
    var _this;

    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, AggregationCursor);

    _this = _super.call(this, client, namespace, options);
    _this[kPipeline] = pipeline;
    _this[kOptions] = options;
    return _this;
  }

  _createClass(AggregationCursor, [{
    key: "pipeline",
    get: function get() {
      return this[kPipeline];
    }
  }, {
    key: "clone",
    value: function clone() {
      var clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this[kPipeline], _objectSpread({}, clonedOptions));
    }
  }, {
    key: "map",
    value: function map(transform) {
      return _get(_getPrototypeOf(AggregationCursor.prototype), "map", this).call(this, transform);
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread(_objectSpread(_objectSpread({}, this[kOptions]), this.cursorOptions), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: aggregateOperation.server,
          session: session,
          response: response
        });
      });
    }
    /** Execute the explain for the cursor */

  }, {
    key: "explain",
    value: function () {
      var _explain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(verbosity) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread(_objectSpread(_objectSpread({}, this[kOptions]), this.cursorOptions), {}, {
                explain: verbosity !== null && verbosity !== void 0 ? verbosity : true
              }))));

            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function explain(_x) {
        return _explain.apply(this, arguments);
      }

      return explain;
    }()
  }, {
    key: "group",
    value: function group($group) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $group: $group
      });
      return this;
    }
    /** Add a limit stage to the aggregation pipeline */

  }, {
    key: "limit",
    value: function limit($limit) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $limit: $limit
      });
      return this;
    }
    /** Add a match stage to the aggregation pipeline */

  }, {
    key: "match",
    value: function match($match) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $match: $match
      });
      return this;
    }
    /** Add an out stage to the aggregation pipeline */

  }, {
    key: "out",
    value: function out($out) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $out: $out
      });
      return this;
    }
    /**
     * Add a project stage to the aggregation pipeline
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
     * You should specify a parameterized type to have assertions on your final results.
     *
     * @example
     * ```typescript
     * // Best way
     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
     * // Flexible way
     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
     * ```
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling project,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
     *
     * // or always use chaining and save the final cursor
     *
     * const cursor = coll.aggregate().project<{ a: string }>({
     *   _id: 0,
     *   a: { $convert: { input: '$a', to: 'string' }
     * }});
     * ```
     */

  }, {
    key: "project",
    value: function project($project) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $project: $project
      });
      return this;
    }
    /** Add a lookup stage to the aggregation pipeline */

  }, {
    key: "lookup",
    value: function lookup($lookup) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $lookup: $lookup
      });
      return this;
    }
    /** Add a redact stage to the aggregation pipeline */

  }, {
    key: "redact",
    value: function redact($redact) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $redact: $redact
      });
      return this;
    }
    /** Add a skip stage to the aggregation pipeline */

  }, {
    key: "skip",
    value: function skip($skip) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $skip: $skip
      });
      return this;
    }
    /** Add a sort stage to the aggregation pipeline */

  }, {
    key: "sort",
    value: function sort($sort) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $sort: $sort
      });
      return this;
    }
    /** Add a unwind stage to the aggregation pipeline */

  }, {
    key: "unwind",
    value: function unwind($unwind) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $unwind: $unwind
      });
      return this;
    }
    /** Add a geoNear stage to the aggregation pipeline */

  }, {
    key: "geoNear",
    value: function geoNear($geoNear) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $geoNear: $geoNear
      });
      return this;
    }
  }]);

  return AggregationCursor;
}(abstract_cursor_1.AbstractCursor);

exports.AggregationCursor = AggregationCursor;

/***/ }),

/***/ 7929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChangeStreamCursor = void 0;

var change_stream_1 = __webpack_require__(7944);

var constants_1 = __webpack_require__(9592);

var aggregate_1 = __webpack_require__(9356);

var execute_operation_1 = __webpack_require__(5756);

var utils_1 = __webpack_require__(672);

var abstract_cursor_1 = __webpack_require__(9800);
/** @internal */


var ChangeStreamCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ChangeStreamCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ChangeStreamCursor);

  function ChangeStreamCursor(client, namespace) {
    var _this;

    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, ChangeStreamCursor);

    _this = _super.call(this, client, namespace, options);
    _this.pipeline = pipeline;
    _this.options = options;
    _this._resumeToken = null;
    _this.startAtOperationTime = options.startAtOperationTime;

    if (options.startAfter) {
      _this.resumeToken = options.startAfter;
    } else if (options.resumeAfter) {
      _this.resumeToken = options.resumeAfter;
    }

    return _this;
  }

  _createClass(ChangeStreamCursor, [{
    key: "resumeToken",
    get: function get() {
      return this._resumeToken;
    },
    set: function set(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
  }, {
    key: "resumeOptions",
    get: function get() {
      var options = _objectSpread({}, this.options);

      for (var _i = 0, _arr = ['resumeAfter', 'startAfter', 'startAtOperationTime']; _i < _arr.length; _i++) {
        var key = _arr[_i];
        delete options[key];
      }

      if (this.resumeToken != null) {
        if (this.options.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }

      return options;
    }
  }, {
    key: "cacheResumeToken",
    value: function cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }

      this.hasReceived = true;
    }
  }, {
    key: "_processBatch",
    value: function _processBatch(response) {
      var cursor = response.cursor;

      if (cursor.postBatchResumeToken) {
        this.postBatchResumeToken = response.cursor.postBatchResumeToken;
        var batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;

        if (batch.length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, _objectSpread({}, this.cursorOptions));
    }
  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var _this2 = this;

      var aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, function (err, response) {
        if (err || response == null) {
          return callback(err);
        }

        var server = aggregateOperation.server;
        _this2.maxWireVersion = (0, utils_1.maxWireVersion)(server);

        if (_this2.startAtOperationTime == null && _this2.resumeAfter == null && _this2.startAfter == null && _this2.maxWireVersion >= 7) {
          _this2.startAtOperationTime = response.operationTime;
        }

        _this2._processBatch(response);

        _this2.emit(constants_1.INIT, response);

        _this2.emit(constants_1.RESPONSE); // TODO: NODE-2882


        callback(undefined, {
          server: server,
          session: session,
          response: response
        });
      });
    }
  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(ChangeStreamCursor.prototype), "_getMore", this).call(this, batchSize, function (err, response) {
        if (err) {
          return callback(err);
        }

        _this3.maxWireVersion = (0, utils_1.maxWireVersion)(_this3.server);

        _this3._processBatch(response);

        _this3.emit(change_stream_1.ChangeStream.MORE, response);

        _this3.emit(change_stream_1.ChangeStream.RESPONSE);

        callback(err, response);
      });
    }
  }]);

  return ChangeStreamCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ChangeStreamCursor = ChangeStreamCursor;

/***/ }),

/***/ 246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindCursor = exports.FLAGS = void 0;

var error_1 = __webpack_require__(9525);

var count_1 = __webpack_require__(5129);

var execute_operation_1 = __webpack_require__(5756);

var find_1 = __webpack_require__(4128);

var sort_1 = __webpack_require__(8077);

var utils_1 = __webpack_require__(672);

var abstract_cursor_1 = __webpack_require__(9800);
/** @internal */


var kFilter = Symbol('filter');
/** @internal */

var kNumReturned = Symbol('numReturned');
/** @internal */

var kBuiltOptions = Symbol('builtOptions');
/** @public Flags allowed for cursor */

exports.FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
/** @public */

var FindCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(FindCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(FindCursor);

  /** @internal */
  function FindCursor(client, namespace) {
    var _this;

    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, FindCursor);

    _this = _super.call(this, client, namespace, options);
    _this[kFilter] = filter;
    _this[kBuiltOptions] = options;

    if (options.sort != null) {
      _this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);
    }

    return _this;
  }

  _createClass(FindCursor, [{
    key: "clone",
    value: function clone() {
      var clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this[kFilter], _objectSpread({}, clonedOptions));
    }
  }, {
    key: "map",
    value: function map(transform) {
      return _get(_getPrototypeOf(FindCursor.prototype), "map", this).call(this, transform);
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var _this2 = this;

      var findOperation = new find_1.FindOperation(undefined, this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.client, findOperation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: We only need this for legacy queries that do not support `limit`, maybe
        //       the value should only be saved in those cases.

        if (response.cursor) {
          _this2[kNumReturned] = response.cursor.firstBatch.length;
        } else {
          _this2[kNumReturned] = response.documents ? response.documents.length : 0;
        } // TODO: NODE-2882


        callback(undefined, {
          server: findOperation.server,
          session: session,
          response: response
        });
      });
    }
    /** @internal */

  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      var _this3 = this;

      // NOTE: this is to support client provided limits in pre-command servers
      var numReturned = this[kNumReturned];

      if (numReturned) {
        var limit = this[kBuiltOptions].limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;

        if (batchSize <= 0) {
          this.close()["finally"](function () {
            return callback();
          });
          return;
        }
      }

      _get(_getPrototypeOf(FindCursor.prototype), "_getMore", this).call(this, batchSize, function (err, response) {
        if (err) return callback(err); // TODO: wrap this in some logic to prevent it from happening if we don't need this support

        if (response) {
          _this3[kNumReturned] = _this3[kNumReturned] + response.cursor.nextBatch.length;
        }

        callback(undefined, response);
      });
    }
    /**
     * Get the count of documents for this cursor
     * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead
     */

  }, {
    key: "count",
    value: function () {
      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');

              if (!(typeof options === 'boolean')) {
                _context.next = 3;
                break;
              }

              throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');

            case 3:
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), options))));

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function count(_x) {
        return _count.apply(this, arguments);
      }

      return count;
    }()
    /** Execute the explain for the cursor */

  }, {
    key: "explain",
    value: function () {
      var _explain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(verbosity) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(undefined, this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), {}, {
                explain: verbosity !== null && verbosity !== void 0 ? verbosity : true
              }))));

            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function explain(_x2) {
        return _explain.apply(this, arguments);
      }

      return explain;
    }()
    /** Set the cursor query */

  }, {
    key: "filter",
    value: function filter(_filter) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kFilter] = _filter;
      return this;
    }
    /**
     * Set the cursor hint
     *
     * @param hint - If specified, then the query system will only consider plans using the hinted index.
     */

  }, {
    key: "hint",
    value: function hint(_hint) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].hint = _hint;
      return this;
    }
    /**
     * Set the cursor min
     *
     * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
     */

  }, {
    key: "min",
    value: function min(_min) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].min = _min;
      return this;
    }
    /**
     * Set the cursor max
     *
     * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
     */

  }, {
    key: "max",
    value: function max(_max) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].max = _max;
      return this;
    }
    /**
     * Set the cursor returnKey.
     * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
     * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
     *
     * @param value - the returnKey value.
     */

  }, {
    key: "returnKey",
    value: function returnKey(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].returnKey = value;
      return this;
    }
    /**
     * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
     *
     * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
     */

  }, {
    key: "showRecordId",
    value: function showRecordId(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].showRecordId = value;
      return this;
    }
    /**
     * Add a query modifier to the cursor query
     *
     * @param name - The query modifier (must start with $, such as $orderby etc)
     * @param value - The modifier value.
     */

  }, {
    key: "addQueryModifier",
    value: function addQueryModifier(name, value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (name[0] !== '$') {
        throw new error_1.MongoInvalidArgumentError("".concat(name, " is not a valid query modifier"));
      } // Strip of the $


      var field = name.substr(1); // NOTE: consider some TS magic for this

      switch (field) {
        case 'comment':
          this[kBuiltOptions].comment = value;
          break;

        case 'explain':
          this[kBuiltOptions].explain = value;
          break;

        case 'hint':
          this[kBuiltOptions].hint = value;
          break;

        case 'max':
          this[kBuiltOptions].max = value;
          break;

        case 'maxTimeMS':
          this[kBuiltOptions].maxTimeMS = value;
          break;

        case 'min':
          this[kBuiltOptions].min = value;
          break;

        case 'orderby':
          this[kBuiltOptions].sort = (0, sort_1.formatSort)(value);
          break;

        case 'query':
          this[kFilter] = value;
          break;

        case 'returnKey':
          this[kBuiltOptions].returnKey = value;
          break;

        case 'showDiskLoc':
          this[kBuiltOptions].showRecordId = value;
          break;

        default:
          throw new error_1.MongoInvalidArgumentError("Invalid query modifier: ".concat(name));
      }

      return this;
    }
    /**
     * Add a comment to the cursor query allowing for tracking the comment in the log.
     *
     * @param value - The comment attached to this query.
     */

  }, {
    key: "comment",
    value: function comment(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].comment = value;
      return this;
    }
    /**
     * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
     *
     * @param value - Number of milliseconds to wait before aborting the tailed query.
     */

  }, {
    key: "maxAwaitTimeMS",
    value: function maxAwaitTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');
      }

      this[kBuiltOptions].maxAwaitTimeMS = value;
      return this;
    }
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */

  }, {
    key: "maxTimeMS",
    value: function maxTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
      }

      this[kBuiltOptions].maxTimeMS = value;
      return this;
    }
    /**
     * Add a project stage to the aggregation pipeline
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * By default chaining a projection to your cursor changes the returned type to the generic
     * {@link Document} type.
     * You should specify a parameterized type to have assertions on your final results.
     *
     * @example
     * ```typescript
     * // Best way
     * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
     * // Flexible way
     * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
     * ```
     *
     * @remarks
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling project,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
     *
     * // or always use chaining and save the final cursor
     *
     * const cursor = coll.find().project<{ a: string }>({
     *   _id: 0,
     *   a: { $convert: { input: '$a', to: 'string' }
     * }});
     * ```
     */

  }, {
    key: "project",
    value: function project(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].projection = value;
      return this;
    }
    /**
     * Sets the sort order of the cursor query.
     *
     * @param sort - The key or keys set for the sort.
     * @param direction - The direction of the sorting (1 or -1).
     */

  }, {
    key: "sort",
    value: function sort(_sort, direction) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');
      }

      this[kBuiltOptions].sort = (0, sort_1.formatSort)(_sort, direction);
      return this;
    }
    /**
     * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
     *
     * @remarks
     * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
     */

  }, {
    key: "allowDiskUse",
    value: function allowDiskUse() {
      var allow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (!this[kBuiltOptions].sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      } // As of 6.0 the default is true. This allows users to get back to the old behavior.


      if (!allow) {
        this[kBuiltOptions].allowDiskUse = false;
        return this;
      }

      this[kBuiltOptions].allowDiskUse = true;
      return this;
    }
    /**
     * Set the collation options for the cursor.
     *
     * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
     */

  }, {
    key: "collation",
    value: function collation(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].collation = value;
      return this;
    }
    /**
     * Set the limit for the cursor.
     *
     * @param value - The limit for the cursor query.
     */

  }, {
    key: "limit",
    value: function limit(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }

      this[kBuiltOptions].limit = value;
      return this;
    }
    /**
     * Set the skip for the cursor.
     *
     * @param value - The skip for the cursor query.
     */

  }, {
    key: "skip",
    value: function skip(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }

      this[kBuiltOptions].skip = value;
      return this;
    }
  }]);

  return FindCursor;
}(abstract_cursor_1.AbstractCursor);

exports.FindCursor = FindCursor;

/***/ }),

/***/ 1297:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListCollectionsCursor = void 0;

var execute_operation_1 = __webpack_require__(5756);

var list_collections_1 = __webpack_require__(1328);

var abstract_cursor_1 = __webpack_require__(9800);
/** @public */


var ListCollectionsCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ListCollectionsCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ListCollectionsCursor);

  function ListCollectionsCursor(db, filter, options) {
    var _this;

    _classCallCheck(this, ListCollectionsCursor);

    _this = _super.call(this, db.client, db.s.namespace, options);
    _this.parent = db;
    _this.filter = filter;
    _this.options = options;
    return _this;
  }

  _createClass(ListCollectionsCursor, [{
    key: "clone",
    value: function clone() {
      return new ListCollectionsCursor(this.parent, this.filter, _objectSpread(_objectSpread({}, this.options), this.cursorOptions));
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.parent.client, operation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: operation.server,
          session: session,
          response: response
        });
      });
    }
  }]);

  return ListCollectionsCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ListCollectionsCursor = ListCollectionsCursor;

/***/ }),

/***/ 1512:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListIndexesCursor = void 0;

var execute_operation_1 = __webpack_require__(5756);

var indexes_1 = __webpack_require__(240);

var abstract_cursor_1 = __webpack_require__(9800);
/** @public */


var ListIndexesCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ListIndexesCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ListIndexesCursor);

  function ListIndexesCursor(collection, options) {
    var _this;

    _classCallCheck(this, ListIndexesCursor);

    _this = _super.call(this, collection.client, collection.s.namespace, options);
    _this.parent = collection;
    _this.options = options;
    return _this;
  }

  _createClass(ListIndexesCursor, [{
    key: "clone",
    value: function clone() {
      return new ListIndexesCursor(this.parent, _objectSpread(_objectSpread({}, this.options), this.cursorOptions));
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var operation = new indexes_1.ListIndexesOperation(this.parent, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.parent.client, operation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: operation.server,
          session: session,
          response: response
        });
      });
    }
  }]);

  return ListIndexesCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ListIndexesCursor = ListIndexesCursor;

/***/ }),

/***/ 8422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListSearchIndexesCursor = void 0;

var aggregation_cursor_1 = __webpack_require__(334);
/** @public */


var ListSearchIndexesCursor = /*#__PURE__*/function (_aggregation_cursor_) {
  _inherits(ListSearchIndexesCursor, _aggregation_cursor_);

  var _super = _createSuper(ListSearchIndexesCursor);

  /** @internal */
  function ListSearchIndexesCursor(_ref, name) {
    var ns = _ref.fullNamespace,
        client = _ref.client;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ListSearchIndexesCursor);

    var pipeline = name == null ? [{
      $listSearchIndexes: {}
    }] : [{
      $listSearchIndexes: {
        name: name
      }
    }];
    return _super.call(this, client, ns, pipeline, options);
  }

  return _createClass(ListSearchIndexesCursor);
}(aggregation_cursor_1.AggregationCursor);

exports.ListSearchIndexesCursor = ListSearchIndexesCursor;

/***/ }),

/***/ 4572:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RunCommandCursor = void 0;

var error_1 = __webpack_require__(9525);

var execute_operation_1 = __webpack_require__(5756);

var get_more_1 = __webpack_require__(4275);

var run_command_1 = __webpack_require__(6621);

var utils_1 = __webpack_require__(672);

var abstract_cursor_1 = __webpack_require__(9800);
/** @public */


var RunCommandCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(RunCommandCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(RunCommandCursor);

  /** @internal */
  function RunCommandCursor(db, command) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, RunCommandCursor);

    _this = _super.call(this, db.client, (0, utils_1.ns)(db.namespace), options);
    _this.getMoreOptions = {};
    _this.db = db;
    _this.command = Object.freeze(_objectSpread({}, command));
    return _this;
  }
  /** @internal */


  _createClass(RunCommandCursor, [{
    key: "setComment",
    value:
    /**
     * Controls the `getMore.comment` field
     * @param comment - any BSON value
     */
    function setComment(comment) {
      this.getMoreOptions.comment = comment;
      return this;
    }
    /**
     * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await
     * @param maxTimeMS - the number of milliseconds to wait for new data
     */

  }, {
    key: "setMaxTimeMS",
    value: function setMaxTimeMS(maxTimeMS) {
      this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
      return this;
    }
    /**
     * Controls the `getMore.batchSize` field
     * @param maxTimeMS - the number documents to return in the `nextBatch`
     */

  }, {
    key: "setBatchSize",
    value: function setBatchSize(batchSize) {
      this.getMoreOptions.batchSize = batchSize;
      return this;
    }
    /** Unsupported for RunCommandCursor */

  }, {
    key: "clone",
    value: function clone() {
      throw new error_1.MongoAPIError('Clone not supported, create a new cursor with db.runCursorCommand');
    }
    /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */

  }, {
    key: "withReadConcern",
    value: function withReadConcern(_) {
      throw new error_1.MongoAPIError('RunCommandCursor does not support readConcern it must be attached to the command being run');
    }
    /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */

  }, {
    key: "addCursorFlag",
    value: function addCursorFlag(_, __) {
      throw new error_1.MongoAPIError('RunCommandCursor does not support cursor flags, they must be attached to the command being run');
    }
    /** Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document */

  }, {
    key: "maxTimeMS",
    value: function maxTimeMS(_) {
      throw new error_1.MongoAPIError('maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()');
    }
    /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */

  }, {
    key: "batchSize",
    value: function batchSize(_) {
      throw new error_1.MongoAPIError('batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()');
    }
  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var operation = new run_command_1.RunCommandOperation(this.db, this.command, _objectSpread(_objectSpread({}, this.cursorOptions), {}, {
        session: session,
        readPreference: this.cursorOptions.readPreference
      }));
      (0, execute_operation_1.executeOperation)(this.client, operation).then(function (response) {
        if (response.cursor == null) {
          callback(new error_1.MongoUnexpectedServerResponseError('Expected server to respond with cursor'));
          return;
        }

        callback(undefined, {
          server: operation.server,
          session: session,
          response: response
        });
      }, function (err) {
        return callback(err);
      });
    }
    /** @internal */

  }, {
    key: "_getMore",
    value: function _getMore(_batchSize, callback) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, _objectSpread(_objectSpread({}, this.cursorOptions), {}, {
        session: this.session
      }, this.getMoreOptions));
      (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, callback);
    }
  }]);

  return RunCommandCursor;
}(abstract_cursor_1.AbstractCursor);

exports.RunCommandCursor = RunCommandCursor;

/***/ }),

/***/ 8931:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Db = void 0;

var admin_1 = __webpack_require__(2340);

var bson_1 = __webpack_require__(4356);

var change_stream_1 = __webpack_require__(7944);

var collection_1 = __webpack_require__(9816);

var CONSTANTS = __webpack_require__(9592);

var aggregation_cursor_1 = __webpack_require__(334);

var list_collections_cursor_1 = __webpack_require__(1297);

var run_command_cursor_1 = __webpack_require__(4572);

var error_1 = __webpack_require__(9525);

var add_user_1 = __webpack_require__(8012);

var collections_1 = __webpack_require__(4086);

var create_collection_1 = __webpack_require__(6589);

var drop_1 = __webpack_require__(4149);

var execute_operation_1 = __webpack_require__(5756);

var indexes_1 = __webpack_require__(240);

var profiling_level_1 = __webpack_require__(3157);

var remove_user_1 = __webpack_require__(9246);

var rename_1 = __webpack_require__(116);

var run_command_1 = __webpack_require__(6621);

var set_profiling_level_1 = __webpack_require__(3705);

var stats_1 = __webpack_require__(5142);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916); // Allowed parameters


var DB_OPTIONS_ALLOW_LIST = ['writeConcern', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'authSource', 'ignoreUndefined', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'useBigInt64', 'promoteBuffers', 'promoteLongs', 'bsonRegExp', 'enableUtf8Validation', 'promoteValues', 'compression', 'retryWrites'];
/**
 * The **Db** class is a class that represents a MongoDB Database.
 * @public
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * interface Pet {
 *   name: string;
 *   kind: 'dog' | 'cat' | 'fish';
 * }
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * const db = client.db();
 *
 * // Create a collection that validates our union
 * await db.createCollection<Pet>('pets', {
 *   validator: { $expr: { $in: ['$kind', ['dog', 'cat', 'fish']] } }
 * })
 * ```
 */

var Db = /*#__PURE__*/function () {
  /**
   * Creates a new Db instance
   *
   * @param client - The MongoClient for the database.
   * @param databaseName - The name of the database this instance represents.
   * @param options - Optional settings for Db construction
   */
  function Db(client, databaseName, options) {
    var _options, _options$pkFactory, _options2;

    _classCallCheck(this, Db);

    options = (_options = options) !== null && _options !== void 0 ? _options : {}; // Filter the options

    options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST); // Ensure we have a valid db name

    validateDatabaseName(databaseName); // Internal state of the db object

    this.s = {
      // Options
      options: options,
      // Unpack read preference
      readPreference: read_preference_1.ReadPreference.fromOptions(options),
      // Merge bson options
      bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
      // Set up the primary key factory or fallback to ObjectId
      pkFactory: (_options$pkFactory = (_options2 = options) === null || _options2 === void 0 ? void 0 : _options2.pkFactory) !== null && _options$pkFactory !== void 0 ? _options$pkFactory : utils_1.DEFAULT_PK_FACTORY,
      // ReadConcern
      readConcern: read_concern_1.ReadConcern.fromOptions(options),
      writeConcern: write_concern_1.WriteConcern.fromOptions(options),
      // Namespace
      namespace: new utils_1.MongoDBNamespace(databaseName)
    };
    this.client = client;
  }

  _createClass(Db, [{
    key: "databaseName",
    get: function get() {
      return this.s.namespace.db;
    } // Options

  }, {
    key: "options",
    get: function get() {
      return this.s.options;
    }
    /**
     * Check if a secondary can be used (because the read preference is *not* set to primary)
     */

  }, {
    key: "secondaryOk",
    get: function get() {
      var _this$s$readPreferenc;

      return ((_this$s$readPreferenc = this.s.readPreference) === null || _this$s$readPreferenc === void 0 ? void 0 : _this$s$readPreferenc.preference) !== 'primary' || false;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this.s.readConcern;
    }
    /**
     * The current readPreference of the Db. If not explicitly defined for
     * this Db, will be inherited from the parent MongoClient
     */

  }, {
    key: "readPreference",
    get: function get() {
      if (this.s.readPreference == null) {
        return this.client.readPreference;
      }

      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    } // get the write Concern

  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "namespace",
    get: function get() {
      return this.s.namespace.toString();
    }
    /**
     * Create a new collection on a server with the specified options. Use this to create capped collections.
     * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/
     *
     * @param name - The name of the collection to create
     * @param options - Optional settings for the command
     */

  }, {
    key: "createCollection",
    value: function () {
      var _createCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function createCollection(_x, _x2) {
        return _createCollection.apply(this, arguments);
      }

      return createCollection;
    }()
    /**
     * Execute a command
     *
     * @remarks
     * This command does not inherit options from the MongoClient.
     *
     * The driver will ensure the following fields are attached to the command sent to the server:
     * - `lsid` - sourced from an implicit session or options.session
     * - `$readPreference` - defaults to primary or can be configured by options.readPreference
     * - `$db` - sourced from the name of this database
     *
     * If the client has a serverApi setting:
     * - `apiVersion`
     * - `apiStrict`
     * - `apiDeprecationErrors`
     *
     * When in a transaction:
     * - `readConcern` - sourced from readConcern set on the TransactionOptions
     * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
     *
     * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
     *
     * @param command - The command to run
     * @param options - Optional settings for the command
     */

  }, {
    key: "command",
    value: function () {
      var _command2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_command, options) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, _command, options)));

            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function command(_x3, _x4) {
        return _command2.apply(this, arguments);
      }

      return command;
    }()
    /**
     * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
     *
     * @param pipeline - An array of aggregation stages to be executed
     * @param options - Optional settings for the command
     */

  }, {
    key: "aggregate",
    value: function aggregate() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /** Return the Admin db instance */

  }, {
    key: "admin",
    value: function admin() {
      return new admin_1.Admin(this);
    }
    /**
     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
     *
     * @param name - the collection name we wish to access.
     * @returns return the new Collection instance
     */

  }, {
    key: "collection",
    value: function collection(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (typeof options === 'function') {
        throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');
      }

      return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Get all the db statistics.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "stats",
    value: function () {
      var _stats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function stats(_x5) {
        return _stats.apply(this, arguments);
      }

      return stats;
    }()
  }, {
    key: "listCollections",
    value: function listCollections() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Rename a collection.
     *
     * @remarks
     * This operation does not inherit options from the MongoClient.
     *
     * @param fromCollection - Name of current collection to rename
     * @param toCollection - New name of of the collection
     * @param options - Optional settings for the command
     */

  }, {
    key: "renameCollection",
    value: function () {
      var _renameCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fromCollection, toCollection, options) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, _objectSpread(_objectSpread({}, options), {}, {
                new_collection: true,
                readPreference: read_preference_1.ReadPreference.primary
              }))));

            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function renameCollection(_x6, _x7, _x8) {
        return _renameCollection.apply(this, arguments);
      }

      return renameCollection;
    }()
    /**
     * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
     *
     * @param name - Name of collection to drop
     * @param options - Optional settings for the command
     */

  }, {
    key: "dropCollection",
    value: function () {
      var _dropCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(name, options) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function dropCollection(_x9, _x10) {
        return _dropCollection.apply(this, arguments);
      }

      return dropCollection;
    }()
    /**
     * Drop a database, removing it permanently from the server.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "dropDatabase",
    value: function () {
      var _dropDatabase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function dropDatabase(_x11) {
        return _dropDatabase.apply(this, arguments);
      }

      return dropDatabase;
    }()
    /**
     * Fetch all collections for the current db.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "collections",
    value: function () {
      var _collections = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function collections(_x12) {
        return _collections.apply(this, arguments);
      }

      return collections;
    }()
    /**
     * Creates an index on the db and collection.
     *
     * @param name - Name of the collection to create the index on.
     * @param indexSpec - Specify the field to index, or an index specification
     * @param options - Optional settings for the command
     */

  }, {
    key: "createIndex",
    value: function () {
      var _createIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(name, indexSpec, options) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function createIndex(_x13, _x14, _x15) {
        return _createIndex.apply(this, arguments);
      }

      return createIndex;
    }()
    /**
     * Add a user to the database
     *
     * @param username - The username for the new user
     * @param passwordOrOptions - An optional password for the new user, or the options for the command
     * @param options - Optional settings for the command
     * @deprecated Use the createUser command in `db.command()` instead.
     * @see https://www.mongodb.com/docs/manual/reference/command/createUser/
     */

  }, {
    key: "addUser",
    value: function () {
      var _addUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(username, passwordOrOptions, options) {
        var password;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              options = options != null && _typeof(options) === 'object' ? options : passwordOrOptions != null && _typeof(passwordOrOptions) === 'object' ? passwordOrOptions : undefined;
              password = typeof passwordOrOptions === 'string' ? passwordOrOptions : undefined;
              return _context9.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options))));

            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function addUser(_x16, _x17, _x18) {
        return _addUser.apply(this, arguments);
      }

      return addUser;
    }()
    /**
     * Remove a user from a database
     *
     * @param username - The username to remove
     * @param options - Optional settings for the command
     */

  }, {
    key: "removeUser",
    value: function () {
      var _removeUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(username, options) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function removeUser(_x19, _x20) {
        return _removeUser.apply(this, arguments);
      }

      return removeUser;
    }()
    /**
     * Set the current profiling level of MongoDB
     *
     * @param level - The new profiling level (off, slow_only, all).
     * @param options - Optional settings for the command
     */

  }, {
    key: "setProfilingLevel",
    value: function () {
      var _setProfilingLevel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(level, options) {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      function setProfilingLevel(_x21, _x22) {
        return _setProfilingLevel.apply(this, arguments);
      }

      return setProfilingLevel;
    }()
    /**
     * Retrieve the current profiling Level for MongoDB
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "profilingLevel",
    value: function () {
      var _profilingLevel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(options) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));

      function profilingLevel(_x23) {
        return _profilingLevel.apply(this, arguments);
      }

      return profilingLevel;
    }()
    /**
     * Retrieves this collections index info.
     *
     * @param name - The name of the collection.
     * @param options - Optional settings for the command
     */

  }, {
    key: "indexInformation",
    value: function () {
      var _indexInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(name, options) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt("return", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options))));

            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));

      function indexInformation(_x24, _x25) {
        return _indexInformation.apply(this, arguments);
      }

      return indexInformation;
    }()
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this database. Will ignore all
     * changes to system collections.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to provide the schema that may be defined for all the collections within this database
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * A low level cursor API providing basic driver functionality:
     * - ClientSession management
     * - ReadPreference for server selection
     * - Running getMores automatically when a local batch is exhausted
     *
     * @param command - The command that will start a cursor on the server.
     * @param options - Configurations for running the command, bson options will apply to getMores
     */

  }, {
    key: "runCursorCommand",
    value: function runCursorCommand(command, options) {
      return new run_command_cursor_1.RunCommandCursor(this, command, options);
    }
  }]);

  return Db;
}();

Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
exports.Db = Db; // TODO(NODE-3484): Refactor into MongoDBNamespace
// Validate the database name

function validateDatabaseName(databaseName) {
  if (typeof databaseName !== 'string') throw new error_1.MongoInvalidArgumentError('Database name must be a string');
  if (databaseName.length === 0) throw new error_1.MongoInvalidArgumentError('Database name cannot be the empty string');
  if (databaseName === '$external') return;
  var invalidChars = [' ', '.', '$', '/', '\\'];

  for (var i = 0; i < invalidChars.length; i++) {
    if (databaseName.indexOf(invalidChars[i]) !== -1) throw new error_1.MongoAPIError("database names cannot contain the character '".concat(invalidChars[i], "'"));
  }
}

/***/ }),

/***/ 8310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AutoEncryptionLoggerLevel = exports.aws4 = exports.saslprep = exports.getSnappy = exports.getAwsCredentialProvider = exports.getZstdLibrary = exports.ZStandard = exports.getKerberos = exports.Kerberos = void 0;

var error_1 = __webpack_require__(9525);

function makeErrorModule(error) {
  var props = error ? {
    kModuleError: error
  } : {};
  return new Proxy(props, {
    get: function get(_, key) {
      if (key === 'kModuleError') {
        return error;
      }

      throw error;
    },
    set: function set() {
      throw error;
    }
  });
}

exports.Kerberos = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `kerberos` not found. Please install it to enable kerberos authentication'));

function getKerberos() {
  try {
    // Ensure you always wrap an optional require in the try block NODE-3199
    exports.Kerberos = __webpack_require__(3548);
    return exports.Kerberos;
  } catch (_unused) {
    return exports.Kerberos;
  }
}

exports.getKerberos = getKerberos;
exports.ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression'));

function getZstdLibrary() {
  try {
    exports.ZStandard = __webpack_require__(8557);
    return exports.ZStandard;
  } catch (_unused2) {
    return exports.ZStandard;
  }
}

exports.getZstdLibrary = getZstdLibrary;

function getAwsCredentialProvider() {
  try {
    // Ensure you always wrap an optional require in the try block NODE-3199
    var credentialProvider = __webpack_require__(4753);

    return credentialProvider;
  } catch (_unused3) {
    return makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `@aws-sdk/credential-providers` not found.' + ' Please install it to enable getting aws credentials via the official sdk.'));
  }
}

exports.getAwsCredentialProvider = getAwsCredentialProvider;

function getSnappy() {
  try {
    // Ensure you always wrap an optional require in the try block NODE-3199
    var value = __webpack_require__(2935);

    return value;
  } catch (cause) {
    var kModuleError = new error_1.MongoMissingDependencyError('Optional module `snappy` not found. Please install it to enable snappy compression', {
      cause: cause
    });
    return {
      kModuleError: kModuleError
    };
  }
}

exports.getSnappy = getSnappy;
exports.saslprep = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `saslprep` not found.' + ' Please install it to enable Stringprep Profile for User Names and Passwords'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.saslprep = __webpack_require__(2066);
} catch (_unused4) {} // eslint-disable-line


exports.aws4 = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `aws4` not found. Please install it to enable AWS authentication'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.aws4 = __webpack_require__(9673);
} catch (_unused5) {} // eslint-disable-line

/** @public */


exports.AutoEncryptionLoggerLevel = Object.freeze({
  FatalError: 0,
  Error: 1,
  Warning: 2,
  Info: 3,
  Trace: 4
});

/***/ }),

/***/ 816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable @typescript-eslint/no-var-requires */

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Encrypter = void 0;

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_client_1 = __webpack_require__(3094);

var utils_1 = __webpack_require__(672);

var AutoEncrypterClass;
/** @internal */

var kInternalClient = Symbol('internalClient');
/** @internal */

var Encrypter = /*#__PURE__*/function () {
  function Encrypter(client, uri, options) {
    _classCallCheck(this, Encrypter);

    if (_typeof(options.autoEncryption) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
    } // initialize to null, if we call getInternalClient, we may set this it is important to not overwrite those function calls.


    this[kInternalClient] = null;
    this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
    this.needsConnecting = false;

    if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = client;
    } else if (options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
    }

    if (this.bypassAutoEncryption) {
      options.autoEncryption.metadataClient = undefined;
    } else if (options.maxPoolSize === 0) {
      options.autoEncryption.metadataClient = client;
    } else {
      options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
    }

    if (options.proxyHost) {
      options.autoEncryption.proxyOptions = {
        proxyHost: options.proxyHost,
        proxyPort: options.proxyPort,
        proxyUsername: options.proxyUsername,
        proxyPassword: options.proxyPassword
      };
    }

    this.autoEncrypter = new AutoEncrypterClass(client, options.autoEncryption);
  }

  _createClass(Encrypter, [{
    key: "getInternalClient",
    value: function getInternalClient(client, uri, options) {
      // TODO(NODE-4144): Remove new variable for type narrowing
      var internalClient = this[kInternalClient];

      if (internalClient == null) {
        var clonedOptions = {};

        for (var _i = 0, _arr = [].concat(_toConsumableArray(Object.getOwnPropertyNames(options)), _toConsumableArray(Object.getOwnPropertySymbols(options))); _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].includes(key)) continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }

        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
        this[kInternalClient] = internalClient;

        var _iterator = _createForOfIteratorHelper(constants_1.MONGO_CLIENT_EVENTS),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var eventName = _step.value;

            var _iterator2 = _createForOfIteratorHelper(client.listeners(eventName)),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var listener = _step2.value;
                internalClient.on(eventName, listener);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        client.on('newListener', function (eventName, listener) {
          var _internalClient;

          (_internalClient = internalClient) === null || _internalClient === void 0 ? void 0 : _internalClient.on(eventName, listener);
        });
        this.needsConnecting = true;
      }

      return internalClient;
    }
  }, {
    key: "connectInternalClient",
    value: function () {
      var _connectInternalClient = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var internalClient;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // TODO(NODE-4144): Remove new variable for type narrowing
              internalClient = this[kInternalClient];

              if (!(this.needsConnecting && internalClient != null)) {
                _context.next = 5;
                break;
              }

              this.needsConnecting = false;
              _context.next = 5;
              return internalClient.connect();

            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function connectInternalClient() {
        return _connectInternalClient.apply(this, arguments);
      }

      return connectInternalClient;
    }()
  }, {
    key: "close",
    value: function close(client, force, callback) {
      var _this = this;

      this.autoEncrypter.teardown(!!force, function (e) {
        var internalClient = _this[kInternalClient];

        if (internalClient != null && client !== internalClient) {
          internalClient.close(force).then(function () {
            return callback();
          }, function (error) {
            return callback(error);
          });
          return;
        }

        callback(e);
      });
    }
  }], [{
    key: "checkForMongoCrypt",
    value: function checkForMongoCrypt() {
      var mongodbClientEncryption = (0, utils_1.getMongoDBClientEncryption)();

      if (mongodbClientEncryption == null) {
        throw new error_1.MongoMissingDependencyError('Auto-encryption requested, but the module is not installed. ' + 'Please add `mongodb-client-encryption` as a dependency of your project');
      }

      AutoEncrypterClass = mongodbClientEncryption.extension(__webpack_require__(1051)).AutoEncrypter;
    }
  }]);

  return Encrypter;
}();

exports.Encrypter = Encrypter;

/***/ }),

/***/ 9525:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableReadError = exports.isRetryableWriteError = exports.needsRetryableWriteLabel = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
/** @internal */

var kErrorLabels = Symbol('errorLabels');
/**
 * @internal
 * The legacy error message from the server that indicates the node is not a writable primary
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp('not master', 'i');
/**
 * @internal
 * The legacy error message from the server that indicates the node is not a primary or secondary
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp('not master or secondary', 'i');
/**
 * @internal
 * The error message from the server that indicates the node is recovering
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp('node is recovering', 'i');
/** @internal MongoDB Error Codes */

exports.MONGODB_ERROR_CODES = Object.freeze({
  HostUnreachable: 6,
  HostNotFound: 7,
  NetworkTimeout: 89,
  ShutdownInProgress: 91,
  PrimarySteppedDown: 189,
  ExceededTimeLimit: 262,
  SocketException: 9001,
  NotWritablePrimary: 10107,
  InterruptedAtShutdown: 11600,
  InterruptedDueToReplStateChange: 11602,
  NotPrimaryNoSecondaryOk: 13435,
  NotPrimaryOrSecondary: 13436,
  StaleShardVersion: 63,
  StaleEpoch: 150,
  StaleConfig: 13388,
  RetryChangeStream: 234,
  FailedToSatisfyReadPreference: 133,
  CursorNotFound: 43,
  LegacyNotPrimary: 10058,
  WriteConcernFailed: 64,
  NamespaceNotFound: 26,
  IllegalOperation: 20,
  MaxTimeMSExpired: 50,
  UnknownReplWriteConcern: 79,
  UnsatisfiableWriteConcern: 100,
  Reauthenticate: 391
}); // From spec@https://github.com/mongodb/specifications/blob/f93d78191f3db2898a59013a7ed5650352ef6da8/source/change-streams/change-streams.rst#resumable-error

exports.GET_MORE_RESUMABLE_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.ExceededTimeLimit, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary, exports.MONGODB_ERROR_CODES.StaleShardVersion, exports.MONGODB_ERROR_CODES.StaleEpoch, exports.MONGODB_ERROR_CODES.StaleConfig, exports.MONGODB_ERROR_CODES.RetryChangeStream, exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference, exports.MONGODB_ERROR_CODES.CursorNotFound]);
/** @public */

exports.MongoErrorLabel = Object.freeze({
  RetryableWriteError: 'RetryableWriteError',
  TransientTransactionError: 'TransientTransactionError',
  UnknownTransactionCommitResult: 'UnknownTransactionCommitResult',
  ResumableChangeStreamError: 'ResumableChangeStreamError',
  HandshakeError: 'HandshakeError',
  ResetPool: 'ResetPool',
  InterruptInUseConnections: 'InterruptInUseConnections',
  NoWritesPerformed: 'NoWritesPerformed'
});

function isAggregateError(e) {
  return 'errors' in e && Array.isArray(e.errors);
}
/**
 * @public
 * @category Error
 *
 * @privateRemarks
 * mongodb-client-encryption has a dependency on this error, it uses the constructor with a string argument
 */


var MongoError = /*#__PURE__*/function (_Error) {
  _inherits(MongoError, _Error);

  var _super = _createSuper(MongoError);

  function MongoError(message) {
    var _this;

    _classCallCheck(this, MongoError);

    _this = _super.call(this, MongoError.buildErrorMessage(message));

    if (message instanceof Error) {
      _this.cause = message;
    }

    _this[kErrorLabels] = new Set();
    return _this;
  }
  /** @internal */


  _createClass(MongoError, [{
    key: "name",
    get: function get() {
      return 'MongoError';
    }
    /** Legacy name for server error responses */

  }, {
    key: "errmsg",
    get: function get() {
      return this.message;
    }
    /**
     * Checks the error to see if it has an error label
     *
     * @param label - The error label to check for
     * @returns returns true if the error has the provided error label
     */

  }, {
    key: "hasErrorLabel",
    value: function hasErrorLabel(label) {
      return this[kErrorLabels].has(label);
    }
  }, {
    key: "addErrorLabel",
    value: function addErrorLabel(label) {
      this[kErrorLabels].add(label);
    }
  }, {
    key: "errorLabels",
    get: function get() {
      return Array.from(this[kErrorLabels]);
    }
  }], [{
    key: "buildErrorMessage",
    value: function buildErrorMessage(e) {
      if (typeof e === 'string') {
        return e;
      }

      if (isAggregateError(e) && e.message.length === 0) {
        return e.errors.length === 0 ? 'AggregateError has an empty errors array. Please check the `cause` property for more information.' : e.errors.map(function (_ref) {
          var message = _ref.message;
          return message;
        }).join(', ');
      }

      return e.message;
    }
  }]);

  return MongoError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.MongoError = MongoError;
/**
 * An error coming from the mongo server
 *
 * @public
 * @category Error
 */

var MongoServerError = /*#__PURE__*/function (_MongoError) {
  _inherits(MongoServerError, _MongoError);

  var _super2 = _createSuper(MongoServerError);

  function MongoServerError(message) {
    var _this2;

    _classCallCheck(this, MongoServerError);

    _this2 = _super2.call(this, message.message || message.errmsg || message.$err || 'n/a');

    if (message.errorLabels) {
      _this2[kErrorLabels] = new Set(message.errorLabels);
    }

    for (var name in message) {
      if (name !== 'errorLabels' && name !== 'errmsg' && name !== 'message') _this2[name] = message[name];
    }

    return _this2;
  }

  _createClass(MongoServerError, [{
    key: "name",
    get: function get() {
      return 'MongoServerError';
    }
  }]);

  return MongoServerError;
}(MongoError);

exports.MongoServerError = MongoServerError;
/**
 * An error generated by the driver
 *
 * @public
 * @category Error
 */

var MongoDriverError = /*#__PURE__*/function (_MongoError2) {
  _inherits(MongoDriverError, _MongoError2);

  var _super3 = _createSuper(MongoDriverError);

  function MongoDriverError(message) {
    _classCallCheck(this, MongoDriverError);

    return _super3.call(this, message);
  }

  _createClass(MongoDriverError, [{
    key: "name",
    get: function get() {
      return 'MongoDriverError';
    }
  }]);

  return MongoDriverError;
}(MongoError);

exports.MongoDriverError = MongoDriverError;
/**
 * An error generated when the driver API is used incorrectly
 *
 * @privateRemarks
 * Should **never** be directly instantiated
 *
 * @public
 * @category Error
 */

var MongoAPIError = /*#__PURE__*/function (_MongoDriverError) {
  _inherits(MongoAPIError, _MongoDriverError);

  var _super4 = _createSuper(MongoAPIError);

  function MongoAPIError(message) {
    _classCallCheck(this, MongoAPIError);

    return _super4.call(this, message);
  }

  _createClass(MongoAPIError, [{
    key: "name",
    get: function get() {
      return 'MongoAPIError';
    }
  }]);

  return MongoAPIError;
}(MongoDriverError);

exports.MongoAPIError = MongoAPIError;
/**
 * An error generated when the driver encounters unexpected input
 * or reaches an unexpected/invalid internal state
 *
 * @privateRemarks
 * Should **never** be directly instantiated.
 *
 * @public
 * @category Error
 */

var MongoRuntimeError = /*#__PURE__*/function (_MongoDriverError2) {
  _inherits(MongoRuntimeError, _MongoDriverError2);

  var _super5 = _createSuper(MongoRuntimeError);

  function MongoRuntimeError(message) {
    _classCallCheck(this, MongoRuntimeError);

    return _super5.call(this, message);
  }

  _createClass(MongoRuntimeError, [{
    key: "name",
    get: function get() {
      return 'MongoRuntimeError';
    }
  }]);

  return MongoRuntimeError;
}(MongoDriverError);

exports.MongoRuntimeError = MongoRuntimeError;
/**
 * An error generated when a batch command is re-executed after one of the commands in the batch
 * has failed
 *
 * @public
 * @category Error
 */

var MongoBatchReExecutionError = /*#__PURE__*/function (_MongoAPIError) {
  _inherits(MongoBatchReExecutionError, _MongoAPIError);

  var _super6 = _createSuper(MongoBatchReExecutionError);

  function MongoBatchReExecutionError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'This batch has already been executed, create new batch to execute';

    _classCallCheck(this, MongoBatchReExecutionError);

    return _super6.call(this, message);
  }

  _createClass(MongoBatchReExecutionError, [{
    key: "name",
    get: function get() {
      return 'MongoBatchReExecutionError';
    }
  }]);

  return MongoBatchReExecutionError;
}(MongoAPIError);

exports.MongoBatchReExecutionError = MongoBatchReExecutionError;
/**
 * An error generated when the driver fails to decompress
 * data received from the server.
 *
 * @public
 * @category Error
 */

var MongoDecompressionError = /*#__PURE__*/function (_MongoRuntimeError) {
  _inherits(MongoDecompressionError, _MongoRuntimeError);

  var _super7 = _createSuper(MongoDecompressionError);

  function MongoDecompressionError(message) {
    _classCallCheck(this, MongoDecompressionError);

    return _super7.call(this, message);
  }

  _createClass(MongoDecompressionError, [{
    key: "name",
    get: function get() {
      return 'MongoDecompressionError';
    }
  }]);

  return MongoDecompressionError;
}(MongoRuntimeError);

exports.MongoDecompressionError = MongoDecompressionError;
/**
 * An error thrown when the user attempts to operate on a database or collection through a MongoClient
 * that has not yet successfully called the "connect" method
 *
 * @public
 * @category Error
 */

var MongoNotConnectedError = /*#__PURE__*/function (_MongoAPIError2) {
  _inherits(MongoNotConnectedError, _MongoAPIError2);

  var _super8 = _createSuper(MongoNotConnectedError);

  function MongoNotConnectedError(message) {
    _classCallCheck(this, MongoNotConnectedError);

    return _super8.call(this, message);
  }

  _createClass(MongoNotConnectedError, [{
    key: "name",
    get: function get() {
      return 'MongoNotConnectedError';
    }
  }]);

  return MongoNotConnectedError;
}(MongoAPIError);

exports.MongoNotConnectedError = MongoNotConnectedError;
/**
 * An error generated when the user makes a mistake in the usage of transactions.
 * (e.g. attempting to commit a transaction with a readPreference other than primary)
 *
 * @public
 * @category Error
 */

var MongoTransactionError = /*#__PURE__*/function (_MongoAPIError3) {
  _inherits(MongoTransactionError, _MongoAPIError3);

  var _super9 = _createSuper(MongoTransactionError);

  function MongoTransactionError(message) {
    _classCallCheck(this, MongoTransactionError);

    return _super9.call(this, message);
  }

  _createClass(MongoTransactionError, [{
    key: "name",
    get: function get() {
      return 'MongoTransactionError';
    }
  }]);

  return MongoTransactionError;
}(MongoAPIError);

exports.MongoTransactionError = MongoTransactionError;
/**
 * An error generated when the user attempts to operate
 * on a session that has expired or has been closed.
 *
 * @public
 * @category Error
 */

var MongoExpiredSessionError = /*#__PURE__*/function (_MongoAPIError4) {
  _inherits(MongoExpiredSessionError, _MongoAPIError4);

  var _super10 = _createSuper(MongoExpiredSessionError);

  function MongoExpiredSessionError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cannot use a session that has ended';

    _classCallCheck(this, MongoExpiredSessionError);

    return _super10.call(this, message);
  }

  _createClass(MongoExpiredSessionError, [{
    key: "name",
    get: function get() {
      return 'MongoExpiredSessionError';
    }
  }]);

  return MongoExpiredSessionError;
}(MongoAPIError);

exports.MongoExpiredSessionError = MongoExpiredSessionError;
/**
 * A error generated when the user attempts to authenticate
 * via Kerberos, but fails to connect to the Kerberos client.
 *
 * @public
 * @category Error
 */

var MongoKerberosError = /*#__PURE__*/function (_MongoRuntimeError2) {
  _inherits(MongoKerberosError, _MongoRuntimeError2);

  var _super11 = _createSuper(MongoKerberosError);

  function MongoKerberosError(message) {
    _classCallCheck(this, MongoKerberosError);

    return _super11.call(this, message);
  }

  _createClass(MongoKerberosError, [{
    key: "name",
    get: function get() {
      return 'MongoKerberosError';
    }
  }]);

  return MongoKerberosError;
}(MongoRuntimeError);

exports.MongoKerberosError = MongoKerberosError;
/**
 * A error generated when the user attempts to authenticate
 * via AWS, but fails
 *
 * @public
 * @category Error
 */

var MongoAWSError = /*#__PURE__*/function (_MongoRuntimeError3) {
  _inherits(MongoAWSError, _MongoRuntimeError3);

  var _super12 = _createSuper(MongoAWSError);

  function MongoAWSError(message) {
    _classCallCheck(this, MongoAWSError);

    return _super12.call(this, message);
  }

  _createClass(MongoAWSError, [{
    key: "name",
    get: function get() {
      return 'MongoAWSError';
    }
  }]);

  return MongoAWSError;
}(MongoRuntimeError);

exports.MongoAWSError = MongoAWSError;
/**
 * A error generated when the user attempts to authenticate
 * via Azure, but fails.
 *
 * @public
 * @category Error
 */

var MongoAzureError = /*#__PURE__*/function (_MongoRuntimeError4) {
  _inherits(MongoAzureError, _MongoRuntimeError4);

  var _super13 = _createSuper(MongoAzureError);

  function MongoAzureError(message) {
    _classCallCheck(this, MongoAzureError);

    return _super13.call(this, message);
  }

  _createClass(MongoAzureError, [{
    key: "name",
    get: function get() {
      return 'MongoAzureError';
    }
  }]);

  return MongoAzureError;
}(MongoRuntimeError);

exports.MongoAzureError = MongoAzureError;
/**
 * An error generated when a ChangeStream operation fails to execute.
 *
 * @public
 * @category Error
 */

var MongoChangeStreamError = /*#__PURE__*/function (_MongoRuntimeError5) {
  _inherits(MongoChangeStreamError, _MongoRuntimeError5);

  var _super14 = _createSuper(MongoChangeStreamError);

  function MongoChangeStreamError(message) {
    _classCallCheck(this, MongoChangeStreamError);

    return _super14.call(this, message);
  }

  _createClass(MongoChangeStreamError, [{
    key: "name",
    get: function get() {
      return 'MongoChangeStreamError';
    }
  }]);

  return MongoChangeStreamError;
}(MongoRuntimeError);

exports.MongoChangeStreamError = MongoChangeStreamError;
/**
 * An error thrown when the user calls a function or method not supported on a tailable cursor
 *
 * @public
 * @category Error
 */

var MongoTailableCursorError = /*#__PURE__*/function (_MongoAPIError5) {
  _inherits(MongoTailableCursorError, _MongoAPIError5);

  var _super15 = _createSuper(MongoTailableCursorError);

  function MongoTailableCursorError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Tailable cursor does not support this operation';

    _classCallCheck(this, MongoTailableCursorError);

    return _super15.call(this, message);
  }

  _createClass(MongoTailableCursorError, [{
    key: "name",
    get: function get() {
      return 'MongoTailableCursorError';
    }
  }]);

  return MongoTailableCursorError;
}(MongoAPIError);

exports.MongoTailableCursorError = MongoTailableCursorError;
/** An error generated when a GridFSStream operation fails to execute.
 *
 * @public
 * @category Error
 */

var MongoGridFSStreamError = /*#__PURE__*/function (_MongoRuntimeError6) {
  _inherits(MongoGridFSStreamError, _MongoRuntimeError6);

  var _super16 = _createSuper(MongoGridFSStreamError);

  function MongoGridFSStreamError(message) {
    _classCallCheck(this, MongoGridFSStreamError);

    return _super16.call(this, message);
  }

  _createClass(MongoGridFSStreamError, [{
    key: "name",
    get: function get() {
      return 'MongoGridFSStreamError';
    }
  }]);

  return MongoGridFSStreamError;
}(MongoRuntimeError);

exports.MongoGridFSStreamError = MongoGridFSStreamError;
/**
 * An error generated when a malformed or invalid chunk is
 * encountered when reading from a GridFSStream.
 *
 * @public
 * @category Error
 */

var MongoGridFSChunkError = /*#__PURE__*/function (_MongoRuntimeError7) {
  _inherits(MongoGridFSChunkError, _MongoRuntimeError7);

  var _super17 = _createSuper(MongoGridFSChunkError);

  function MongoGridFSChunkError(message) {
    _classCallCheck(this, MongoGridFSChunkError);

    return _super17.call(this, message);
  }

  _createClass(MongoGridFSChunkError, [{
    key: "name",
    get: function get() {
      return 'MongoGridFSChunkError';
    }
  }]);

  return MongoGridFSChunkError;
}(MongoRuntimeError);

exports.MongoGridFSChunkError = MongoGridFSChunkError;
/**
 * An error generated when a **parsable** unexpected response comes from the server.
 * This is generally an error where the driver in a state expecting a certain behavior to occur in
 * the next message from MongoDB but it receives something else.
 * This error **does not** represent an issue with wire message formatting.
 *
 * #### Example
 * When an operation fails, it is the driver's job to retry it. It must perform serverSelection
 * again to make sure that it attempts the operation against a server in a good state. If server
 * selection returns a server that does not support retryable operations, this error is used.
 * This scenario is unlikely as retryable support would also have been determined on the first attempt
 * but it is possible the state change could report a selectable server that does not support retries.
 *
 * @public
 * @category Error
 */

var MongoUnexpectedServerResponseError = /*#__PURE__*/function (_MongoRuntimeError8) {
  _inherits(MongoUnexpectedServerResponseError, _MongoRuntimeError8);

  var _super18 = _createSuper(MongoUnexpectedServerResponseError);

  function MongoUnexpectedServerResponseError(message) {
    _classCallCheck(this, MongoUnexpectedServerResponseError);

    return _super18.call(this, message);
  }

  _createClass(MongoUnexpectedServerResponseError, [{
    key: "name",
    get: function get() {
      return 'MongoUnexpectedServerResponseError';
    }
  }]);

  return MongoUnexpectedServerResponseError;
}(MongoRuntimeError);

exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
/**
 * An error thrown when the user attempts to add options to a cursor that has already been
 * initialized
 *
 * @public
 * @category Error
 */

var MongoCursorInUseError = /*#__PURE__*/function (_MongoAPIError6) {
  _inherits(MongoCursorInUseError, _MongoAPIError6);

  var _super19 = _createSuper(MongoCursorInUseError);

  function MongoCursorInUseError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cursor is already initialized';

    _classCallCheck(this, MongoCursorInUseError);

    return _super19.call(this, message);
  }

  _createClass(MongoCursorInUseError, [{
    key: "name",
    get: function get() {
      return 'MongoCursorInUseError';
    }
  }]);

  return MongoCursorInUseError;
}(MongoAPIError);

exports.MongoCursorInUseError = MongoCursorInUseError;
/**
 * An error generated when an attempt is made to operate
 * on a closed/closing server.
 *
 * @public
 * @category Error
 */

var MongoServerClosedError = /*#__PURE__*/function (_MongoAPIError7) {
  _inherits(MongoServerClosedError, _MongoAPIError7);

  var _super20 = _createSuper(MongoServerClosedError);

  function MongoServerClosedError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Server is closed';

    _classCallCheck(this, MongoServerClosedError);

    return _super20.call(this, message);
  }

  _createClass(MongoServerClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoServerClosedError';
    }
  }]);

  return MongoServerClosedError;
}(MongoAPIError);

exports.MongoServerClosedError = MongoServerClosedError;
/**
 * An error thrown when an attempt is made to read from a cursor that has been exhausted
 *
 * @public
 * @category Error
 */

var MongoCursorExhaustedError = /*#__PURE__*/function (_MongoAPIError8) {
  _inherits(MongoCursorExhaustedError, _MongoAPIError8);

  var _super21 = _createSuper(MongoCursorExhaustedError);

  function MongoCursorExhaustedError(message) {
    _classCallCheck(this, MongoCursorExhaustedError);

    return _super21.call(this, message || 'Cursor is exhausted');
  }

  _createClass(MongoCursorExhaustedError, [{
    key: "name",
    get: function get() {
      return 'MongoCursorExhaustedError';
    }
  }]);

  return MongoCursorExhaustedError;
}(MongoAPIError);

exports.MongoCursorExhaustedError = MongoCursorExhaustedError;
/**
 * An error generated when an attempt is made to operate on a
 * dropped, or otherwise unavailable, database.
 *
 * @public
 * @category Error
 */

var MongoTopologyClosedError = /*#__PURE__*/function (_MongoAPIError9) {
  _inherits(MongoTopologyClosedError, _MongoAPIError9);

  var _super22 = _createSuper(MongoTopologyClosedError);

  function MongoTopologyClosedError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Topology is closed';

    _classCallCheck(this, MongoTopologyClosedError);

    return _super22.call(this, message);
  }

  _createClass(MongoTopologyClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoTopologyClosedError';
    }
  }]);

  return MongoTopologyClosedError;
}(MongoAPIError);

exports.MongoTopologyClosedError = MongoTopologyClosedError;
/** @internal */

var kBeforeHandshake = Symbol('beforeHandshake');

function isNetworkErrorBeforeHandshake(err) {
  return err[kBeforeHandshake] === true;
}

exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;
/**
 * An error indicating an issue with the network, including TCP errors and timeouts.
 * @public
 * @category Error
 */

var MongoNetworkError = /*#__PURE__*/function (_MongoError3) {
  _inherits(MongoNetworkError, _MongoError3);

  var _super23 = _createSuper(MongoNetworkError);

  function MongoNetworkError(message, options) {
    var _this3;

    _classCallCheck(this, MongoNetworkError);

    _this3 = _super23.call(this, message);

    if (options && typeof options.beforeHandshake === 'boolean') {
      _this3[kBeforeHandshake] = options.beforeHandshake;
    }

    return _this3;
  }

  _createClass(MongoNetworkError, [{
    key: "name",
    get: function get() {
      return 'MongoNetworkError';
    }
  }]);

  return MongoNetworkError;
}(MongoError);

exports.MongoNetworkError = MongoNetworkError;
/**
 * An error indicating a network timeout occurred
 * @public
 * @category Error
 *
 * @privateRemarks
 * mongodb-client-encryption has a dependency on this error with an instanceof check
 */

var MongoNetworkTimeoutError = /*#__PURE__*/function (_MongoNetworkError) {
  _inherits(MongoNetworkTimeoutError, _MongoNetworkError);

  var _super24 = _createSuper(MongoNetworkTimeoutError);

  function MongoNetworkTimeoutError(message, options) {
    _classCallCheck(this, MongoNetworkTimeoutError);

    return _super24.call(this, message, options);
  }

  _createClass(MongoNetworkTimeoutError, [{
    key: "name",
    get: function get() {
      return 'MongoNetworkTimeoutError';
    }
  }]);

  return MongoNetworkTimeoutError;
}(MongoNetworkError);

exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
/**
 * An error used when attempting to parse a value (like a connection string)
 * @public
 * @category Error
 */

var MongoParseError = /*#__PURE__*/function (_MongoDriverError3) {
  _inherits(MongoParseError, _MongoDriverError3);

  var _super25 = _createSuper(MongoParseError);

  function MongoParseError(message) {
    _classCallCheck(this, MongoParseError);

    return _super25.call(this, message);
  }

  _createClass(MongoParseError, [{
    key: "name",
    get: function get() {
      return 'MongoParseError';
    }
  }]);

  return MongoParseError;
}(MongoDriverError);

exports.MongoParseError = MongoParseError;
/**
 * An error generated when the user supplies malformed or unexpected arguments
 * or when a required argument or field is not provided.
 *
 *
 * @public
 * @category Error
 */

var MongoInvalidArgumentError = /*#__PURE__*/function (_MongoAPIError10) {
  _inherits(MongoInvalidArgumentError, _MongoAPIError10);

  var _super26 = _createSuper(MongoInvalidArgumentError);

  function MongoInvalidArgumentError(message) {
    _classCallCheck(this, MongoInvalidArgumentError);

    return _super26.call(this, message);
  }

  _createClass(MongoInvalidArgumentError, [{
    key: "name",
    get: function get() {
      return 'MongoInvalidArgumentError';
    }
  }]);

  return MongoInvalidArgumentError;
}(MongoAPIError);

exports.MongoInvalidArgumentError = MongoInvalidArgumentError;
/**
 * An error generated when a feature that is not enabled or allowed for the current server
 * configuration is used
 *
 *
 * @public
 * @category Error
 */

var MongoCompatibilityError = /*#__PURE__*/function (_MongoAPIError11) {
  _inherits(MongoCompatibilityError, _MongoAPIError11);

  var _super27 = _createSuper(MongoCompatibilityError);

  function MongoCompatibilityError(message) {
    _classCallCheck(this, MongoCompatibilityError);

    return _super27.call(this, message);
  }

  _createClass(MongoCompatibilityError, [{
    key: "name",
    get: function get() {
      return 'MongoCompatibilityError';
    }
  }]);

  return MongoCompatibilityError;
}(MongoAPIError);

exports.MongoCompatibilityError = MongoCompatibilityError;
/**
 * An error generated when the user fails to provide authentication credentials before attempting
 * to connect to a mongo server instance.
 *
 *
 * @public
 * @category Error
 */

var MongoMissingCredentialsError = /*#__PURE__*/function (_MongoAPIError12) {
  _inherits(MongoMissingCredentialsError, _MongoAPIError12);

  var _super28 = _createSuper(MongoMissingCredentialsError);

  function MongoMissingCredentialsError(message) {
    _classCallCheck(this, MongoMissingCredentialsError);

    return _super28.call(this, message);
  }

  _createClass(MongoMissingCredentialsError, [{
    key: "name",
    get: function get() {
      return 'MongoMissingCredentialsError';
    }
  }]);

  return MongoMissingCredentialsError;
}(MongoAPIError);

exports.MongoMissingCredentialsError = MongoMissingCredentialsError;
/**
 * An error generated when a required module or dependency is not present in the local environment
 *
 * @public
 * @category Error
 */

var MongoMissingDependencyError = /*#__PURE__*/function (_MongoAPIError13) {
  _inherits(MongoMissingDependencyError, _MongoAPIError13);

  var _super29 = _createSuper(MongoMissingDependencyError);

  function MongoMissingDependencyError(message) {
    var _this4;

    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        cause = _ref2.cause;

    _classCallCheck(this, MongoMissingDependencyError);

    _this4 = _super29.call(this, message);
    if (cause) _this4.cause = cause;
    return _this4;
  }

  _createClass(MongoMissingDependencyError, [{
    key: "name",
    get: function get() {
      return 'MongoMissingDependencyError';
    }
  }]);

  return MongoMissingDependencyError;
}(MongoAPIError);

exports.MongoMissingDependencyError = MongoMissingDependencyError;
/**
 * An error signifying a general system issue
 * @public
 * @category Error
 */

var MongoSystemError = /*#__PURE__*/function (_MongoError4) {
  _inherits(MongoSystemError, _MongoError4);

  var _super30 = _createSuper(MongoSystemError);

  function MongoSystemError(message, reason) {
    var _reason$error;

    var _this5;

    _classCallCheck(this, MongoSystemError);

    if (reason && reason.error) {
      _this5 = _super30.call(this, reason.error.message || reason.error);
    } else {
      _this5 = _super30.call(this, message);
    }

    if (reason) {
      _this5.reason = reason;
    }

    _this5.code = (_reason$error = reason.error) === null || _reason$error === void 0 ? void 0 : _reason$error.code;
    return _possibleConstructorReturn(_this5);
  }

  _createClass(MongoSystemError, [{
    key: "name",
    get: function get() {
      return 'MongoSystemError';
    }
  }]);

  return MongoSystemError;
}(MongoError);

exports.MongoSystemError = MongoSystemError;
/**
 * An error signifying a client-side server selection error
 * @public
 * @category Error
 */

var MongoServerSelectionError = /*#__PURE__*/function (_MongoSystemError) {
  _inherits(MongoServerSelectionError, _MongoSystemError);

  var _super31 = _createSuper(MongoServerSelectionError);

  function MongoServerSelectionError(message, reason) {
    _classCallCheck(this, MongoServerSelectionError);

    return _super31.call(this, message, reason);
  }

  _createClass(MongoServerSelectionError, [{
    key: "name",
    get: function get() {
      return 'MongoServerSelectionError';
    }
  }]);

  return MongoServerSelectionError;
}(MongoSystemError);

exports.MongoServerSelectionError = MongoServerSelectionError;

function makeWriteConcernResultObject(input) {
  var output = Object.assign({}, input);

  if (output.ok === 0) {
    output.ok = 1;
    delete output.errmsg;
    delete output.code;
    delete output.codeName;
  }

  return output;
}
/**
 * An error thrown when the server reports a writeConcernError
 * @public
 * @category Error
 */


var MongoWriteConcernError = /*#__PURE__*/function (_MongoServerError) {
  _inherits(MongoWriteConcernError, _MongoServerError);

  var _super32 = _createSuper(MongoWriteConcernError);

  function MongoWriteConcernError(message, result) {
    var _this6;

    _classCallCheck(this, MongoWriteConcernError);

    if (result && Array.isArray(result.errorLabels)) {
      message.errorLabels = result.errorLabels;
    }

    _this6 = _super32.call(this, message);
    _this6.errInfo = message.errInfo;

    if (result != null) {
      _this6.result = makeWriteConcernResultObject(result);
    }

    return _this6;
  }

  _createClass(MongoWriteConcernError, [{
    key: "name",
    get: function get() {
      return 'MongoWriteConcernError';
    }
  }]);

  return MongoWriteConcernError;
}(MongoServerError);

exports.MongoWriteConcernError = MongoWriteConcernError; // https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst#retryable-error

var RETRYABLE_READ_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]); // see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms

var RETRYABLE_WRITE_ERROR_CODES = new Set([].concat(_toConsumableArray(RETRYABLE_READ_ERROR_CODES), [exports.MONGODB_ERROR_CODES.ExceededTimeLimit]));

function needsRetryableWriteLabel(error, maxWireVersion) {
  // pre-4.4 server, then the driver adds an error label for every valid case
  // execute operation will only inspect the label, code/message logic is handled here
  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (error instanceof MongoError) {
    if ((maxWireVersion >= 9 || error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
      // If we already have the error label no need to add it again. 4.4+ servers add the label.
      // In the case where we have a handshake error, need to fall down to the logic checking
      // the codes.
      return false;
    }
  }

  if (error instanceof MongoWriteConcernError) {
    var _ref3, _error$result$code, _error$result;

    return RETRYABLE_WRITE_ERROR_CODES.has((_ref3 = (_error$result$code = (_error$result = error.result) === null || _error$result === void 0 ? void 0 : _error$result.code) !== null && _error$result$code !== void 0 ? _error$result$code : error.code) !== null && _ref3 !== void 0 ? _ref3 : 0);
  }

  if (error instanceof MongoError && typeof error.code === 'number') {
    return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
  }

  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);

  if (isNotWritablePrimaryError) {
    return true;
  }

  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);

  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

exports.needsRetryableWriteLabel = needsRetryableWriteLabel;

function isRetryableWriteError(error) {
  return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError);
}

exports.isRetryableWriteError = isRetryableWriteError;
/** Determines whether an error is something the driver should attempt to retry */

function isRetryableReadError(error) {
  var hasRetryableErrorCode = typeof error.code === 'number' ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;

  if (hasRetryableErrorCode) {
    return true;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);

  if (isNotWritablePrimaryError) {
    return true;
  }

  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);

  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

exports.isRetryableReadError = isRetryableReadError;
var SDAM_RECOVERING_CODES = new Set([exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]);
var SDAM_NOT_PRIMARY_CODES = new Set([exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.LegacyNotPrimary]);
var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.ShutdownInProgress]);

function isRecoveringError(err) {
  if (typeof err.code === 'number') {
    // If any error code exists, we ignore the error.message
    return SDAM_RECOVERING_CODES.has(err.code);
  }

  return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
}

function isNotWritablePrimaryError(err) {
  if (typeof err.code === 'number') {
    // If any error code exists, we ignore the error.message
    return SDAM_NOT_PRIMARY_CODES.has(err.code);
  }

  if (isRecoveringError(err)) {
    return false;
  }

  return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
}

function isNodeShuttingDownError(err) {
  return !!(typeof err.code === 'number' && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
}

exports.isNodeShuttingDownError = isNodeShuttingDownError;
/**
 * Determines whether SDAM can recover from a given error. If it cannot
 * then the pool will be cleared, and server state will completely reset
 * locally.
 *
 * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering
 */

function isSDAMUnrecoverableError(error) {
  // NOTE: null check is here for a strictly pre-CMAP world, a timeout or
  //       close event are considered unrecoverable
  if (error instanceof MongoParseError || error == null) {
    return true;
  }

  return isRecoveringError(error) || isNotWritablePrimaryError(error);
}

exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;

function isNetworkTimeoutError(err) {
  return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
}

exports.isNetworkTimeoutError = isNetworkTimeoutError;

function isResumableError(error, wireVersion) {
  if (error == null || !(error instanceof MongoError)) {
    return false;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (wireVersion != null && wireVersion >= 9) {
    // DRIVERS-1308: For 4.4 drivers running against 4.4 servers, drivers will add a special case to treat the CursorNotFound error code as resumable
    if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
      return true;
    }

    return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
  }

  if (typeof error.code === 'number') {
    return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
  }

  return false;
}

exports.isResumableError = isResumableError;

/***/ }),

/***/ 4969:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Explain = exports.ExplainVerbosity = void 0;

var error_1 = __webpack_require__(9525);
/** @public */


exports.ExplainVerbosity = Object.freeze({
  queryPlanner: 'queryPlanner',
  queryPlannerExtended: 'queryPlannerExtended',
  executionStats: 'executionStats',
  allPlansExecution: 'allPlansExecution'
});
/** @internal */

var Explain = /*#__PURE__*/function () {
  function Explain(verbosity) {
    _classCallCheck(this, Explain);

    if (typeof verbosity === 'boolean') {
      this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
    } else {
      this.verbosity = verbosity;
    }
  }

  _createClass(Explain, null, [{
    key: "fromOptions",
    value: function fromOptions(options) {
      if ((options === null || options === void 0 ? void 0 : options.explain) == null) return;
      var explain = options.explain;

      if (typeof explain === 'boolean' || typeof explain === 'string') {
        return new Explain(explain);
      }

      throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
    }
  }]);

  return Explain;
}();

exports.Explain = Explain;

/***/ }),

/***/ 3353:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucketReadStream = void 0;

var stream_1 = __webpack_require__(2781);

var error_1 = __webpack_require__(9525);
/**
 * A readable stream that enables you to read buffers from GridFS.
 *
 * Do not instantiate this class directly. Use `openDownloadStream()` instead.
 * @public
 */


var GridFSBucketReadStream = /*#__PURE__*/function (_stream_1$Readable) {
  _inherits(GridFSBucketReadStream, _stream_1$Readable);

  var _super = _createSuper(GridFSBucketReadStream);

  /**
   * @param chunks - Handle for chunks collection
   * @param files - Handle for files collection
   * @param readPreference - The read preference to use
   * @param filter - The filter to use to find the file document
   * @internal
   */
  function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
    var _this;

    _classCallCheck(this, GridFSBucketReadStream);

    _this = _super.call(this);
    _this.s = {
      bytesToTrim: 0,
      bytesToSkip: 0,
      bytesRead: 0,
      chunks: chunks,
      expected: 0,
      files: files,
      filter: filter,
      init: false,
      expectedEnd: 0,
      options: _objectSpread({
        start: 0,
        end: 0
      }, options),
      readPreference: readPreference
    };
    return _this;
  }
  /**
   * Reads from the cursor and pushes to the stream.
   * Private Impl, do not call directly
   * @internal
   */


  _createClass(GridFSBucketReadStream, [{
    key: "_read",
    value: function _read() {
      var _this2 = this;

      if (this.destroyed) return;
      waitForFile(this, function () {
        return doRead(_this2);
      });
    }
    /**
     * Sets the 0-based offset in bytes to start streaming from. Throws
     * an error if this stream has entered flowing mode
     * (e.g. if you've already called `on('data')`)
     *
     * @param start - 0-based offset in bytes to start streaming from
     */

  }, {
    key: "start",
    value: function start() {
      var _start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      throwIfInitialized(this);
      this.s.options.start = _start;
      return this;
    }
    /**
     * Sets the 0-based offset in bytes to start streaming from. Throws
     * an error if this stream has entered flowing mode
     * (e.g. if you've already called `on('data')`)
     *
     * @param end - Offset in bytes to stop reading at
     */

  }, {
    key: "end",
    value: function end() {
      var _end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      throwIfInitialized(this);
      this.s.options.end = _end;
      return this;
    }
    /**
     * Marks this stream as aborted (will never push another `data` event)
     * and kills the underlying cursor. Will emit the 'end' event, and then
     * the 'close' event once the cursor is successfully killed.
     */

  }, {
    key: "abort",
    value: function () {
      var _abort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.push(null);
              this.destroyed = true;

              if (!this.s.cursor) {
                _context.next = 11;
                break;
              }

              _context.prev = 3;
              _context.next = 6;
              return this.s.cursor.close();

            case 6:
              _context.prev = 6;
              this.emit(GridFSBucketReadStream.CLOSE);
              return _context.finish(6);

            case 9:
              _context.next = 12;
              break;

            case 11:
              if (!this.s.init) {
                // If not initialized, fire close event because we will never
                // get a cursor
                this.emit(GridFSBucketReadStream.CLOSE);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3,, 6, 9]]);
      }));

      function abort() {
        return _abort.apply(this, arguments);
      }

      return abort;
    }()
  }]);

  return GridFSBucketReadStream;
}(stream_1.Readable);
/**
 * An error occurred
 * @event
 */


GridFSBucketReadStream.ERROR = 'error';
/**
 * Fires when the stream loaded the file document corresponding to the provided id.
 * @event
 */

GridFSBucketReadStream.FILE = 'file';
/**
 * Emitted when a chunk of data is available to be consumed.
 * @event
 */

GridFSBucketReadStream.DATA = 'data';
/**
 * Fired when the stream is exhausted (no more data events).
 * @event
 */

GridFSBucketReadStream.END = 'end';
/**
 * Fired when the stream is exhausted and the underlying cursor is killed
 * @event
 */

GridFSBucketReadStream.CLOSE = 'close';
exports.GridFSBucketReadStream = GridFSBucketReadStream;

function throwIfInitialized(stream) {
  if (stream.s.init) {
    throw new error_1.MongoGridFSStreamError('Options cannot be changed after the stream is initialized');
  }
}

function doRead(stream) {
  if (stream.destroyed) return;
  if (!stream.s.cursor) return;
  if (!stream.s.file) return;

  var handleReadResult = function handleReadResult(_ref) {
    var error = _ref.error,
        doc = _ref.doc;

    if (stream.destroyed) {
      return;
    }

    if (error) {
      stream.emit(GridFSBucketReadStream.ERROR, error);
      return;
    }

    if (!doc) {
      var _stream$s$cursor;

      stream.push(null);
      (_stream$s$cursor = stream.s.cursor) === null || _stream$s$cursor === void 0 ? void 0 : _stream$s$cursor.close().then(function () {
        stream.emit(GridFSBucketReadStream.CLOSE);
      }, function (error) {
        stream.emit(GridFSBucketReadStream.ERROR, error);
      });
      return;
    }

    if (!stream.s.file) return;
    var bytesRemaining = stream.s.file.length - stream.s.bytesRead;
    var expectedN = stream.s.expected++;
    var expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);

    if (doc.n > expectedN) {
      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ChunkIsMissing: Got unexpected n: ".concat(doc.n, ", expected: ").concat(expectedN)));
    }

    if (doc.n < expectedN) {
      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ExtraChunk: Got unexpected n: ".concat(doc.n, ", expected: ").concat(expectedN)));
    }

    var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;

    if (buf.byteLength !== expectedLength) {
      if (bytesRemaining <= 0) {
        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ExtraChunk: Got unexpected n: ".concat(doc.n, ", expected file length ").concat(stream.s.file.length, " bytes but already read ").concat(stream.s.bytesRead, " bytes")));
      }

      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ChunkIsWrongSize: Got unexpected length: ".concat(buf.byteLength, ", expected: ").concat(expectedLength)));
    }

    stream.s.bytesRead += buf.byteLength;

    if (buf.byteLength === 0) {
      return stream.push(null);
    }

    var sliceStart = null;
    var sliceEnd = null;

    if (stream.s.bytesToSkip != null) {
      sliceStart = stream.s.bytesToSkip;
      stream.s.bytesToSkip = 0;
    }

    var atEndOfStream = expectedN === stream.s.expectedEnd - 1;
    var bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;

    if (atEndOfStream && stream.s.bytesToTrim != null) {
      sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
    } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
      sliceEnd = bytesLeftToRead;
    }

    if (sliceStart != null || sliceEnd != null) {
      buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
    }

    stream.push(buf);
    return;
  };

  stream.s.cursor.next().then(function (doc) {
    return handleReadResult({
      error: null,
      doc: doc
    });
  }, function (error) {
    return handleReadResult({
      error: error,
      doc: null
    });
  });
}

function init(stream) {
  var findOneOptions = {};

  if (stream.s.readPreference) {
    findOneOptions.readPreference = stream.s.readPreference;
  }

  if (stream.s.options && stream.s.options.sort) {
    findOneOptions.sort = stream.s.options.sort;
  }

  if (stream.s.options && stream.s.options.skip) {
    findOneOptions.skip = stream.s.options.skip;
  }

  var handleReadResult = function handleReadResult(_ref2) {
    var error = _ref2.error,
        doc = _ref2.doc;

    if (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    if (!doc) {
      var identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
      var errmsg = "FileNotFound: file ".concat(identifier, " was not found"); // TODO(NODE-3483)

      var err = new error_1.MongoRuntimeError(errmsg);
      err.code = 'ENOENT'; // TODO: NODE-3338 set property as part of constructor

      return stream.emit(GridFSBucketReadStream.ERROR, err);
    } // If document is empty, kill the stream immediately and don't
    // execute any reads


    if (doc.length <= 0) {
      stream.push(null);
      return;
    }

    if (stream.destroyed) {
      // If user destroys the stream before we have a cursor, wait
      // until the query is done to say we're 'closed' because we can't
      // cancel a query.
      stream.emit(GridFSBucketReadStream.CLOSE);
      return;
    }

    try {
      stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
    } catch (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    var filter = {
      files_id: doc._id
    }; // Currently (MongoDB 3.4.4) skip function does not support the index,
    // it needs to retrieve all the documents first and then skip them. (CS-25811)
    // As work around we use $gte on the "n" field.

    if (stream.s.options && stream.s.options.start != null) {
      var skip = Math.floor(stream.s.options.start / doc.chunkSize);

      if (skip > 0) {
        filter['n'] = {
          $gte: skip
        };
      }
    }

    stream.s.cursor = stream.s.chunks.find(filter).sort({
      n: 1
    });

    if (stream.s.readPreference) {
      stream.s.cursor.withReadPreference(stream.s.readPreference);
    }

    stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
    stream.s.file = doc;

    try {
      stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
    } catch (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    stream.emit(GridFSBucketReadStream.FILE, doc);
    return;
  };

  stream.s.files.findOne(stream.s.filter, findOneOptions).then(function (doc) {
    return handleReadResult({
      error: null,
      doc: doc
    });
  }, function (error) {
    return handleReadResult({
      error: error,
      doc: null
    });
  });
}

function waitForFile(stream, callback) {
  if (stream.s.file) {
    return callback();
  }

  if (!stream.s.init) {
    init(stream);
    stream.s.init = true;
  }

  stream.once('file', function () {
    callback();
  });
}

function handleStartOption(stream, doc, options) {
  if (options && options.start != null) {
    if (options.start > doc.length) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be more than the length of the file (").concat(doc.length, ")"));
    }

    if (options.start < 0) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be negative"));
    }

    if (options.end != null && options.end < options.start) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be greater than stream end (").concat(options.end, ")"));
    }

    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
    stream.s.expected = Math.floor(options.start / doc.chunkSize);
    return options.start - stream.s.bytesRead;
  }

  throw new error_1.MongoInvalidArgumentError('Start option must be defined');
}

function handleEndOption(stream, doc, cursor, options) {
  if (options && options.end != null) {
    if (options.end > doc.length) {
      throw new error_1.MongoInvalidArgumentError("Stream end (".concat(options.end, ") must not be more than the length of the file (").concat(doc.length, ")"));
    }

    if (options.start == null || options.start < 0) {
      throw new error_1.MongoInvalidArgumentError("Stream end (".concat(options.end, ") must not be negative"));
    }

    var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
    return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
  }

  throw new error_1.MongoInvalidArgumentError('End option must be defined');
}

/***/ }),

/***/ 6947:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucket = void 0;

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var write_concern_1 = __webpack_require__(6916);

var download_1 = __webpack_require__(3353);

var upload_1 = __webpack_require__(7171);

var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
  bucketName: 'fs',
  chunkSizeBytes: 255 * 1024
};
/**
 * Constructor for a streaming GridFS interface
 * @public
 */

var GridFSBucket = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(GridFSBucket, _mongo_types_1$TypedE);

  var _super = _createSuper(GridFSBucket);

  function GridFSBucket(db, options) {
    var _this;

    _classCallCheck(this, GridFSBucket);

    _this = _super.call(this);

    _this.setMaxListeners(0);

    var privateOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_GRIDFS_BUCKET_OPTIONS), options), {}, {
      writeConcern: write_concern_1.WriteConcern.fromOptions(options)
    });

    _this.s = {
      db: db,
      options: privateOptions,
      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),
      _filesCollection: db.collection(privateOptions.bucketName + '.files'),
      checkedIndexes: false,
      calledOpenUploadStream: false
    };
    return _this;
  }
  /**
   * Returns a writable stream (GridFSBucketWriteStream) for writing
   * buffers to GridFS. The stream's 'id' property contains the resulting
   * file's id.
   *
   * @param filename - The value of the 'filename' key in the files doc
   * @param options - Optional settings.
   */


  _createClass(GridFSBucket, [{
    key: "openUploadStream",
    value: function openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, options);
    }
    /**
     * Returns a writable stream (GridFSBucketWriteStream) for writing
     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
     * file's id.
     */

  }, {
    key: "openUploadStreamWithId",
    value: function openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, _objectSpread(_objectSpread({}, options), {}, {
        id: id
      }));
    }
    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */

  }, {
    key: "openDownloadStream",
    value: function openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {
        _id: id
      }, options);
    }
    /**
     * Deletes a file with the given id
     *
     * @param id - The id of the file doc
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
        var _yield$this$s$_filesC, deletedCount;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.s._filesCollection.deleteOne({
                _id: id
              });

            case 2:
              _yield$this$s$_filesC = _context.sent;
              deletedCount = _yield$this$s$_filesC.deletedCount;
              _context.next = 6;
              return this.s._chunksCollection.deleteMany({
                files_id: id
              });

            case 6:
              if (!(deletedCount === 0)) {
                _context.next = 8;
                break;
              }

              throw new error_1.MongoRuntimeError("File not found for id ".concat(id));

            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function _delete(_x) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /** Convenience wrapper around find on the files collection */

  }, {
    key: "find",
    value: function find() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.s._filesCollection.find(filter, options);
    }
    /**
     * Returns a readable stream (GridFSBucketReadStream) for streaming the
     * file with the given name from GridFS. If there are multiple files with
     * the same name, this will stream the most recent file with the given name
     * (as determined by the `uploadDate` field). You can set the `revision`
     * option to change this behavior.
     */

  }, {
    key: "openDownloadStreamByName",
    value: function openDownloadStreamByName(filename, options) {
      var sort = {
        uploadDate: -1
      };
      var skip = undefined;

      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = {
            uploadDate: 1
          };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }

      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {
        filename: filename
      }, _objectSpread(_objectSpread({}, options), {}, {
        sort: sort,
        skip: skip
      }));
    }
    /**
     * Renames the file with the given _id to the given string
     *
     * @param id - the id of the file to rename
     * @param filename - new name for the file
     */

  }, {
    key: "rename",
    value: function () {
      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id, filename) {
        var filter, update, _yield$this$s$_filesC2, matchedCount;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              filter = {
                _id: id
              };
              update = {
                $set: {
                  filename: filename
                }
              };
              _context2.next = 4;
              return this.s._filesCollection.updateOne(filter, update);

            case 4:
              _yield$this$s$_filesC2 = _context2.sent;
              matchedCount = _yield$this$s$_filesC2.matchedCount;

              if (!(matchedCount === 0)) {
                _context2.next = 8;
                break;
              }

              throw new error_1.MongoRuntimeError("File with id ".concat(id, " not found"));

            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function rename(_x2, _x3) {
        return _rename.apply(this, arguments);
      }

      return rename;
    }()
    /** Removes this bucket's files collection, followed by its chunks collection. */

  }, {
    key: "drop",
    value: function () {
      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.s._filesCollection.drop();

            case 2:
              _context3.next = 4;
              return this.s._chunksCollection.drop();

            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function drop() {
        return _drop.apply(this, arguments);
      }

      return drop;
    }()
  }]);

  return GridFSBucket;
}(mongo_types_1.TypedEventEmitter);
/**
 * When the first call to openUploadStream is made, the upload stream will
 * check to see if it needs to create the proper indexes on the chunks and
 * files collections. This event is fired either when 1) it determines that
 * no index creation is necessary, 2) when it successfully creates the
 * necessary indexes.
 * @event
 */


GridFSBucket.INDEX = 'index';
exports.GridFSBucket = GridFSBucket;

/***/ }),

/***/ 7171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucketWriteStream = void 0;

var stream_1 = __webpack_require__(2781);

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var write_concern_1 = __webpack_require__(6916);
/**
 * A writable stream that enables you to write buffers to GridFS.
 *
 * Do not instantiate this class directly. Use `openUploadStream()` instead.
 * @public
 */


var GridFSBucketWriteStream = /*#__PURE__*/function (_stream_1$Writable) {
  _inherits(GridFSBucketWriteStream, _stream_1$Writable);

  var _super = _createSuper(GridFSBucketWriteStream);

  /**
   * @param bucket - Handle for this stream's corresponding bucket
   * @param filename - The value of the 'filename' key in the files doc
   * @param options - Optional settings.
   * @internal
   */
  function GridFSBucketWriteStream(bucket, filename, options) {
    var _options;

    var _this;

    _classCallCheck(this, GridFSBucketWriteStream);

    _this = _super.call(this);
    options = (_options = options) !== null && _options !== void 0 ? _options : {};
    _this.bucket = bucket;
    _this.chunks = bucket.s._chunksCollection;
    _this.filename = filename;
    _this.files = bucket.s._filesCollection;
    _this.options = options;
    _this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern; // Signals the write is all done

    _this.done = false;
    _this.id = options.id ? options.id : new bson_1.ObjectId(); // properly inherit the default chunksize from parent

    _this.chunkSizeBytes = options.chunkSizeBytes || _this.bucket.s.options.chunkSizeBytes;
    _this.bufToStore = Buffer.alloc(_this.chunkSizeBytes);
    _this.length = 0;
    _this.n = 0;
    _this.pos = 0;
    _this.state = {
      streamEnd: false,
      outstandingRequests: 0,
      errored: false,
      aborted: false
    };

    if (!_this.bucket.s.calledOpenUploadStream) {
      _this.bucket.s.calledOpenUploadStream = true;
      checkIndexes(_assertThisInitialized(_this)).then(function () {
        _this.bucket.s.checkedIndexes = true;

        _this.bucket.emit('index');
      }, function () {
        return null;
      });
    }

    return _this;
  }

  _createClass(GridFSBucketWriteStream, [{
    key: "write",
    value: function write(chunk, encodingOrCallback, callback) {
      var _this2 = this;

      var encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;
      callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      return waitForIndexes(this, function () {
        return doWrite(_this2, chunk, encoding, callback);
      });
    }
    /**
     * Places this write stream into an aborted state (all future writes fail)
     * and deletes all chunks that have already been written.
     */

  }, {
    key: "abort",
    value: function () {
      var _abort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.state.streamEnd) {
                _context.next = 2;
                break;
              }

              throw new error_1.MongoAPIError('Cannot abort a stream that has already completed');

            case 2:
              if (!this.state.aborted) {
                _context.next = 4;
                break;
              }

              throw new error_1.MongoAPIError('Cannot call abort() on a stream twice');

            case 4:
              this.state.aborted = true;
              _context.next = 7;
              return this.chunks.deleteMany({
                files_id: this.id
              });

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function abort() {
        return _abort.apply(this, arguments);
      }

      return abort;
    }()
  }, {
    key: "end",
    value: function end(chunkOrCallback, encodingOrCallback, callback) {
      var _this3 = this;

      var chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;
      var encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;
      callback = typeof chunkOrCallback === 'function' ? chunkOrCallback : typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      if (this.state.streamEnd || checkAborted(this, callback)) return this;
      this.state.streamEnd = true;

      if (callback) {
        this.once(GridFSBucketWriteStream.FINISH, function (result) {
          if (callback) callback(undefined, result);
        });
      }

      if (!chunk) {
        waitForIndexes(this, function () {
          return !!writeRemnant(_this3);
        });
        return this;
      }

      this.write(chunk, encoding, function () {
        writeRemnant(_this3);
      });
      return this;
    }
  }]);

  return GridFSBucketWriteStream;
}(stream_1.Writable);
/** @event */


GridFSBucketWriteStream.CLOSE = 'close';
/** @event */

GridFSBucketWriteStream.ERROR = 'error';
/**
 * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.
 * @event
 */

GridFSBucketWriteStream.FINISH = 'finish';
exports.GridFSBucketWriteStream = GridFSBucketWriteStream;

function __handleError(stream, error, callback) {
  if (stream.state.errored) {
    return;
  }

  stream.state.errored = true;

  if (callback) {
    return callback(error);
  }

  stream.emit(GridFSBucketWriteStream.ERROR, error);
}

function createChunkDoc(filesId, n, data) {
  return {
    _id: new bson_1.ObjectId(),
    files_id: filesId,
    n: n,
    data: data
  };
}

function checkChunksIndex(_x) {
  return _checkChunksIndex.apply(this, arguments);
}

function _checkChunksIndex() {
  _checkChunksIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stream) {
    var index, indexes, hasChunksIndex;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          index = {
            files_id: 1,
            n: 1
          };
          _context2.prev = 1;
          _context2.next = 4;
          return stream.chunks.listIndexes().toArray();

        case 4:
          indexes = _context2.sent;
          _context2.next = 14;
          break;

        case 7:
          _context2.prev = 7;
          _context2.t0 = _context2["catch"](1);

          if (!(_context2.t0 instanceof error_1.MongoError && _context2.t0.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound)) {
            _context2.next = 13;
            break;
          }

          indexes = [];
          _context2.next = 14;
          break;

        case 13:
          throw _context2.t0;

        case 14:
          hasChunksIndex = !!indexes.find(function (index) {
            var keys = Object.keys(index.key);

            if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {
              return true;
            }

            return false;
          });

          if (hasChunksIndex) {
            _context2.next = 18;
            break;
          }

          _context2.next = 18;
          return stream.chunks.createIndex(index, _objectSpread(_objectSpread({}, stream.writeConcern), {}, {
            background: true,
            unique: true
          }));

        case 18:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[1, 7]]);
  }));
  return _checkChunksIndex.apply(this, arguments);
}

function checkDone(stream, callback) {
  if (stream.done) return true;

  if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
    // Set done so we do not trigger duplicate createFilesDoc
    stream.done = true; // Create a new files doc

    var filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);

    if (checkAborted(stream, callback)) {
      return false;
    }

    stream.files.insertOne(filesDoc, {
      writeConcern: stream.writeConcern
    }).then(function () {
      stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);
      stream.emit(GridFSBucketWriteStream.CLOSE);
    }, function (error) {
      return __handleError(stream, error, callback);
    });
    return true;
  }

  return false;
}

function checkIndexes(_x2) {
  return _checkIndexes.apply(this, arguments);
}

function _checkIndexes() {
  _checkIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(stream) {
    var doc, index, indexes, hasFileIndex;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return stream.files.findOne({}, {
            projection: {
              _id: 1
            }
          });

        case 2:
          doc = _context3.sent;

          if (!(doc != null)) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return");

        case 5:
          index = {
            filename: 1,
            uploadDate: 1
          };
          _context3.prev = 6;
          _context3.next = 9;
          return stream.files.listIndexes().toArray();

        case 9:
          indexes = _context3.sent;
          _context3.next = 19;
          break;

        case 12:
          _context3.prev = 12;
          _context3.t0 = _context3["catch"](6);

          if (!(_context3.t0 instanceof error_1.MongoError && _context3.t0.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound)) {
            _context3.next = 18;
            break;
          }

          indexes = [];
          _context3.next = 19;
          break;

        case 18:
          throw _context3.t0;

        case 19:
          hasFileIndex = !!indexes.find(function (index) {
            var keys = Object.keys(index.key);

            if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {
              return true;
            }

            return false;
          });

          if (hasFileIndex) {
            _context3.next = 23;
            break;
          }

          _context3.next = 23;
          return stream.files.createIndex(index, {
            background: false
          });

        case 23:
          _context3.next = 25;
          return checkChunksIndex(stream);

        case 25:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[6, 12]]);
  }));
  return _checkIndexes.apply(this, arguments);
}

function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
  var ret = {
    _id: _id,
    length: length,
    chunkSize: chunkSize,
    uploadDate: new Date(),
    filename: filename
  };

  if (contentType) {
    ret.contentType = contentType;
  }

  if (aliases) {
    ret.aliases = aliases;
  }

  if (metadata) {
    ret.metadata = metadata;
  }

  return ret;
}

function doWrite(stream, chunk, encoding, callback) {
  if (checkAborted(stream, callback)) {
    return false;
  }

  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
  stream.length += inputBuf.length; // Input is small enough to fit in our buffer

  if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
    inputBuf.copy(stream.bufToStore, stream.pos);
    stream.pos += inputBuf.length;
    callback && callback(); // Note that we reverse the typical semantics of write's return value
    // to be compatible with node's `.pipe()` function.
    // True means client can keep writing.

    return true;
  } // Otherwise, buffer is too big for current chunk, so we need to flush
  // to MongoDB.


  var inputBufRemaining = inputBuf.length;
  var spaceRemaining = stream.chunkSizeBytes - stream.pos;
  var numToCopy = Math.min(spaceRemaining, inputBuf.length);
  var outstandingRequests = 0;

  var _loop = function _loop() {
    var inputBufPos = inputBuf.length - inputBufRemaining;
    inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
    stream.pos += numToCopy;
    spaceRemaining -= numToCopy;
    var doc;

    if (spaceRemaining === 0) {
      doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
      ++stream.state.outstandingRequests;
      ++outstandingRequests;

      if (checkAborted(stream, callback)) {
        return {
          v: false
        };
      }

      stream.chunks.insertOne(doc, {
        writeConcern: stream.writeConcern
      }).then(function () {
        --stream.state.outstandingRequests;
        --outstandingRequests;

        if (!outstandingRequests) {
          stream.emit('drain', doc);
          callback && callback();
          checkDone(stream);
        }
      }, function (error) {
        return __handleError(stream, error);
      });
      spaceRemaining = stream.chunkSizeBytes;
      stream.pos = 0;
      ++stream.n;
    }

    inputBufRemaining -= numToCopy;
    numToCopy = Math.min(spaceRemaining, inputBufRemaining);
  },
      _ret;

  while (inputBufRemaining > 0) {
    _ret = _loop();
    if (_ret) return _ret.v;
  } // Note that we reverse the typical semantics of write's return value
  // to be compatible with node's `.pipe()` function.
  // False means the client should wait for the 'drain' event.


  return false;
}

function waitForIndexes(stream, callback) {
  if (stream.bucket.s.checkedIndexes) {
    return callback(false);
  }

  stream.bucket.once('index', function () {
    callback(true);
  });
  return true;
}

function writeRemnant(stream, callback) {
  // Buffer is empty, so don't bother to insert
  if (stream.pos === 0) {
    return checkDone(stream, callback);
  }

  ++stream.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs
  // to be.

  var remnant = Buffer.alloc(stream.pos);
  stream.bufToStore.copy(remnant, 0, 0, stream.pos);
  var doc = createChunkDoc(stream.id, stream.n, remnant); // If the stream was aborted, do not write remnant

  if (checkAborted(stream, callback)) {
    return false;
  }

  stream.chunks.insertOne(doc, {
    writeConcern: stream.writeConcern
  }).then(function () {
    --stream.state.outstandingRequests;
    checkDone(stream);
  }, function (error) {
    return __handleError(stream, error);
  });
  return true;
}

function checkAborted(stream, callback) {
  if (stream.state.aborted) {
    if (typeof callback === 'function') {
      // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError
      callback(new error_1.MongoAPIError('Stream has been aborted'));
    }

    return true;
  }

  return false;
}

/***/ }),

/***/ 1051:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AbstractCursor = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoServerSelectionError = exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.MongoBulkWriteError = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = void 0;
exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.AutoEncryptionLoggerLevel = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = void 0;
exports.SrvPollingEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = void 0;

var admin_1 = __webpack_require__(2340);

Object.defineProperty(exports, "Admin", ({
  enumerable: true,
  get: function get() {
    return admin_1.Admin;
  }
}));

var ordered_1 = __webpack_require__(5873);

Object.defineProperty(exports, "OrderedBulkOperation", ({
  enumerable: true,
  get: function get() {
    return ordered_1.OrderedBulkOperation;
  }
}));

var unordered_1 = __webpack_require__(2325);

Object.defineProperty(exports, "UnorderedBulkOperation", ({
  enumerable: true,
  get: function get() {
    return unordered_1.UnorderedBulkOperation;
  }
}));

var change_stream_1 = __webpack_require__(7944);

Object.defineProperty(exports, "ChangeStream", ({
  enumerable: true,
  get: function get() {
    return change_stream_1.ChangeStream;
  }
}));

var collection_1 = __webpack_require__(9816);

Object.defineProperty(exports, "Collection", ({
  enumerable: true,
  get: function get() {
    return collection_1.Collection;
  }
}));

var abstract_cursor_1 = __webpack_require__(9800);

Object.defineProperty(exports, "AbstractCursor", ({
  enumerable: true,
  get: function get() {
    return abstract_cursor_1.AbstractCursor;
  }
}));

var aggregation_cursor_1 = __webpack_require__(334);

Object.defineProperty(exports, "AggregationCursor", ({
  enumerable: true,
  get: function get() {
    return aggregation_cursor_1.AggregationCursor;
  }
}));

var find_cursor_1 = __webpack_require__(246);

Object.defineProperty(exports, "FindCursor", ({
  enumerable: true,
  get: function get() {
    return find_cursor_1.FindCursor;
  }
}));

var list_collections_cursor_1 = __webpack_require__(1297);

Object.defineProperty(exports, "ListCollectionsCursor", ({
  enumerable: true,
  get: function get() {
    return list_collections_cursor_1.ListCollectionsCursor;
  }
}));

var list_indexes_cursor_1 = __webpack_require__(1512);

Object.defineProperty(exports, "ListIndexesCursor", ({
  enumerable: true,
  get: function get() {
    return list_indexes_cursor_1.ListIndexesCursor;
  }
}));

var db_1 = __webpack_require__(8931);

Object.defineProperty(exports, "Db", ({
  enumerable: true,
  get: function get() {
    return db_1.Db;
  }
}));

var gridfs_1 = __webpack_require__(6947);

Object.defineProperty(exports, "GridFSBucket", ({
  enumerable: true,
  get: function get() {
    return gridfs_1.GridFSBucket;
  }
}));

var download_1 = __webpack_require__(3353);

Object.defineProperty(exports, "GridFSBucketReadStream", ({
  enumerable: true,
  get: function get() {
    return download_1.GridFSBucketReadStream;
  }
}));

var upload_1 = __webpack_require__(7171);

Object.defineProperty(exports, "GridFSBucketWriteStream", ({
  enumerable: true,
  get: function get() {
    return upload_1.GridFSBucketWriteStream;
  }
}));

var mongo_client_1 = __webpack_require__(3094);

Object.defineProperty(exports, "MongoClient", ({
  enumerable: true,
  get: function get() {
    return mongo_client_1.MongoClient;
  }
}));

var mongo_types_1 = __webpack_require__(1815);

Object.defineProperty(exports, "CancellationToken", ({
  enumerable: true,
  get: function get() {
    return mongo_types_1.CancellationToken;
  }
}));

var sessions_1 = __webpack_require__(2516);

Object.defineProperty(exports, "ClientSession", ({
  enumerable: true,
  get: function get() {
    return sessions_1.ClientSession;
  }
}));
/** @public */

var bson_1 = __webpack_require__(4356);

Object.defineProperty(exports, "BSON", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSON;
  }
}));

var bson_2 = __webpack_require__(4356);

Object.defineProperty(exports, "Binary", ({
  enumerable: true,
  get: function get() {
    return bson_2.Binary;
  }
}));
Object.defineProperty(exports, "BSONRegExp", ({
  enumerable: true,
  get: function get() {
    return bson_2.BSONRegExp;
  }
}));
Object.defineProperty(exports, "BSONSymbol", ({
  enumerable: true,
  get: function get() {
    return bson_2.BSONSymbol;
  }
}));
Object.defineProperty(exports, "BSONType", ({
  enumerable: true,
  get: function get() {
    return bson_2.BSONType;
  }
}));
Object.defineProperty(exports, "Code", ({
  enumerable: true,
  get: function get() {
    return bson_2.Code;
  }
}));
Object.defineProperty(exports, "DBRef", ({
  enumerable: true,
  get: function get() {
    return bson_2.DBRef;
  }
}));
Object.defineProperty(exports, "Decimal128", ({
  enumerable: true,
  get: function get() {
    return bson_2.Decimal128;
  }
}));
Object.defineProperty(exports, "Double", ({
  enumerable: true,
  get: function get() {
    return bson_2.Double;
  }
}));
Object.defineProperty(exports, "Int32", ({
  enumerable: true,
  get: function get() {
    return bson_2.Int32;
  }
}));
Object.defineProperty(exports, "Long", ({
  enumerable: true,
  get: function get() {
    return bson_2.Long;
  }
}));
Object.defineProperty(exports, "MaxKey", ({
  enumerable: true,
  get: function get() {
    return bson_2.MaxKey;
  }
}));
Object.defineProperty(exports, "MinKey", ({
  enumerable: true,
  get: function get() {
    return bson_2.MinKey;
  }
}));
Object.defineProperty(exports, "ObjectId", ({
  enumerable: true,
  get: function get() {
    return bson_2.ObjectId;
  }
}));
Object.defineProperty(exports, "Timestamp", ({
  enumerable: true,
  get: function get() {
    return bson_2.Timestamp;
  }
}));

var common_1 = __webpack_require__(1419);

Object.defineProperty(exports, "MongoBulkWriteError", ({
  enumerable: true,
  get: function get() {
    return common_1.MongoBulkWriteError;
  }
}));

var change_stream_cursor_1 = __webpack_require__(7929);

Object.defineProperty(exports, "ChangeStreamCursor", ({
  enumerable: true,
  get: function get() {
    return change_stream_cursor_1.ChangeStreamCursor;
  }
}));

var error_1 = __webpack_require__(9525);

Object.defineProperty(exports, "MongoAPIError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoAPIError;
  }
}));
Object.defineProperty(exports, "MongoAWSError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoAWSError;
  }
}));
Object.defineProperty(exports, "MongoAzureError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoAzureError;
  }
}));
Object.defineProperty(exports, "MongoBatchReExecutionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoBatchReExecutionError;
  }
}));
Object.defineProperty(exports, "MongoChangeStreamError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoChangeStreamError;
  }
}));
Object.defineProperty(exports, "MongoCompatibilityError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCompatibilityError;
  }
}));
Object.defineProperty(exports, "MongoCursorExhaustedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCursorExhaustedError;
  }
}));
Object.defineProperty(exports, "MongoCursorInUseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCursorInUseError;
  }
}));
Object.defineProperty(exports, "MongoDecompressionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoDecompressionError;
  }
}));
Object.defineProperty(exports, "MongoDriverError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoDriverError;
  }
}));
Object.defineProperty(exports, "MongoError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoError;
  }
}));
Object.defineProperty(exports, "MongoExpiredSessionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoExpiredSessionError;
  }
}));
Object.defineProperty(exports, "MongoGridFSChunkError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoGridFSChunkError;
  }
}));
Object.defineProperty(exports, "MongoGridFSStreamError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoGridFSStreamError;
  }
}));
Object.defineProperty(exports, "MongoInvalidArgumentError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoInvalidArgumentError;
  }
}));
Object.defineProperty(exports, "MongoKerberosError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoKerberosError;
  }
}));
Object.defineProperty(exports, "MongoMissingCredentialsError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoMissingCredentialsError;
  }
}));
Object.defineProperty(exports, "MongoMissingDependencyError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoMissingDependencyError;
  }
}));
Object.defineProperty(exports, "MongoNetworkError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNetworkError;
  }
}));
Object.defineProperty(exports, "MongoNetworkTimeoutError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNetworkTimeoutError;
  }
}));
Object.defineProperty(exports, "MongoNotConnectedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNotConnectedError;
  }
}));
Object.defineProperty(exports, "MongoParseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoParseError;
  }
}));
Object.defineProperty(exports, "MongoRuntimeError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoRuntimeError;
  }
}));
Object.defineProperty(exports, "MongoServerClosedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerClosedError;
  }
}));
Object.defineProperty(exports, "MongoServerError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerError;
  }
}));
Object.defineProperty(exports, "MongoServerSelectionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerSelectionError;
  }
}));
Object.defineProperty(exports, "MongoSystemError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoSystemError;
  }
}));
Object.defineProperty(exports, "MongoTailableCursorError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTailableCursorError;
  }
}));
Object.defineProperty(exports, "MongoTopologyClosedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTopologyClosedError;
  }
}));
Object.defineProperty(exports, "MongoTransactionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTransactionError;
  }
}));
Object.defineProperty(exports, "MongoUnexpectedServerResponseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoUnexpectedServerResponseError;
  }
}));
Object.defineProperty(exports, "MongoWriteConcernError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoWriteConcernError;
  }
})); // enums

var common_2 = __webpack_require__(1419);

Object.defineProperty(exports, "BatchType", ({
  enumerable: true,
  get: function get() {
    return common_2.BatchType;
  }
}));

var gssapi_1 = __webpack_require__(7874);

Object.defineProperty(exports, "GSSAPICanonicalizationValue", ({
  enumerable: true,
  get: function get() {
    return gssapi_1.GSSAPICanonicalizationValue;
  }
}));

var providers_1 = __webpack_require__(4923);

Object.defineProperty(exports, "AuthMechanism", ({
  enumerable: true,
  get: function get() {
    return providers_1.AuthMechanism;
  }
}));

var compression_1 = __webpack_require__(435);

Object.defineProperty(exports, "Compressor", ({
  enumerable: true,
  get: function get() {
    return compression_1.Compressor;
  }
}));

var abstract_cursor_2 = __webpack_require__(9800);

Object.defineProperty(exports, "CURSOR_FLAGS", ({
  enumerable: true,
  get: function get() {
    return abstract_cursor_2.CURSOR_FLAGS;
  }
}));

var deps_1 = __webpack_require__(8310);

Object.defineProperty(exports, "AutoEncryptionLoggerLevel", ({
  enumerable: true,
  get: function get() {
    return deps_1.AutoEncryptionLoggerLevel;
  }
}));

var error_2 = __webpack_require__(9525);

Object.defineProperty(exports, "MongoErrorLabel", ({
  enumerable: true,
  get: function get() {
    return error_2.MongoErrorLabel;
  }
}));

var explain_1 = __webpack_require__(4969);

Object.defineProperty(exports, "ExplainVerbosity", ({
  enumerable: true,
  get: function get() {
    return explain_1.ExplainVerbosity;
  }
}));

var mongo_client_2 = __webpack_require__(3094);

Object.defineProperty(exports, "ServerApiVersion", ({
  enumerable: true,
  get: function get() {
    return mongo_client_2.ServerApiVersion;
  }
}));

var find_and_modify_1 = __webpack_require__(1253);

Object.defineProperty(exports, "ReturnDocument", ({
  enumerable: true,
  get: function get() {
    return find_and_modify_1.ReturnDocument;
  }
}));

var set_profiling_level_1 = __webpack_require__(3705);

Object.defineProperty(exports, "ProfilingLevel", ({
  enumerable: true,
  get: function get() {
    return set_profiling_level_1.ProfilingLevel;
  }
}));

var read_concern_1 = __webpack_require__(2445);

Object.defineProperty(exports, "ReadConcernLevel", ({
  enumerable: true,
  get: function get() {
    return read_concern_1.ReadConcernLevel;
  }
}));

var read_preference_1 = __webpack_require__(4064);

Object.defineProperty(exports, "ReadPreferenceMode", ({
  enumerable: true,
  get: function get() {
    return read_preference_1.ReadPreferenceMode;
  }
}));

var common_3 = __webpack_require__(2801);

Object.defineProperty(exports, "ServerType", ({
  enumerable: true,
  get: function get() {
    return common_3.ServerType;
  }
}));
Object.defineProperty(exports, "TopologyType", ({
  enumerable: true,
  get: function get() {
    return common_3.TopologyType;
  }
})); // Helper classes

var read_concern_2 = __webpack_require__(2445);

Object.defineProperty(exports, "ReadConcern", ({
  enumerable: true,
  get: function get() {
    return read_concern_2.ReadConcern;
  }
}));

var read_preference_2 = __webpack_require__(4064);

Object.defineProperty(exports, "ReadPreference", ({
  enumerable: true,
  get: function get() {
    return read_preference_2.ReadPreference;
  }
}));

var write_concern_1 = __webpack_require__(6916);

Object.defineProperty(exports, "WriteConcern", ({
  enumerable: true,
  get: function get() {
    return write_concern_1.WriteConcern;
  }
})); // events

var command_monitoring_events_1 = __webpack_require__(4482);

Object.defineProperty(exports, "CommandFailedEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandFailedEvent;
  }
}));
Object.defineProperty(exports, "CommandStartedEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandStartedEvent;
  }
}));
Object.defineProperty(exports, "CommandSucceededEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandSucceededEvent;
  }
}));

var connection_pool_events_1 = __webpack_require__(1027);

Object.defineProperty(exports, "ConnectionCheckedInEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckedOutEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionClosedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionClosedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCreatedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolClearedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolClosedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolCreatedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolReadyEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolReadyEvent;
  }
}));
Object.defineProperty(exports, "ConnectionReadyEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionReadyEvent;
  }
}));

var events_1 = __webpack_require__(468);

Object.defineProperty(exports, "ServerClosedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerClosedEvent;
  }
}));
Object.defineProperty(exports, "ServerDescriptionChangedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerDescriptionChangedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatFailedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatFailedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatStartedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatStartedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatSucceededEvent;
  }
}));
Object.defineProperty(exports, "ServerOpeningEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerOpeningEvent;
  }
}));
Object.defineProperty(exports, "TopologyClosedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyClosedEvent;
  }
}));
Object.defineProperty(exports, "TopologyDescriptionChangedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyDescriptionChangedEvent;
  }
}));
Object.defineProperty(exports, "TopologyOpeningEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyOpeningEvent;
  }
}));

var srv_polling_1 = __webpack_require__(1817);

Object.defineProperty(exports, "SrvPollingEvent", ({
  enumerable: true,
  get: function get() {
    return srv_polling_1.SrvPollingEvent;
  }
}));

/***/ }),

/***/ 3094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoClient = exports.ServerApiVersion = void 0;

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(4356);

var change_stream_1 = __webpack_require__(7944);

var mongo_credentials_1 = __webpack_require__(7739);

var providers_1 = __webpack_require__(4923);

var connection_string_1 = __webpack_require__(1825);

var constants_1 = __webpack_require__(9592);

var db_1 = __webpack_require__(8931);

var error_1 = __webpack_require__(9525);

var mongo_logger_1 = __webpack_require__(1274);

var mongo_types_1 = __webpack_require__(1815);

var read_preference_1 = __webpack_require__(4064);

var server_selection_1 = __webpack_require__(4265);

var topology_1 = __webpack_require__(2776);

var sessions_1 = __webpack_require__(2516);

var utils_1 = __webpack_require__(672);
/** @public */


exports.ServerApiVersion = Object.freeze({
  v1: '1'
});
/** @internal */

var kOptions = Symbol('options');
/**
 * The **MongoClient** class is a class that allows for making Connections to MongoDB.
 * @public
 *
 * @remarks
 * The programmatically provided options take precedence over the URI options.
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * // Enable command monitoring for debugging
 * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });
 *
 * client.on('commandStarted', started => console.log(started));
 * client.db().collection('pets');
 * await client.insertOne({ name: 'spot', kind: 'dog' });
 * ```
 */

var MongoClient = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(MongoClient, _mongo_types_1$TypedE);

  var _super = _createSuper(MongoClient);

  function MongoClient(url, options) {
    var _this;

    _classCallCheck(this, MongoClient);

    _this = _super.call(this);
    _this[kOptions] = (0, connection_string_1.parseOptions)(url, _assertThisInitialized(_this), options);
    _this.mongoLogger = new mongo_logger_1.MongoLogger(_this[kOptions].mongoLoggerOptions); // eslint-disable-next-line @typescript-eslint/no-this-alias

    var client = _assertThisInitialized(_this); // The internal state


    _this.s = {
      url: url,
      bsonOptions: (0, bson_1.resolveBSONOptions)(_this[kOptions]),
      namespace: (0, utils_1.ns)('admin'),
      hasBeenClosed: false,
      sessionPool: new sessions_1.ServerSessionPool(_assertThisInitialized(_this)),
      activeSessions: new Set(),

      get options() {
        return client[kOptions];
      },

      get readConcern() {
        return client[kOptions].readConcern;
      },

      get writeConcern() {
        return client[kOptions].writeConcern;
      },

      get readPreference() {
        return client[kOptions].readPreference;
      },

      get isMongoClient() {
        return true;
      }

    };
    return _this;
  }
  /** @see MongoOptions */


  _createClass(MongoClient, [{
    key: "options",
    get: function get() {
      return Object.freeze(_objectSpread({}, this[kOptions]));
    }
  }, {
    key: "serverApi",
    get: function get() {
      return this[kOptions].serverApi && Object.freeze(_objectSpread({}, this[kOptions].serverApi));
    }
    /**
     * Intended for APM use only
     * @internal
     */

  }, {
    key: "monitorCommands",
    get: function get() {
      return this[kOptions].monitorCommands;
    },
    set: function set(value) {
      this[kOptions].monitorCommands = value;
    }
  }, {
    key: "autoEncrypter",
    get: function get() {
      return this[kOptions].autoEncrypter;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this.s.readConcern;
    }
  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "readPreference",
    get: function get() {
      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
    /**
     * Connect to MongoDB using a url
     *
     * @see docs.mongodb.org/manual/reference/connection-string/
     */

  }, {
    key: "connect",
    value: function () {
      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.connectionLock) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", this.connectionLock);

            case 2:
              _context.prev = 2;
              this.connectionLock = this._connect();
              _context.next = 6;
              return this.connectionLock;

            case 6:
              _context.prev = 6;
              // release
              this.connectionLock = undefined;
              return _context.finish(6);

            case 9:
              return _context.abrupt("return", this);

            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2,, 6, 9]]);
      }));

      function connect() {
        return _connect2.apply(this, arguments);
      }

      return connect;
    }()
    /**
     * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.
     * Locking is enforced by the connect method.
     *
     * @internal
     */

  }, {
    key: "_connect",
    value: function () {
      var _connect3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var _options$credentials,
            _this2 = this;

        var options, hosts, _iterator, _step, _step$value2, index, host, _options$credentials2, _options$credentials3, allowedHosts, isServiceAuth, _iterator2, _step2, _host, _iterator3, _step3, _loop, topologyConnect, initAutoEncrypter;

        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(this.topology && this.topology.isConnected())) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return", this);

            case 2:
              options = this[kOptions];

              if (!(typeof options.srvHost === 'string')) {
                _context4.next = 9;
                break;
              }

              _context4.next = 6;
              return (0, connection_string_1.resolveSRVRecord)(options);

            case 6:
              hosts = _context4.sent;
              _iterator = _createForOfIteratorHelper(hosts.entries());

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _step$value2 = _slicedToArray(_step.value, 2), index = _step$value2[0], host = _step$value2[1];
                  options.hosts[index] = host;
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

            case 9:
              if (!(((_options$credentials = options.credentials) === null || _options$credentials === void 0 ? void 0 : _options$credentials.mechanism) === providers_1.AuthMechanism.MONGODB_OIDC)) {
                _context4.next = 30;
                break;
              }

              allowedHosts = ((_options$credentials2 = options.credentials) === null || _options$credentials2 === void 0 || (_options$credentials2 = _options$credentials2.mechanismProperties) === null || _options$credentials2 === void 0 ? void 0 : _options$credentials2.ALLOWED_HOSTS) || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
              isServiceAuth = !!((_options$credentials3 = options.credentials) !== null && _options$credentials3 !== void 0 && (_options$credentials3 = _options$credentials3.mechanismProperties) !== null && _options$credentials3 !== void 0 && _options$credentials3.PROVIDER_NAME);

              if (isServiceAuth) {
                _context4.next = 30;
                break;
              }

              _iterator2 = _createForOfIteratorHelper(options.hosts);
              _context4.prev = 14;

              _iterator2.s();

            case 16:
              if ((_step2 = _iterator2.n()).done) {
                _context4.next = 22;
                break;
              }

              _host = _step2.value;

              if ((0, utils_1.hostMatchesWildcards)(_host.toHostPort().host, allowedHosts)) {
                _context4.next = 20;
                break;
              }

              throw new error_1.MongoInvalidArgumentError("Host '".concat(_host, "' is not valid for OIDC authentication with ALLOWED_HOSTS of '").concat(allowedHosts.join(','), "'"));

            case 20:
              _context4.next = 16;
              break;

            case 22:
              _context4.next = 27;
              break;

            case 24:
              _context4.prev = 24;
              _context4.t0 = _context4["catch"](14);

              _iterator2.e(_context4.t0);

            case 27:
              _context4.prev = 27;

              _iterator2.f();

              return _context4.finish(27);

            case 30:
              this.topology = new topology_1.Topology(this, options.hosts, options); // Events can be emitted before initialization is complete so we have to
              // save the reference to the topology on the client ASAP if the event handlers need to access it

              this.topology.once(topology_1.Topology.OPEN, function () {
                return _this2.emit('open', _this2);
              });
              _iterator3 = _createForOfIteratorHelper(constants_1.MONGO_CLIENT_EVENTS);
              _context4.prev = 33;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var event;
                return _regeneratorRuntime().wrap(function _loop$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      event = _step3.value;

                      _this2.topology.on(event, function () {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                          args[_key] = arguments[_key];
                        }

                        return _this2.emit.apply(_this2, [event].concat(args));
                      });

                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }, _loop);
              });

              _iterator3.s();

            case 36:
              if ((_step3 = _iterator3.n()).done) {
                _context4.next = 40;
                break;
              }

              return _context4.delegateYield(_loop(), "t1", 38);

            case 38:
              _context4.next = 36;
              break;

            case 40:
              _context4.next = 45;
              break;

            case 42:
              _context4.prev = 42;
              _context4.t2 = _context4["catch"](33);

              _iterator3.e(_context4.t2);

            case 45:
              _context4.prev = 45;

              _iterator3.f();

              return _context4.finish(45);

            case 48:
              topologyConnect = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                  var _this2$topology2;

                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return (0, util_1.promisify)(function (callback) {
                          var _this2$topology;

                          return (_this2$topology = _this2.topology) === null || _this2$topology === void 0 ? void 0 : _this2$topology.connect(options, callback);
                        })();

                      case 3:
                        _context2.next = 9;
                        break;

                      case 5:
                        _context2.prev = 5;
                        _context2.t0 = _context2["catch"](0);
                        (_this2$topology2 = _this2.topology) === null || _this2$topology2 === void 0 ? void 0 : _this2$topology2.close({
                          force: true
                        });
                        throw _context2.t0;

                      case 9:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2, null, [[0, 5]]);
                }));

                return function topologyConnect() {
                  return _ref.apply(this, arguments);
                };
              }();

              if (!this.autoEncrypter) {
                _context4.next = 59;
                break;
              }

              initAutoEncrypter = (0, util_1.promisify)(function (callback) {
                var _this2$autoEncrypter;

                return (_this2$autoEncrypter = _this2.autoEncrypter) === null || _this2$autoEncrypter === void 0 ? void 0 : _this2$autoEncrypter.init(callback);
              });
              _context4.next = 53;
              return initAutoEncrypter();

            case 53:
              _context4.next = 55;
              return topologyConnect();

            case 55:
              _context4.next = 57;
              return options.encrypter.connectInternalClient();

            case 57:
              _context4.next = 61;
              break;

            case 59:
              _context4.next = 61;
              return topologyConnect();

            case 61:
              return _context4.abrupt("return", this);

            case 62:
            case "end":
              return _context4.stop();
          }
        }, _callee3, this, [[14, 24, 27, 30], [33, 42, 45, 48]]);
      }));

      function _connect() {
        return _connect3.apply(this, arguments);
      }

      return _connect;
    }()
    /**
     * Close the client and its underlying connections
     *
     * @param force - Force close, emitting no events
     */

  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var _this3 = this;

        var force,
            activeSessionEnds,
            selector,
            topologyDescription,
            serverDescriptions,
            servers,
            endSessions,
            topology,
            _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              force = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : false;
              // There's no way to set hasBeenClosed back to false
              Object.defineProperty(this.s, 'hasBeenClosed', {
                value: true,
                enumerable: true,
                configurable: false,
                writable: false
              });
              activeSessionEnds = Array.from(this.s.activeSessions, function (session) {
                return session.endSession();
              });
              this.s.activeSessions.clear();
              _context5.next = 6;
              return Promise.all(activeSessionEnds);

            case 6:
              if (!(this.topology == null)) {
                _context5.next = 8;
                break;
              }

              return _context5.abrupt("return");

            case 8:
              // If we would attempt to select a server and get nothing back we short circuit
              // to avoid the server selection timeout.
              selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
              topologyDescription = this.topology.description;
              serverDescriptions = Array.from(topologyDescription.servers.values());
              servers = selector(topologyDescription, serverDescriptions);

              if (!(servers.length !== 0)) {
                _context5.next = 17;
                break;
              }

              endSessions = Array.from(this.s.sessionPool.sessions, function (_ref2) {
                var id = _ref2.id;
                return id;
              });

              if (!(endSessions.length !== 0)) {
                _context5.next = 17;
                break;
              }

              _context5.next = 17;
              return this.db('admin').command({
                endSessions: endSessions
              }, {
                readPreference: read_preference_1.ReadPreference.primaryPreferred,
                noResponse: true
              })["catch"](function () {
                return null;
              });

            case 17:
              // clear out references to old topology
              topology = this.topology;
              this.topology = undefined;
              _context5.next = 21;
              return new Promise(function (resolve, reject) {
                topology.close({
                  force: force
                }, function (error) {
                  if (error) return reject(error);
                  var encrypter = _this3[kOptions].encrypter;

                  if (encrypter) {
                    return encrypter.close(_this3, force, function (error) {
                      if (error) return reject(error);
                      resolve();
                    });
                  }

                  resolve();
                });
              });

            case 21:
            case "end":
              return _context5.stop();
          }
        }, _callee4, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Create a new Db instance sharing the current socket connections.
     *
     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
     * @param options - Optional settings for Db construction
     */

  }, {
    key: "db",
    value: function db(dbName, options) {
      var _options;

      options = (_options = options) !== null && _options !== void 0 ? _options : {}; // Default to db from connection string if not provided

      if (!dbName) {
        dbName = this.options.dbName;
      } // Copy the options and add out internal override of the not shared flag


      var finalOptions = Object.assign({}, this[kOptions], options); // Return the db object

      var db = new db_1.Db(this, dbName, finalOptions); // Return the database

      return db;
    }
    /**
     * Connect to MongoDB using a url
     *
     * @remarks
     * The programmatically provided options take precedence over the URI options.
     *
     * @see https://www.mongodb.com/docs/manual/reference/connection-string/
     */

  }, {
    key: "startSession",
    value:
    /** Starts a new session on the server */
    function startSession(options) {
      var _this4 = this;

      var session = new sessions_1.ClientSession(this, this.s.sessionPool, _objectSpread({
        explicit: true
      }, options), this[kOptions]);
      this.s.activeSessions.add(session);
      session.once('ended', function () {
        _this4.s.activeSessions["delete"](session);
      });
      return session;
    }
  }, {
    key: "withSession",
    value: function () {
      var _withSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(optionsOrOperation, callback) {
        var options, withSessionCallback, session;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              options = _objectSpread({
                // Always define an owner
                owner: Symbol()
              }, _typeof(optionsOrOperation) === 'object' ? optionsOrOperation : {});
              withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;

              if (!(withSessionCallback == null)) {
                _context6.next = 4;
                break;
              }

              throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');

            case 4:
              session = this.startSession(options);
              _context6.prev = 5;
              _context6.next = 8;
              return withSessionCallback(session);

            case 8:
              _context6.prev = 8;
              _context6.prev = 9;
              _context6.next = 12;
              return session.endSession();

            case 12:
              _context6.next = 16;
              break;

            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](9);

            case 16:
              return _context6.finish(8);

            case 17:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this, [[5,, 8, 17], [9, 14]]);
      }));

      function withSession(_x, _x2) {
        return _withSession.apply(this, arguments);
      }

      return withSession;
    }()
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this cluster. Will ignore all
     * changes to system collections, as well as the local, admin, and config databases.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to provide the schema that may be defined for all the data within the current cluster
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
  }], [{
    key: "connect",
    value: function () {
      var _connect4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, options) {
        var client;
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              client = new this(url, options);
              return _context7.abrupt("return", client.connect());

            case 2:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this);
      }));

      function connect(_x3, _x4) {
        return _connect4.apply(this, arguments);
      }

      return connect;
    }()
  }]);

  return MongoClient;
}(mongo_types_1.TypedEventEmitter);

exports.MongoClient = MongoClient;

/***/ }),

/***/ 1274:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoLogger = exports.stringifyWithMaxLen = exports.createStdioLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = void 0;

var bson_1 = __webpack_require__(8054);

var util_1 = __webpack_require__(3837);

var constants_1 = __webpack_require__(9592);

var utils_1 = __webpack_require__(672);
/** @internal */


exports.SeverityLevel = Object.freeze({
  EMERGENCY: 'emergency',
  ALERT: 'alert',
  CRITICAL: 'critical',
  ERROR: 'error',
  WARNING: 'warn',
  NOTICE: 'notice',
  INFORMATIONAL: 'info',
  DEBUG: 'debug',
  TRACE: 'trace',
  OFF: 'off'
});
/** @internal */

exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;
/** @internal */

var SeverityLevelMap = /*#__PURE__*/function (_Map) {
  _inherits(SeverityLevelMap, _Map);

  var _super = _createSuper(SeverityLevelMap);

  function SeverityLevelMap(entries) {
    _classCallCheck(this, SeverityLevelMap);

    var newEntries = [];

    var _iterator = _createForOfIteratorHelper(entries),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value2 = _slicedToArray(_step.value, 2),
            level = _step$value2[0],
            value = _step$value2[1];

        newEntries.push([value, level]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    newEntries.push.apply(newEntries, _toConsumableArray(entries));
    return _super.call(this, newEntries);
  }

  _createClass(SeverityLevelMap, [{
    key: "getNumericSeverityLevel",
    value: function getNumericSeverityLevel(severity) {
      return this.get(severity);
    }
  }, {
    key: "getSeverityLevelName",
    value: function getSeverityLevelName(level) {
      return this.get(level);
    }
  }]);

  return SeverityLevelMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));
/** @internal */


exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([[exports.SeverityLevel.OFF, -Infinity], [exports.SeverityLevel.EMERGENCY, 0], [exports.SeverityLevel.ALERT, 1], [exports.SeverityLevel.CRITICAL, 2], [exports.SeverityLevel.ERROR, 3], [exports.SeverityLevel.WARNING, 4], [exports.SeverityLevel.NOTICE, 5], [exports.SeverityLevel.INFORMATIONAL, 6], [exports.SeverityLevel.DEBUG, 7], [exports.SeverityLevel.TRACE, 8]]);
/** @internal */

exports.MongoLoggableComponent = Object.freeze({
  COMMAND: 'command',
  TOPOLOGY: 'topology',
  SERVER_SELECTION: 'serverSelection',
  CONNECTION: 'connection'
});
/**
 * Parses a string as one of SeverityLevel
 *
 * @param s - the value to be parsed
 * @returns one of SeverityLevel if value can be parsed as such, otherwise null
 */

function parseSeverityFromString(s) {
  var validSeverities = Object.values(exports.SeverityLevel);
  var lowerSeverity = s === null || s === void 0 ? void 0 : s.toLowerCase();

  if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
    return lowerSeverity;
  }

  return null;
}
/** @internal */


function createStdioLogger(stream) {
  return {
    write: function write(log) {
      stream.write((0, util_1.inspect)(log, {
        compact: true,
        breakLength: Infinity
      }), 'utf-8');
      return;
    }
  };
}

exports.createStdioLogger = createStdioLogger;
/**
 * resolves the MONGODB_LOG_PATH and mongodbLogPath options from the environment and the
 * mongo client options respectively. The mongodbLogPath can be either 'stdout', 'stderr', a NodeJS
 * Writable or an object which has a `write` method with the signature:
 * ```ts
 * write(log: Log): void
 * ```
 *
 * @returns the MongoDBLogWritable object to write logs to
 */

function resolveLogPath(_ref, _ref2) {
  var MONGODB_LOG_PATH = _ref.MONGODB_LOG_PATH;
  var mongodbLogPath = _ref2.mongodbLogPath;

  if (typeof mongodbLogPath === 'string' && /^stderr$/i.test(mongodbLogPath)) {
    return createStdioLogger(process.stderr);
  }

  if (typeof mongodbLogPath === 'string' && /^stdout$/i.test(mongodbLogPath)) {
    return createStdioLogger(process.stdout);
  }

  if (_typeof(mongodbLogPath) === 'object' && typeof (mongodbLogPath === null || mongodbLogPath === void 0 ? void 0 : mongodbLogPath.write) === 'function') {
    return mongodbLogPath;
  }

  if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
    return createStdioLogger(process.stderr);
  }

  if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
    return createStdioLogger(process.stdout);
  }

  return createStdioLogger(process.stderr);
}

function compareSeverity(s0, s1) {
  var s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
  var s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
  return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
}
/** @internal */


function stringifyWithMaxLen(value, maxDocumentLength) {
  var ejson = bson_1.EJSON.stringify(value);
  return maxDocumentLength !== 0 && ejson.length > maxDocumentLength ? "".concat(ejson.slice(0, maxDocumentLength), "...") : ejson;
}

exports.stringifyWithMaxLen = stringifyWithMaxLen;

function isLogConvertible(obj) {
  var objAsLogConvertible = obj; // eslint-disable-next-line no-restricted-syntax

  return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === 'function';
}

function attachCommandFields(log, commandEvent) {
  log.commandName = commandEvent.commandName;
  log.requestId = commandEvent.requestId;
  log.driverConnectionId = commandEvent === null || commandEvent === void 0 ? void 0 : commandEvent.connectionId;

  var _utils_1$HostAddress$ = utils_1.HostAddress.fromString(commandEvent.address).toHostPort(),
      host = _utils_1$HostAddress$.host,
      port = _utils_1$HostAddress$.port;

  log.serverHost = host;
  log.serverPort = port;

  if (commandEvent !== null && commandEvent !== void 0 && commandEvent.serviceId) {
    log.serviceId = commandEvent.serviceId.toHexString();
  }

  return log;
}

function attachConnectionFields(log, connectionPoolEvent) {
  var _utils_1$HostAddress$2 = utils_1.HostAddress.fromString(connectionPoolEvent.address).toHostPort(),
      host = _utils_1$HostAddress$2.host,
      port = _utils_1$HostAddress$2.port;

  log.serverHost = host;
  log.serverPort = port;
  return log;
}

function defaultLogTransform(logObject) {
  var _logObject$serviceId;

  var maxDocumentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.DEFAULT_MAX_DOCUMENT_LENGTH;
  var log = Object.create(null);

  switch (logObject.name) {
    case constants_1.COMMAND_STARTED:
      log = attachCommandFields(log, logObject);
      log.message = 'Command started';
      log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength);
      log.databaseName = logObject.databaseName;
      return log;

    case constants_1.COMMAND_SUCCEEDED:
      log = attachCommandFields(log, logObject);
      log.message = 'Command succeeded';
      log.durationMS = logObject.duration;
      log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength);
      return log;

    case constants_1.COMMAND_FAILED:
      log = attachCommandFields(log, logObject);
      log.message = 'Command failed';
      log.durationMS = logObject.duration;
      log.failure = logObject.failure;
      return log;

    case constants_1.CONNECTION_POOL_CREATED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection pool created';

      if (logObject.options) {
        var _logObject$options2 = logObject.options,
            maxIdleTimeMS = _logObject$options2.maxIdleTimeMS,
            minPoolSize = _logObject$options2.minPoolSize,
            maxPoolSize = _logObject$options2.maxPoolSize,
            maxConnecting = _logObject$options2.maxConnecting,
            waitQueueTimeoutMS = _logObject$options2.waitQueueTimeoutMS;
        log = _objectSpread(_objectSpread({}, log), {}, {
          maxIdleTimeMS: maxIdleTimeMS,
          minPoolSize: minPoolSize,
          maxPoolSize: maxPoolSize,
          maxConnecting: maxConnecting,
          waitQueueTimeoutMS: waitQueueTimeoutMS
        });
      }

      return log;

    case constants_1.CONNECTION_POOL_READY:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection pool ready';
      return log;

    case constants_1.CONNECTION_POOL_CLEARED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection pool cleared';

      if (((_logObject$serviceId = logObject.serviceId) === null || _logObject$serviceId === void 0 ? void 0 : _logObject$serviceId._bsontype) === 'ObjectId') {
        log.serviceId = logObject.serviceId.toHexString();
      }

      return log;

    case constants_1.CONNECTION_POOL_CLOSED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection pool closed';
      return log;

    case constants_1.CONNECTION_CREATED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection created';
      log.driverConnectionId = logObject.connectionId;
      return log;

    case constants_1.CONNECTION_READY:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection ready';
      log.driverConnectionId = logObject.connectionId;
      return log;

    case constants_1.CONNECTION_CLOSED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection closed';
      log.driverConnectionId = logObject.connectionId;

      switch (logObject.reason) {
        case 'stale':
          log.reason = 'Connection became stale because the pool was cleared';
          break;

        case 'idle':
          log.reason = 'Connection has been available but unused for longer than the configured max idle time';
          break;

        case 'error':
          log.reason = 'An error occurred while using the connection';

          if (logObject.error) {
            log.error = logObject.error;
          }

          break;

        case 'poolClosed':
          log.reason = 'Connection pool was closed';
          break;

        default:
          log.reason = "Unknown close reason: ".concat(logObject.reason);
      }

      return log;

    case constants_1.CONNECTION_CHECK_OUT_STARTED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection checkout started';
      return log;

    case constants_1.CONNECTION_CHECK_OUT_FAILED:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection checkout failed';

      switch (logObject.reason) {
        case 'poolClosed':
          log.reason = 'Connection pool was closed';
          break;

        case 'timeout':
          log.reason = 'Wait queue timeout elapsed without a connection becoming available';
          break;

        case 'connectionError':
          log.reason = 'An error occurred while trying to establish a new connection';

          if (logObject.error) {
            log.error = logObject.error;
          }

          break;

        default:
          log.reason = "Unknown close reason: ".concat(logObject.reason);
      }

      return log;

    case constants_1.CONNECTION_CHECKED_OUT:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection checked out';
      log.driverConnectionId = logObject.connectionId;
      return log;

    case constants_1.CONNECTION_CHECKED_IN:
      log = attachConnectionFields(log, logObject);
      log.message = 'Connection checked in';
      log.driverConnectionId = logObject.connectionId;
      return log;

    default:
      for (var _i2 = 0, _Object$entries = Object.entries(logObject); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i2 = _slicedToArray(_Object$entries[_i2], 2),
            key = _Object$entries$_i2[0],
            value = _Object$entries$_i2[1];

        if (value != null) log[key] = value;
      }

  }

  return log;
}
/** @internal */


var MongoLogger = /*#__PURE__*/function () {
  function MongoLogger(options) {
    _classCallCheck(this, MongoLogger);

    /**
     * This method should be used when logging errors that do not have a public driver API for
     * reporting errors.
     */
    this.error = this.log.bind(this, 'error');
    /**
     * This method should be used to log situations where undesirable application behaviour might
     * occur. For example, failing to end sessions on `MongoClient.close`.
     */

    this.warn = this.log.bind(this, 'warn');
    /**
     * This method should be used to report high-level information about normal driver behaviour.
     * For example, the creation of a `MongoClient`.
     */

    this.info = this.log.bind(this, 'info');
    /**
     * This method should be used to report information that would be helpful when debugging an
     * application. For example, a command starting, succeeding or failing.
     */

    this.debug = this.log.bind(this, 'debug');
    /**
     * This method should be used to report fine-grained details related to logic flow. For example,
     * entering and exiting a function body.
     */

    this.trace = this.log.bind(this, 'trace');
    this.componentSeverities = options.componentSeverities;
    this.maxDocumentLength = options.maxDocumentLength;
    this.logDestination = options.logDestination;
  }

  _createClass(MongoLogger, [{
    key: "log",
    value: function log(severity, component, message) {
      if (compareSeverity(severity, this.componentSeverities[component]) > 0) return;
      var logMessage = {
        t: new Date(),
        c: component,
        s: severity
      };

      if (typeof message === 'string') {
        logMessage.message = message;
      } else if (_typeof(message) === 'object') {
        if (isLogConvertible(message)) {
          logMessage = _objectSpread(_objectSpread({}, logMessage), message.toLog());
        } else {
          logMessage = _objectSpread(_objectSpread({}, logMessage), defaultLogTransform(message, this.maxDocumentLength));
        }
      }

      this.logDestination.write(logMessage);
    }
    /**
     * Merges options set through environment variables and the MongoClient, preferring environment
     * variables when both are set, and substituting defaults for values not set. Options set in
     * constructor take precedence over both environment variables and MongoClient options.
     *
     * @remarks
     * When parsing component severity levels, invalid values are treated as unset and replaced with
     * the default severity.
     *
     * @param envOptions - options set for the logger from the environment
     * @param clientOptions - options set for the logger in the MongoClient options
     * @returns a MongoLoggerOptions object to be used when instantiating a new MongoLogger
     */

  }], [{
    key: "resolveOptions",
    value: function resolveOptions(envOptions, clientOptions) {
      var _parseSeverityFromStr, _parseSeverityFromStr2, _parseSeverityFromStr3, _parseSeverityFromStr4, _parseSeverityFromStr5, _ref3;

      // client options take precedence over env options
      var combinedOptions = _objectSpread(_objectSpread(_objectSpread({}, envOptions), clientOptions), {}, {
        mongodbLogPath: resolveLogPath(envOptions, clientOptions)
      });

      var defaultSeverity = (_parseSeverityFromStr = parseSeverityFromString(combinedOptions.MONGODB_LOG_ALL)) !== null && _parseSeverityFromStr !== void 0 ? _parseSeverityFromStr : exports.SeverityLevel.OFF;
      return {
        componentSeverities: {
          command: (_parseSeverityFromStr2 = parseSeverityFromString(combinedOptions.MONGODB_LOG_COMMAND)) !== null && _parseSeverityFromStr2 !== void 0 ? _parseSeverityFromStr2 : defaultSeverity,
          topology: (_parseSeverityFromStr3 = parseSeverityFromString(combinedOptions.MONGODB_LOG_TOPOLOGY)) !== null && _parseSeverityFromStr3 !== void 0 ? _parseSeverityFromStr3 : defaultSeverity,
          serverSelection: (_parseSeverityFromStr4 = parseSeverityFromString(combinedOptions.MONGODB_LOG_SERVER_SELECTION)) !== null && _parseSeverityFromStr4 !== void 0 ? _parseSeverityFromStr4 : defaultSeverity,
          connection: (_parseSeverityFromStr5 = parseSeverityFromString(combinedOptions.MONGODB_LOG_CONNECTION)) !== null && _parseSeverityFromStr5 !== void 0 ? _parseSeverityFromStr5 : defaultSeverity,
          "default": defaultSeverity
        },
        maxDocumentLength: (_ref3 = (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH)) !== null && _ref3 !== void 0 ? _ref3 : 1000,
        logDestination: combinedOptions.mongodbLogPath
      };
    }
  }]);

  return MongoLogger;
}();

exports.MongoLogger = MongoLogger;

/***/ }),

/***/ 1815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationToken = exports.TypedEventEmitter = void 0;

var events_1 = __webpack_require__(1239);
/**
 * Typescript type safe event emitter
 * @public
 */


var TypedEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(TypedEventEmitter, _events_1$EventEmitte);

  var _super = _createSuper(TypedEventEmitter);

  function TypedEventEmitter() {
    _classCallCheck(this, TypedEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(TypedEventEmitter, [{
    key: "emitAndLog",
    value:
    /** @internal */
    function emitAndLog(event) {
      var _this$mongoLogger;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.emit.apply(this, [event].concat(args));
      if (this.component) (_this$mongoLogger = this.mongoLogger) === null || _this$mongoLogger === void 0 ? void 0 : _this$mongoLogger.debug(this.component, args[0]);
    }
  }]);

  return TypedEventEmitter;
}(events_1.EventEmitter);

exports.TypedEventEmitter = TypedEventEmitter;
/** @public */

var CancellationToken = /*#__PURE__*/function (_TypedEventEmitter) {
  _inherits(CancellationToken, _TypedEventEmitter);

  var _super2 = _createSuper(CancellationToken);

  function CancellationToken() {
    _classCallCheck(this, CancellationToken);

    return _super2.apply(this, arguments);
  }

  return _createClass(CancellationToken);
}(TypedEventEmitter);

exports.CancellationToken = CancellationToken;

/***/ }),

/***/ 8012:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AddUserOperation = void 0;

var crypto = __webpack_require__(6113);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var AddUserOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(AddUserOperation, _command_1$CommandOpe);

  var _super = _createSuper(AddUserOperation);

  function AddUserOperation(db, username, password, options) {
    var _this;

    _classCallCheck(this, AddUserOperation);

    _this = _super.call(this, db, options);
    _this.db = db;
    _this.username = username;
    _this.password = password;
    _this.options = options !== null && options !== void 0 ? options : {};
    return _this;
  }

  _createClass(AddUserOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var db = this.db;
      var username = this.username;
      var password = this.password;
      var options = this.options; // Error out if digestPassword set
      // v5 removed the digestPassword option from AddUserOptions but we still want to throw
      // an error when digestPassword is provided.

      if ('digestPassword' in options && options.digestPassword != null) {
        return callback(new error_1.MongoInvalidArgumentError('Option "digestPassword" not supported via addUser, use db.command(...) instead'));
      }

      var roles;

      if (!options.roles || Array.isArray(options.roles) && options.roles.length === 0) {
        (0, utils_1.emitWarningOnce)('Creating a user without roles is deprecated. Defaults to "root" if db is "admin" or "dbOwner" otherwise');

        if (db.databaseName.toLowerCase() === 'admin') {
          roles = ['root'];
        } else {
          roles = ['dbOwner'];
        }
      } else {
        roles = Array.isArray(options.roles) ? options.roles : [options.roles];
      }

      var topology;

      try {
        topology = (0, utils_1.getTopology)(db);
      } catch (error) {
        return callback(error);
      }

      var digestPassword = topology.lastHello().maxWireVersion >= 7;
      var userPassword = password;

      if (!digestPassword) {
        // Use node md5 generator
        var md5 = crypto.createHash('md5'); // Generate keys used for authentication

        md5.update("".concat(username, ":mongo:").concat(password));
        userPassword = md5.digest('hex');
      } // Build the command to execute


      var command = {
        createUser: username,
        customData: options.customData || {},
        roles: roles,
        digestPassword: digestPassword
      }; // No password

      if (typeof password === 'string') {
        command.pwd = userPassword;
      }

      _get(_getPrototypeOf(AddUserOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return AddUserOperation;
}(command_1.CommandOperation);

exports.AddUserOperation = AddUserOperation;
(0, operation_1.defineAspects)(AddUserOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 9356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


exports.DB_AGGREGATE_COLLECTION = 1;
var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
/** @internal */

var AggregateOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(AggregateOperation, _command_1$CommandOpe);

  var _super = _createSuper(AggregateOperation);

  function AggregateOperation(ns, pipeline, options) {
    var _this;

    _classCallCheck(this, AggregateOperation);

    _this = _super.call(this, undefined, _objectSpread(_objectSpread({}, options), {}, {
      dbName: ns.db
    }));
    _this.options = _objectSpread({}, options); // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION

    _this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
    _this.pipeline = pipeline; // determine if we have a write stage, override read preference if so

    _this.hasWriteStage = false;

    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {
      _this.pipeline = _this.pipeline.concat({
        $out: options.out
      });
      _this.hasWriteStage = true;
    } else if (pipeline.length > 0) {
      var finalStage = pipeline[pipeline.length - 1];

      if (finalStage.$out || finalStage.$merge) {
        _this.hasWriteStage = true;
      }
    }

    if (_this.hasWriteStage) {
      _this.trySecondaryWrite = true;
    } else {
      delete _this.options.writeConcern;
    }

    if (_this.explain && _this.writeConcern) {
      throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
    }

    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && _typeof(options.cursor) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');
    }

    return _this;
  }

  _createClass(AggregateOperation, [{
    key: "canRetryRead",
    get: function get() {
      return !this.hasWriteStage;
    }
  }, {
    key: "addToPipeline",
    value: function addToPipeline(stage) {
      this.pipeline.push(stage);
    }
  }, {
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var options = this.options;
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var command = {
        aggregate: this.target,
        pipeline: this.pipeline
      };

      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }

      if (this.hasWriteStage && this.writeConcern) {
        write_concern_1.WriteConcern.apply(command, this.writeConcern);
      }

      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }

      if (typeof options.allowDiskUse === 'boolean') {
        command.allowDiskUse = options.allowDiskUse;
      }

      if (options.hint) {
        command.hint = options.hint;
      }

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      command.cursor = options.cursor || {};

      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }

      _get(_getPrototypeOf(AggregateOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return AggregateOperation;
}(command_1.CommandOperation);

exports.AggregateOperation = AggregateOperation;
(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BulkWriteOperation = void 0;

var operation_1 = __webpack_require__(4797);
/** @internal */


var BulkWriteOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(BulkWriteOperation, _operation_1$Abstract);

  var _super = _createSuper(BulkWriteOperation);

  function BulkWriteOperation(collection, operations, options) {
    var _this;

    _classCallCheck(this, BulkWriteOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    _this.operations = operations;
    return _this;
  }

  _createClass(BulkWriteOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      var operations = this.operations;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference
      }); // Create the bulk operation


      var bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options); // for each op go through and add to the bulk

      try {
        for (var i = 0; i < operations.length; i++) {
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback(err);
      } // Execute the bulk


      bulk.execute(_objectSpread(_objectSpread({}, options), {}, {
        session: session
      })).then(function (result) {
        return callback(undefined, result);
      }, function (error) {
        return callback(error);
      });
    }
  }]);

  return BulkWriteOperation;
}(operation_1.AbstractCallbackOperation);

exports.BulkWriteOperation = BulkWriteOperation;
(0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 4086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CollectionsOperation = void 0;

var collection_1 = __webpack_require__(9816);

var operation_1 = __webpack_require__(4797);
/** @internal */


var CollectionsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(CollectionsOperation, _operation_1$Abstract);

  var _super = _createSuper(CollectionsOperation);

  function CollectionsOperation(db, options) {
    var _this;

    _classCallCheck(this, CollectionsOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.db = db;
    return _this;
  }

  _createClass(CollectionsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      // Let's get the collection names
      this.db.listCollections({}, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: true,
        readPreference: this.readPreference,
        session: session
      })).toArray().then(function (documents) {
        var collections = [];

        var _iterator = _createForOfIteratorHelper(documents),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var name = _step.value.name;

            if (!name.includes('$')) {
              // Filter collections removing any illegal ones
              collections.push(new collection_1.Collection(_this2.db, name, _this2.db.s.options));
            }
          } // Return the collection objects

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        callback(undefined, collections);
      }, function (error) {
        return callback(error);
      });
    }
  }]);

  return CollectionsOperation;
}(operation_1.AbstractCallbackOperation);

exports.CollectionsOperation = CollectionsOperation;

/***/ }),

/***/ 9507:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CommandOperation = void 0;

var error_1 = __webpack_require__(9525);

var explain_1 = __webpack_require__(4969);

var read_concern_1 = __webpack_require__(2445);

var server_selection_1 = __webpack_require__(4265);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);

var operation_1 = __webpack_require__(4797);
/** @internal */


var CommandOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(CommandOperation, _operation_1$Abstract);

  var _super = _createSuper(CommandOperation);

  function CommandOperation(parent, options) {
    var _this;

    _classCallCheck(this, CommandOperation);

    _this = _super.call(this, options);
    _this.options = options !== null && options !== void 0 ? options : {}; // NOTE: this was explicitly added for the add/remove user operations, it's likely
    //       something we'd want to reconsider. Perhaps those commands can use `Admin`
    //       as a parent?

    var dbNameOverride = (options === null || options === void 0 ? void 0 : options.dbName) || (options === null || options === void 0 ? void 0 : options.authdb);

    if (dbNameOverride) {
      _this.ns = new utils_1.MongoDBNamespace(dbNameOverride, '$cmd');
    } else {
      _this.ns = parent ? parent.s.namespace.withCollection('$cmd') : new utils_1.MongoDBNamespace('admin', '$cmd');
    }

    _this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
    _this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);

    if (_this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
      _this.explain = explain_1.Explain.fromOptions(options);
    } else if ((options === null || options === void 0 ? void 0 : options.explain) != null) {
      throw new error_1.MongoInvalidArgumentError("Option \"explain\" is not supported on this command");
    }

    return _this;
  }

  _createClass(CommandOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }

      return true;
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(server, session, cmd, callback) {
      // TODO: consider making this a non-enumerable property
      this.server = server;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference,
        session: session
      });

      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var inTransaction = this.session && this.session.inTransaction();

      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, {
          readConcern: this.readConcern
        });
      }

      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }

      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
      }

      if (options.collation && _typeof(options.collation) === 'object' && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
        Object.assign(cmd, {
          collation: options.collation
        });
      }

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      }

      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
      }

      server.command(this.ns, cmd, options, callback);
    }
  }]);

  return CommandOperation;
}(operation_1.AbstractCallbackOperation);

exports.CommandOperation = CommandOperation;

/***/ }),

/***/ 9230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prepareDocs = exports.indexInformation = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

function indexInformation(db, name, _optionsOrCallback, _callback) {
  var options = _optionsOrCallback;
  var callback = _callback;

  if ('function' === typeof _optionsOrCallback) {
    callback = _optionsOrCallback;
    options = {};
  } // If we specified full information


  var full = options.full == null ? false : options.full;
  var topology;

  try {
    topology = (0, utils_1.getTopology)(db);
  } catch (error) {
    return callback(error);
  } // Did the user destroy the topology


  if (topology.isDestroyed()) return callback(new error_1.MongoTopologyClosedError()); // Process all the results from the index command and collection

  function processResults(indexes) {
    // Contains all the information
    var info = {}; // Process all the indexes

    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i]; // Let's unpack the object

      info[index.name] = [];

      for (var _name2 in index.key) {
        info[index.name].push([_name2, index.key[_name2]]);
      }
    }

    return info;
  } // Get the list of indexes of the specified collection


  db.collection(name).listIndexes(options).toArray().then(function (indexes) {
    if (!Array.isArray(indexes)) return callback(undefined, []);
    if (full) return callback(undefined, indexes);
    callback(undefined, processResults(indexes));
  }, function (error) {
    return callback(error);
  });
}

exports.indexInformation = indexInformation;

function prepareDocs(coll, docs, options) {
  var _coll$s$db$options;

  var forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : (_coll$s$db$options = coll.s.db.options) === null || _coll$s$db$options === void 0 ? void 0 : _coll$s$db$options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId

  if (forceServerObjectId === true) {
    return docs;
  }

  return docs.map(function (doc) {
    if (doc._id == null) {
      doc._id = coll.s.pkFactory.createPk();
    }

    return doc;
  });
}

exports.prepareDocs = prepareDocs;

/***/ }),

/***/ 5129:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CountOperation = void 0;

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var CountOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CountOperation, _command_1$CommandOpe);

  var _super = _createSuper(CountOperation);

  function CountOperation(namespace, filter, options) {
    var _this;

    _classCallCheck(this, CountOperation);

    _this = _super.call(this, {
      s: {
        namespace: namespace
      }
    }, options);
    _this.options = options;
    _this.collectionName = namespace.collection;
    _this.query = filter;
    return _this;
  }

  _createClass(CountOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var options = this.options;
      var cmd = {
        count: this.collectionName,
        query: this.query
      };

      if (typeof options.limit === 'number') {
        cmd.limit = options.limit;
      }

      if (typeof options.skip === 'number') {
        cmd.skip = options.skip;
      }

      if (options.hint != null) {
        cmd.hint = options.hint;
      }

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      }

      _get(_getPrototypeOf(CountOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        callback(err, result ? result.n : 0);
      });
    }
  }]);

  return CountOperation;
}(command_1.CommandOperation);

exports.CountOperation = CountOperation;
(0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);

/***/ }),

/***/ 2411:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CountDocumentsOperation = void 0;

var aggregate_1 = __webpack_require__(9356);
/** @internal */


var CountDocumentsOperation = /*#__PURE__*/function (_aggregate_1$Aggregat) {
  _inherits(CountDocumentsOperation, _aggregate_1$Aggregat);

  var _super = _createSuper(CountDocumentsOperation);

  function CountDocumentsOperation(collection, query, options) {
    _classCallCheck(this, CountDocumentsOperation);

    var pipeline = [];
    pipeline.push({
      $match: query
    });

    if (typeof options.skip === 'number') {
      pipeline.push({
        $skip: options.skip
      });
    }

    if (typeof options.limit === 'number') {
      pipeline.push({
        $limit: options.limit
      });
    }

    pipeline.push({
      $group: {
        _id: 1,
        n: {
          $sum: 1
        }
      }
    });
    return _super.call(this, collection.s.namespace, pipeline, options);
  }

  _createClass(CountDocumentsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(CountDocumentsOperation.prototype), "executeCallback", this).call(this, server, session, function (err, result) {
        if (err || !result) {
          callback(err);
          return;
        } // NOTE: We're avoiding creating a cursor here to reduce the callstack.


        var response = result;

        if (response.cursor == null || response.cursor.firstBatch == null) {
          callback(undefined, 0);
          return;
        }

        var docs = response.cursor.firstBatch;
        callback(undefined, docs.length ? docs[0].n : 0);
      });
    }
  }]);

  return CountDocumentsOperation;
}(aggregate_1.AggregateOperation);

exports.CountDocumentsOperation = CountDocumentsOperation;

/***/ }),

/***/ 6589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CreateCollectionOperation = void 0;

var constants_1 = __webpack_require__(7154);

var collection_1 = __webpack_require__(9816);

var error_1 = __webpack_require__(9525);

var command_1 = __webpack_require__(9507);

var indexes_1 = __webpack_require__(240);

var operation_1 = __webpack_require__(4797);

var ILLEGAL_COMMAND_FIELDS = new Set(['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern', 'raw', 'fieldsAsRaw', 'useBigInt64', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation']);
/* @internal */

var INVALID_QE_VERSION = 'Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.';
/** @internal */

var CreateCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CreateCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(CreateCollectionOperation);

  function CreateCollectionOperation(db, name) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, CreateCollectionOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    _this.db = db;
    _this.name = name;
    return _this;
  }

  _createClass(CreateCollectionOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _options$encryptedFie, _db$client$options$au;

        var db, name, options, encryptedFields, _encryptedFields$escC, _encryptedFields$ecoc, escCollection, ecocCollection, _i, _arr, collectionName, createOp, coll, createIndexOp;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              db = _this2.db;
              name = _this2.name;
              options = _this2.options;
              encryptedFields = (_options$encryptedFie = options.encryptedFields) !== null && _options$encryptedFie !== void 0 ? _options$encryptedFie : (_db$client$options$au = db.client.options.autoEncryption) === null || _db$client$options$au === void 0 || (_db$client$options$au = _db$client$options$au.encryptedFieldsMap) === null || _db$client$options$au === void 0 ? void 0 : _db$client$options$au["".concat(db.databaseName, ".").concat(name)];

              if (!encryptedFields) {
                _context.next = 19;
                break;
              }

              if (!(!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION)) {
                _context.next = 7;
                break;
              }

              throw new error_1.MongoCompatibilityError("".concat(INVALID_QE_VERSION, " The minimum server version required is ").concat(constants_1.MIN_SUPPORTED_QE_SERVER_VERSION));

            case 7:
              // Create auxilliary collections for queryable encryption support.
              escCollection = (_encryptedFields$escC = encryptedFields.escCollection) !== null && _encryptedFields$escC !== void 0 ? _encryptedFields$escC : "enxcol_.".concat(name, ".esc");
              ecocCollection = (_encryptedFields$ecoc = encryptedFields.ecocCollection) !== null && _encryptedFields$ecoc !== void 0 ? _encryptedFields$ecoc : "enxcol_.".concat(name, ".ecoc");
              _i = 0, _arr = [escCollection, ecocCollection];

            case 10:
              if (!(_i < _arr.length)) {
                _context.next = 18;
                break;
              }

              collectionName = _arr[_i];
              createOp = new CreateCollectionOperation(db, collectionName, {
                clusteredIndex: {
                  key: {
                    _id: 1
                  },
                  unique: true
                }
              });
              _context.next = 15;
              return createOp.executeWithoutEncryptedFieldsCheck(server, session);

            case 15:
              _i++;
              _context.next = 10;
              break;

            case 18:
              if (!options.encryptedFields) {
                _this2.options = _objectSpread(_objectSpread({}, _this2.options), {}, {
                  encryptedFields: encryptedFields
                });
              }

            case 19:
              _context.next = 21;
              return _this2.executeWithoutEncryptedFieldsCheck(server, session);

            case 21:
              coll = _context.sent;

              if (!encryptedFields) {
                _context.next = 26;
                break;
              }

              // Create the required index for queryable encryption support.
              createIndexOp = new indexes_1.CreateIndexOperation(db, name, {
                __safeContent__: 1
              }, {});
              _context.next = 26;
              return createIndexOp.execute(server, session);

            case 26:
              return _context.abrupt("return", coll);

            case 27:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))().then(function (coll) {
        return callback(undefined, coll);
      }, function (err) {
        return callback(err);
      });
    }
  }, {
    key: "executeWithoutEncryptedFieldsCheck",
    value: function executeWithoutEncryptedFieldsCheck(server, session) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var db = _this3.db;
        var name = _this3.name;
        var options = _this3.options;

        var done = function done(err) {
          if (err) {
            return reject(err);
          }

          resolve(new collection_1.Collection(db, name, options));
        };

        var cmd = {
          create: name
        };

        for (var n in options) {
          if (options[n] != null && typeof options[n] !== 'function' && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        } // otherwise just execute the command


        _get(_getPrototypeOf(CreateCollectionOperation.prototype), "executeCommand", _this3).call(_this3, server, session, cmd, done);
      });
    }
  }]);

  return CreateCollectionOperation;
}(command_1.CommandOperation);

exports.CreateCollectionOperation = CreateCollectionOperation;
(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 4371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeDeleteStatement = exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = void 0;

var error_1 = __webpack_require__(9525);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var DeleteOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DeleteOperation, _command_1$CommandOpe);

  var _super = _createSuper(DeleteOperation);

  function DeleteOperation(ns, statements, options) {
    var _this;

    _classCallCheck(this, DeleteOperation);

    _this = _super.call(this, undefined, options);
    _this.options = options;
    _this.ns = ns;
    _this.statements = statements;
    return _this;
  }

  _createClass(DeleteOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (_get(_getPrototypeOf(DeleteOperation.prototype), "canRetryWrite", this) === false) {
        return false;
      }

      return this.statements.every(function (op) {
        return op.limit != null ? op.limit > 0 : true;
      });
    }
  }, {
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this$options;

      var options = (_this$options = this.options) !== null && _this$options !== void 0 ? _this$options : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        "delete": this.ns.collection,
        deletes: this.statements,
        ordered: ordered
      };

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      var unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;

      if (unacknowledgedWrite) {
        if (this.statements.find(function (o) {
          return o.hint;
        })) {
          // TODO(NODE-3541): fix error for hint with unacknowledged writes
          callback(new error_1.MongoCompatibilityError("hint is not supported with unacknowledged writes"));
          return;
        }
      }

      _get(_getPrototypeOf(DeleteOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return DeleteOperation;
}(command_1.CommandOperation);

exports.DeleteOperation = DeleteOperation;

var DeleteOneOperation = /*#__PURE__*/function (_DeleteOperation) {
  _inherits(DeleteOneOperation, _DeleteOperation);

  var _super2 = _createSuper(DeleteOneOperation);

  function DeleteOneOperation(collection, filter, options) {
    _classCallCheck(this, DeleteOneOperation);

    return _super2.call(this, collection.s.namespace, [makeDeleteStatement(filter, _objectSpread(_objectSpread({}, options), {}, {
      limit: 1
    }))], options);
  }

  _createClass(DeleteOneOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      _get(_getPrototypeOf(DeleteOneOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref, _this2$writeConcern;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        if (_this2.explain) return callback(undefined, res);
        callback(undefined, {
          acknowledged: (_ref = ((_this2$writeConcern = _this2.writeConcern) === null || _this2$writeConcern === void 0 ? void 0 : _this2$writeConcern.w) !== 0) !== null && _ref !== void 0 ? _ref : true,
          deletedCount: res.n
        });
      });
    }
  }]);

  return DeleteOneOperation;
}(DeleteOperation);

exports.DeleteOneOperation = DeleteOneOperation;

var DeleteManyOperation = /*#__PURE__*/function (_DeleteOperation2) {
  _inherits(DeleteManyOperation, _DeleteOperation2);

  var _super3 = _createSuper(DeleteManyOperation);

  function DeleteManyOperation(collection, filter, options) {
    _classCallCheck(this, DeleteManyOperation);

    return _super3.call(this, collection.s.namespace, [makeDeleteStatement(filter, options)], options);
  }

  _createClass(DeleteManyOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(DeleteManyOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref2, _this3$writeConcern;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        if (_this3.explain) return callback(undefined, res);
        callback(undefined, {
          acknowledged: (_ref2 = ((_this3$writeConcern = _this3.writeConcern) === null || _this3$writeConcern === void 0 ? void 0 : _this3$writeConcern.w) !== 0) !== null && _ref2 !== void 0 ? _ref2 : true,
          deletedCount: res.n
        });
      });
    }
  }]);

  return DeleteManyOperation;
}(DeleteOperation);

exports.DeleteManyOperation = DeleteManyOperation;

function makeDeleteStatement(filter, options) {
  var op = {
    q: filter,
    limit: typeof options.limit === 'number' ? options.limit : 0
  };

  if (options.collation) {
    op.collation = options.collation;
  }

  if (options.hint) {
    op.hint = options.hint;
  }

  return op;
}

exports.makeDeleteStatement = makeDeleteStatement;
(0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DeleteOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(DeleteManyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);

/***/ }),

/***/ 4629:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DistinctOperation = void 0;

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/**
 * Return a list of distinct values for the given key across a collection.
 * @internal
 */


var DistinctOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DistinctOperation, _command_1$CommandOpe);

  var _super = _createSuper(DistinctOperation);

  /**
   * Construct a Distinct operation.
   *
   * @param collection - Collection instance.
   * @param key - Field of the document to find distinct values for.
   * @param query - The query for filtering the set of documents to which we apply the distinct filter.
   * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
   */
  function DistinctOperation(collection, key, query, options) {
    var _this;

    _classCallCheck(this, DistinctOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.collection = collection;
    _this.key = key;
    _this.query = query;
    return _this;
  }

  _createClass(DistinctOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      var coll = this.collection;
      var key = this.key;
      var query = this.query;
      var options = this.options; // Distinct command

      var cmd = {
        distinct: coll.collectionName,
        key: key,
        query: query
      }; // Add maxTimeMS if defined

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (typeof options.comment !== 'undefined') {
        cmd.comment = options.comment;
      } // Do we have a readConcern specified


      (0, utils_1.decorateWithReadConcern)(cmd, coll, options); // Have we specified collation

      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback(err);
      }

      _get(_getPrototypeOf(DistinctOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        if (err) {
          callback(err);
          return;
        }

        callback(undefined, _this2.explain ? result : result.values);
      });
    }
  }]);

  return DistinctOperation;
}(command_1.CommandOperation);

exports.DistinctOperation = DistinctOperation;
(0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);

/***/ }),

/***/ 4149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;

var error_1 = __webpack_require__(9525);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var DropCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DropCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(DropCollectionOperation);

  function DropCollectionOperation(db, name) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, DropCollectionOperation);

    _this = _super.call(this, db, options);
    _this.db = db;
    _this.options = options;
    _this.name = name;
    return _this;
  }

  _createClass(DropCollectionOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _db$client$options$au, _options$encryptedFie;

        var db, options, name, encryptedFieldsMap, encryptedFields, _listCollectionsResul, listCollectionsResult, escCollection, ecocCollection, _i, _arr, collectionName, dropOp;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              db = _this2.db;
              options = _this2.options;
              name = _this2.name;
              encryptedFieldsMap = (_db$client$options$au = db.client.options.autoEncryption) === null || _db$client$options$au === void 0 ? void 0 : _db$client$options$au.encryptedFieldsMap;
              encryptedFields = (_options$encryptedFie = options.encryptedFields) !== null && _options$encryptedFie !== void 0 ? _options$encryptedFie : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap["".concat(db.databaseName, ".").concat(name)];

              if (!(!encryptedFields && encryptedFieldsMap)) {
                _context.next = 10;
                break;
              }

              _context.next = 8;
              return db.listCollections({
                name: name
              }, {
                nameOnly: false
              }).toArray();

            case 8:
              listCollectionsResult = _context.sent;
              encryptedFields = listCollectionsResult === null || listCollectionsResult === void 0 || (_listCollectionsResul = listCollectionsResult[0]) === null || _listCollectionsResul === void 0 || (_listCollectionsResul = _listCollectionsResul.options) === null || _listCollectionsResul === void 0 ? void 0 : _listCollectionsResul.encryptedFields;

            case 10:
              if (!encryptedFields) {
                _context.next = 29;
                break;
              }

              escCollection = encryptedFields.escCollection || "enxcol_.".concat(name, ".esc");
              ecocCollection = encryptedFields.ecocCollection || "enxcol_.".concat(name, ".ecoc");
              _i = 0, _arr = [escCollection, ecocCollection];

            case 14:
              if (!(_i < _arr.length)) {
                _context.next = 29;
                break;
              }

              collectionName = _arr[_i];
              // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.
              dropOp = new DropCollectionOperation(db, collectionName);
              _context.prev = 17;
              _context.next = 20;
              return dropOp.executeWithoutEncryptedFieldsCheck(server, session);

            case 20:
              _context.next = 26;
              break;

            case 22:
              _context.prev = 22;
              _context.t0 = _context["catch"](17);

              if (!(!(_context.t0 instanceof error_1.MongoServerError) || _context.t0.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound)) {
                _context.next = 26;
                break;
              }

              throw _context.t0;

            case 26:
              _i++;
              _context.next = 14;
              break;

            case 29:
              return _context.abrupt("return", _this2.executeWithoutEncryptedFieldsCheck(server, session));

            case 30:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[17, 22]]);
      }))().then(function (result) {
        return callback(undefined, result);
      }, function (err) {
        return callback(err);
      });
    }
  }, {
    key: "executeWithoutEncryptedFieldsCheck",
    value: function executeWithoutEncryptedFieldsCheck(server, session) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _get(_getPrototypeOf(DropCollectionOperation.prototype), "executeCommand", _this3).call(_this3, server, session, {
          drop: _this3.name
        }, function (err, result) {
          if (err) return reject(err);
          resolve(!!result.ok);
        });
      });
    }
  }]);

  return DropCollectionOperation;
}(command_1.CommandOperation);

exports.DropCollectionOperation = DropCollectionOperation;
/** @internal */

var DropDatabaseOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DropDatabaseOperation, _command_1$CommandOpe2);

  var _super2 = _createSuper(DropDatabaseOperation);

  function DropDatabaseOperation(db, options) {
    var _this4;

    _classCallCheck(this, DropDatabaseOperation);

    _this4 = _super2.call(this, db, options);
    _this4.options = options;
    return _this4;
  }

  _createClass(DropDatabaseOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(DropDatabaseOperation.prototype), "executeCommand", this).call(this, server, session, {
        dropDatabase: 1
      }, function (err, result) {
        if (err) return callback(err);
        if (result.ok) return callback(undefined, true);
        callback(undefined, false);
      });
    }
  }]);

  return DropDatabaseOperation;
}(command_1.CommandOperation);

exports.DropDatabaseOperation = DropDatabaseOperation;
(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 2421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EstimatedDocumentCountOperation = void 0;

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var EstimatedDocumentCountOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(EstimatedDocumentCountOperation, _command_1$CommandOpe);

  var _super = _createSuper(EstimatedDocumentCountOperation);

  function EstimatedDocumentCountOperation(collection) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EstimatedDocumentCountOperation);

    _this = _super.call(this, collection, options);
    _this.options = options;
    _this.collectionName = collection.collectionName;
    return _this;
  }

  _createClass(EstimatedDocumentCountOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var cmd = {
        count: this.collectionName
      };

      if (typeof this.options.maxTimeMS === 'number') {
        cmd.maxTimeMS = this.options.maxTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }

      _get(_getPrototypeOf(EstimatedDocumentCountOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, response) {
        if (err) {
          callback(err);
          return;
        }

        callback(undefined, (response === null || response === void 0 ? void 0 : response.n) || 0);
      });
    }
  }]);

  return EstimatedDocumentCountOperation;
}(command_1.CommandOperation);

exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
(0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 5756:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.executeOperation = void 0;

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var server_selection_1 = __webpack_require__(4265);

var utils_1 = __webpack_require__(672);

var operation_1 = __webpack_require__(4797);

var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';

function executeOperation(client, operation, callback) {
  return (0, utils_1.maybeCallback)(function () {
    return executeOperationAsync(client, operation);
  }, callback);
}

exports.executeOperation = executeOperation;

function executeOperationAsync(_x, _x2) {
  return _executeOperationAsync.apply(this, arguments);
}

function _executeOperationAsync() {
  _executeOperationAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, operation) {
    var _operation$readPrefer, _session, _session2;

    var topology, session, owner, readPreference, inTransaction, selector, _operation$server, server, _session3, willRetryRead, willRetryWrite, hasReadAspect, hasWriteAspect, willRetry, _session4;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (operation instanceof operation_1.AbstractCallbackOperation) {
            _context.next = 2;
            break;
          }

          throw new error_1.MongoRuntimeError('This method requires a valid operation instance');

        case 2:
          if (!(client.topology == null)) {
            _context.next = 12;
            break;
          }

          if (!client.s.hasBeenClosed) {
            _context.next = 5;
            break;
          }

          throw new error_1.MongoNotConnectedError('Client must be connected before running operations');

        case 5:
          client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] = true;
          _context.prev = 6;
          _context.next = 9;
          return client.connect();

        case 9:
          _context.prev = 9;
          delete client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')];
          return _context.finish(9);

        case 12:
          topology = client.topology;

          if (!(topology == null)) {
            _context.next = 15;
            break;
          }

          throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');

        case 15:
          // The driver sessions spec mandates that we implicitly create sessions for operations
          // that are not explicitly provided with a session.
          session = operation.session;

          if (!(session == null)) {
            _context.next = 21;
            break;
          }

          owner = Symbol();
          session = client.startSession({
            owner: owner,
            explicit: false
          });
          _context.next = 27;
          break;

        case 21:
          if (!session.hasEnded) {
            _context.next = 25;
            break;
          }

          throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');

        case 25:
          if (!(session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads)) {
            _context.next = 27;
            break;
          }

          throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');

        case 27:
          readPreference = (_operation$readPrefer = operation.readPreference) !== null && _operation$readPrefer !== void 0 ? _operation$readPrefer : read_preference_1.ReadPreference.primary;
          inTransaction = !!((_session = session) !== null && _session !== void 0 && _session.inTransaction());

          if (!(inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary))) {
            _context.next = 31;
            break;
          }

          throw new error_1.MongoTransactionError("Read preference in a transaction must be primary, not: ".concat(readPreference.mode));

        case 31:
          if ((_session2 = session) !== null && _session2 !== void 0 && _session2.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
            session.unpin();
          }

          if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
            // GetMore and KillCursor operations must always select the same server, but run through
            // server selection to potentially force monitor checks if the server is
            // in an unknown state.
            selector = (0, server_selection_1.sameServerSelector)((_operation$server = operation.server) === null || _operation$server === void 0 ? void 0 : _operation$server.description);
          } else if (operation.trySecondaryWrite) {
            // If operation should try to write to secondary use the custom server selector
            // otherwise provide the read preference.
            selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
          } else {
            selector = readPreference;
          }

          _context.next = 35;
          return topology.selectServerAsync(selector, {
            session: session
          });

        case 35:
          server = _context.sent;

          if (!(session == null)) {
            _context.next = 38;
            break;
          }

          return _context.abrupt("return", operation.execute(server, undefined));

        case 38:
          if (operation.hasAspect(operation_1.Aspect.RETRYABLE)) {
            _context.next = 48;
            break;
          }

          _context.prev = 39;
          _context.next = 42;
          return operation.execute(server, session);

        case 42:
          return _context.abrupt("return", _context.sent);

        case 43:
          _context.prev = 43;

          if (!(((_session3 = session) === null || _session3 === void 0 ? void 0 : _session3.owner) != null && session.owner === owner)) {
            _context.next = 47;
            break;
          }

          _context.next = 47;
          return session.endSession()["catch"](function () {
            return null;
          });

        case 47:
          return _context.finish(43);

        case 48:
          willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
          willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
          hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
          hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
          willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;

          if (hasWriteAspect && willRetryWrite) {
            operation.options.willRetryWrite = true;
            session.incrementTransactionNumber();
          }

          _context.prev = 54;
          _context.next = 57;
          return operation.execute(server, session);

        case 57:
          return _context.abrupt("return", _context.sent);

        case 60:
          _context.prev = 60;
          _context.t0 = _context["catch"](54);

          if (!(willRetry && _context.t0 instanceof error_1.MongoError)) {
            _context.next = 66;
            break;
          }

          _context.next = 65;
          return retryOperation(operation, _context.t0, {
            session: session,
            topology: topology,
            selector: selector
          });

        case 65:
          return _context.abrupt("return", _context.sent);

        case 66:
          throw _context.t0;

        case 67:
          _context.prev = 67;

          if (!(((_session4 = session) === null || _session4 === void 0 ? void 0 : _session4.owner) != null && session.owner === owner)) {
            _context.next = 71;
            break;
          }

          _context.next = 71;
          return session.endSession()["catch"](function () {
            return null;
          });

        case 71:
          return _context.finish(67);

        case 72:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[6,, 9, 12], [39,, 43, 48], [54, 60, 67, 72]]);
  }));
  return _executeOperationAsync.apply(this, arguments);
}

function retryOperation(_x3, _x4, _x5) {
  return _retryOperation.apply(this, arguments);
}

function _retryOperation() {
  _retryOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(operation, originalError, _ref) {
    var session, topology, selector, isWriteOperation, isReadOperation, server;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          session = _ref.session, topology = _ref.topology, selector = _ref.selector;
          isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
          isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);

          if (!(isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE)) {
            _context2.next = 5;
            break;
          }

          throw new error_1.MongoServerError({
            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            originalError: originalError
          });

        case 5:
          if (!(isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError))) {
            _context2.next = 7;
            break;
          }

          throw originalError;

        case 7:
          if (!(isReadOperation && !(0, error_1.isRetryableReadError)(originalError))) {
            _context2.next = 9;
            break;
          }

          throw originalError;

        case 9:
          if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {
            // If we have a cursor and the initial command fails with a network error,
            // we can retry it on another connection. So we need to check it back in, clear the
            // pool for the service id, and retry again.
            session.unpin({
              force: true,
              forceClear: true
            });
          } // select a new server, and attempt to retry the operation


          _context2.next = 12;
          return topology.selectServerAsync(selector, {
            session: session
          });

        case 12:
          server = _context2.sent;

          if (!(isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server))) {
            _context2.next = 15;
            break;
          }

          throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');

        case 15:
          _context2.prev = 15;
          _context2.next = 18;
          return operation.execute(server, session);

        case 18:
          return _context2.abrupt("return", _context2.sent);

        case 21:
          _context2.prev = 21;
          _context2.t0 = _context2["catch"](15);

          if (!(_context2.t0 instanceof error_1.MongoError && _context2.t0.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed))) {
            _context2.next = 25;
            break;
          }

          throw originalError;

        case 25:
          throw _context2.t0;

        case 26:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[15, 21]]);
  }));
  return _retryOperation.apply(this, arguments);
}

/***/ }),

/***/ 4128:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindOperation = void 0;

var error_1 = __webpack_require__(9525);

var read_concern_1 = __webpack_require__(2445);

var sort_1 = __webpack_require__(8077);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var FindOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(FindOperation, _command_1$CommandOpe);

  var _super = _createSuper(FindOperation);

  function FindOperation(collection, ns) {
    var _this;

    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, FindOperation);

    _this = _super.call(this, collection, options);
    _this.options = _objectSpread({}, options);
    delete _this.options.writeConcern;
    _this.ns = ns;

    if (_typeof(filter) !== 'object' || Array.isArray(filter)) {
      throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');
    } // special case passing in an ObjectId as a filter


    _this.filter = filter != null && filter._bsontype === 'ObjectId' ? {
      _id: filter
    } : filter;
    return _this;
  }

  _createClass(FindOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      this.server = server;
      var options = this.options;
      var findCommand = makeFindCommand(this.ns, this.filter, options);

      if (this.explain) {
        findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
      }

      server.command(this.ns, findCommand, _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        documentsReturnedIn: 'firstBatch',
        session: session
      }), callback);
    }
  }]);

  return FindOperation;
}(command_1.CommandOperation);

exports.FindOperation = FindOperation;

function makeFindCommand(ns, filter, options) {
  var findCommand = {
    find: ns.collection,
    filter: filter
  };

  if (options.sort) {
    findCommand.sort = (0, sort_1.formatSort)(options.sort);
  }

  if (options.projection) {
    var projection = options.projection;

    if (projection && Array.isArray(projection)) {
      projection = projection.length ? projection.reduce(function (result, field) {
        result[field] = 1;
        return result;
      }, {}) : {
        _id: 1
      };
    }

    findCommand.projection = projection;
  }

  if (options.hint) {
    findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
  }

  if (typeof options.skip === 'number') {
    findCommand.skip = options.skip;
  }

  if (typeof options.limit === 'number') {
    if (options.limit < 0) {
      findCommand.limit = -options.limit;
      findCommand.singleBatch = true;
    } else {
      findCommand.limit = options.limit;
    }
  }

  if (typeof options.batchSize === 'number') {
    if (options.batchSize < 0) {
      if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
        findCommand.limit = -options.batchSize;
      }

      findCommand.singleBatch = true;
    } else {
      findCommand.batchSize = options.batchSize;
    }
  }

  if (typeof options.singleBatch === 'boolean') {
    findCommand.singleBatch = options.singleBatch;
  } // we check for undefined specifically here to allow falsy values
  // eslint-disable-next-line no-restricted-syntax


  if (options.comment !== undefined) {
    findCommand.comment = options.comment;
  }

  if (typeof options.maxTimeMS === 'number') {
    findCommand.maxTimeMS = options.maxTimeMS;
  }

  var readConcern = read_concern_1.ReadConcern.fromOptions(options);

  if (readConcern) {
    findCommand.readConcern = readConcern.toJSON();
  }

  if (options.max) {
    findCommand.max = options.max;
  }

  if (options.min) {
    findCommand.min = options.min;
  }

  if (typeof options.returnKey === 'boolean') {
    findCommand.returnKey = options.returnKey;
  }

  if (typeof options.showRecordId === 'boolean') {
    findCommand.showRecordId = options.showRecordId;
  }

  if (typeof options.tailable === 'boolean') {
    findCommand.tailable = options.tailable;
  }

  if (typeof options.oplogReplay === 'boolean') {
    findCommand.oplogReplay = options.oplogReplay;
  }

  if (typeof options.timeout === 'boolean') {
    findCommand.noCursorTimeout = !options.timeout;
  } else if (typeof options.noCursorTimeout === 'boolean') {
    findCommand.noCursorTimeout = options.noCursorTimeout;
  }

  if (typeof options.awaitData === 'boolean') {
    findCommand.awaitData = options.awaitData;
  }

  if (typeof options.allowPartialResults === 'boolean') {
    findCommand.allowPartialResults = options.allowPartialResults;
  }

  if (options.collation) {
    findCommand.collation = options.collation;
  }

  if (typeof options.allowDiskUse === 'boolean') {
    findCommand.allowDiskUse = options.allowDiskUse;
  }

  if (options["let"]) {
    findCommand["let"] = options["let"];
  }

  return findCommand;
}

(0, operation_1.defineAspects)(FindOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 1253:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.ReturnDocument = void 0;

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var sort_1 = __webpack_require__(8077);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @public */


exports.ReturnDocument = Object.freeze({
  BEFORE: 'before',
  AFTER: 'after'
});

function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
  cmdBase["new"] = options.returnDocument === exports.ReturnDocument.AFTER;
  cmdBase.upsert = options.upsert === true;

  if (options.bypassDocumentValidation === true) {
    cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
  }

  return cmdBase;
}
/** @internal */


var FindAndModifyOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(FindAndModifyOperation, _command_1$CommandOpe);

  var _super = _createSuper(FindAndModifyOperation);

  function FindAndModifyOperation(collection, query, options) {
    var _options$includeResul;

    var _this;

    _classCallCheck(this, FindAndModifyOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.cmdBase = {
      remove: false,
      "new": false,
      upsert: false
    };
    (_options$includeResul = options.includeResultMetadata) !== null && _options$includeResul !== void 0 ? _options$includeResul : options.includeResultMetadata = true;
    var sort = (0, sort_1.formatSort)(options.sort);

    if (sort) {
      _this.cmdBase.sort = sort;
    }

    if (options.projection) {
      _this.cmdBase.fields = options.projection;
    }

    if (options.maxTimeMS) {
      _this.cmdBase.maxTimeMS = options.maxTimeMS;
    } // Decorate the findAndModify command with the write Concern


    if (options.writeConcern) {
      _this.cmdBase.writeConcern = options.writeConcern;
    }

    if (options["let"]) {
      _this.cmdBase["let"] = options["let"];
    } // we check for undefined specifically here to allow falsy values
    // eslint-disable-next-line no-restricted-syntax


    if (options.comment !== undefined) {
      _this.cmdBase.comment = options.comment;
    } // force primary read preference


    _this.readPreference = read_preference_1.ReadPreference.primary;
    _this.collection = collection;
    _this.query = query;
    return _this;
  }

  _createClass(FindAndModifyOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      var query = this.query;

      var options = _objectSpread(_objectSpread({}, this.options), this.bsonOptions); // Create findAndModify command object


      var cmd = _objectSpread({
        findAndModify: coll.collectionName,
        query: query
      }, this.cmdBase); // Have we specified collation


      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback(err);
      }

      if (options.hint) {
        var _this$writeConcern;

        // TODO: once this method becomes a CommandOperation we will have the server
        // in place to check.
        var unacknowledgedWrite = ((_this$writeConcern = this.writeConcern) === null || _this$writeConcern === void 0 ? void 0 : _this$writeConcern.w) === 0;

        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          callback(new error_1.MongoCompatibilityError('The current topology does not support a hint on findAndModify commands'));
          return;
        }

        cmd.hint = options.hint;
      } // Execute the command


      _get(_getPrototypeOf(FindAndModifyOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        var _result$value;

        if (err) return callback(err);
        return callback(undefined, options.includeResultMetadata ? result : (_result$value = result.value) !== null && _result$value !== void 0 ? _result$value : null);
      });
    }
  }]);

  return FindAndModifyOperation;
}(command_1.CommandOperation);
/** @internal */


var FindOneAndDeleteOperation = /*#__PURE__*/function (_FindAndModifyOperati) {
  _inherits(FindOneAndDeleteOperation, _FindAndModifyOperati);

  var _super2 = _createSuper(FindOneAndDeleteOperation);

  function FindOneAndDeleteOperation(collection, filter, options) {
    var _this2;

    _classCallCheck(this, FindOneAndDeleteOperation);

    // Basic validation
    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    _this2 = _super2.call(this, collection, filter, options);
    _this2.cmdBase.remove = true;
    return _this2;
  }

  return _createClass(FindOneAndDeleteOperation);
}(FindAndModifyOperation);

exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
/** @internal */

var FindOneAndReplaceOperation = /*#__PURE__*/function (_FindAndModifyOperati2) {
  _inherits(FindOneAndReplaceOperation, _FindAndModifyOperati2);

  var _super3 = _createSuper(FindOneAndReplaceOperation);

  function FindOneAndReplaceOperation(collection, filter, replacement, options) {
    var _this3;

    _classCallCheck(this, FindOneAndReplaceOperation);

    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    if (replacement == null || _typeof(replacement) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
    }

    if ((0, utils_1.hasAtomicOperators)(replacement)) {
      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
    }

    _this3 = _super3.call(this, collection, filter, options);
    _this3.cmdBase.update = replacement;
    configureFindAndModifyCmdBaseUpdateOpts(_this3.cmdBase, options);
    return _this3;
  }

  return _createClass(FindOneAndReplaceOperation);
}(FindAndModifyOperation);

exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
/** @internal */

var FindOneAndUpdateOperation = /*#__PURE__*/function (_FindAndModifyOperati3) {
  _inherits(FindOneAndUpdateOperation, _FindAndModifyOperati3);

  var _super4 = _createSuper(FindOneAndUpdateOperation);

  function FindOneAndUpdateOperation(collection, filter, update, options) {
    var _this4;

    _classCallCheck(this, FindOneAndUpdateOperation);

    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    if (update == null || _typeof(update) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
    }

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    _this4 = _super4.call(this, collection, filter, options);
    _this4.cmdBase.update = update;
    configureFindAndModifyCmdBaseUpdateOpts(_this4.cmdBase, options);

    if (options.arrayFilters) {
      _this4.cmdBase.arrayFilters = options.arrayFilters;
    }

    return _this4;
  }

  return _createClass(FindOneAndUpdateOperation);
}(FindAndModifyOperation);

exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
(0, operation_1.defineAspects)(FindAndModifyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);

/***/ }),

/***/ 4275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GetMoreOperation = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var operation_1 = __webpack_require__(4797);
/** @internal */


var GetMoreOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(GetMoreOperation, _operation_1$Abstract);

  var _super = _createSuper(GetMoreOperation);

  function GetMoreOperation(ns, cursorId, server, options) {
    var _this;

    _classCallCheck(this, GetMoreOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.ns = ns;
    _this.cursorId = cursorId;
    _this.server = server;
    return _this;
  }
  /**
   * Although there is a server already associated with the get more operation, the signature
   * for execute passes a server so we will just use that one.
   */


  _createClass(GetMoreOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      if (server !== this.server) {
        return callback(new error_1.MongoRuntimeError('Getmore must run on the same server operation began on'));
      }

      if (this.cursorId == null || this.cursorId.isZero()) {
        return callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));
      }

      var collection = this.ns.collection;

      if (collection == null) {
        // Cursors should have adopted the namespace returned by MongoDB
        // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
        return callback(new error_1.MongoRuntimeError('A collection name must be determined before getMore'));
      }

      var getMoreCmd = {
        getMore: this.cursorId,
        collection: collection
      };

      if (typeof this.options.batchSize === 'number') {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }

      if (typeof this.options.maxAwaitTimeMS === 'number') {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }

      var commandOptions = _objectSpread({
        returnFieldSelector: null,
        documentsReturnedIn: 'nextBatch'
      }, this.options);

      server.command(this.ns, getMoreCmd, commandOptions, callback);
    }
  }]);

  return GetMoreOperation;
}(operation_1.AbstractCallbackOperation);

exports.GetMoreOperation = GetMoreOperation;
(0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);

/***/ }),

/***/ 240:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var common_functions_1 = __webpack_require__(9230);

var operation_1 = __webpack_require__(4797);

var VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes
'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes
'2dsphereIndexVersion', // 2d indexes
'bits', 'min', 'max', // geoHaystack Indexes
'bucketSize', // wildcard indexes
'wildcardProjection']);

function isIndexDirection(x) {
  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';
}

function isSingleIndexTuple(t) {
  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
}

function makeIndexSpec(indexSpec, options) {
  var key = new Map();
  var indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec; // Iterate through array and handle different types

  var _iterator = _createForOfIteratorHelper(indexSpecs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var spec = _step.value;

      if (typeof spec === 'string') {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        var _spec$;

        key.set(spec[0], (_spec$ = spec[1]) !== null && _spec$ !== void 0 ? _spec$ : 1);
      } else if (spec instanceof Map) {
        var _iterator2 = _createForOfIteratorHelper(spec),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value2 = _slicedToArray(_step2.value, 2),
                property = _step2$value2[0],
                value = _step2$value2[1];

            key.set(property, value);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (var _i2 = 0, _Object$entries = Object.entries(spec); _i2 < _Object$entries.length; _i2++) {
          var _Object$entries$_i2 = _slicedToArray(_Object$entries[_i2], 2),
              _property = _Object$entries$_i2[0],
              _value = _Object$entries$_i2[1];

          key.set(_property, _value);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return _objectSpread(_objectSpread({}, options), {}, {
    key: key
  });
}
/** @internal */


var IndexesOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(IndexesOperation, _operation_1$Abstract);

  var _super = _createSuper(IndexesOperation);

  function IndexesOperation(collection, options) {
    var _this;

    _classCallCheck(this, IndexesOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(IndexesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      var options = this.options;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({
        full: true
      }, options), {}, {
        readPreference: this.readPreference,
        session: session
      }), callback);
    }
  }]);

  return IndexesOperation;
}(operation_1.AbstractCallbackOperation);

exports.IndexesOperation = IndexesOperation;
/** @internal */

var CreateIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CreateIndexesOperation, _command_1$CommandOpe);

  var _super2 = _createSuper(CreateIndexesOperation);

  function CreateIndexesOperation(parent, collectionName, indexes, options) {
    var _this2;

    _classCallCheck(this, CreateIndexesOperation);

    _this2 = _super2.call(this, parent, options);
    _this2.options = options !== null && options !== void 0 ? options : {};
    _this2.collectionName = collectionName;
    _this2.indexes = indexes.map(function (userIndex) {
      // Ensure the key is a Map to preserve index key ordering
      var key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
      var name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');
      var validIndexOptions = Object.fromEntries(Object.entries(_objectSpread({}, userIndex)).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            optionName = _ref2[0];

        return VALID_INDEX_OPTIONS.has(optionName);
      }));
      return _objectSpread(_objectSpread({}, validIndexOptions), {}, {
        name: name,
        key: key
      });
    });
    return _this2;
  }

  _createClass(CreateIndexesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var options = this.options;
      var indexes = this.indexes;
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var cmd = {
        createIndexes: this.collectionName,
        indexes: indexes
      };

      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));
          return;
        }

        cmd.commitQuorum = options.commitQuorum;
      } // collation is set on each index, it should not be defined at the root


      this.options.collation = undefined;

      _get(_getPrototypeOf(CreateIndexesOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err) {
        if (err) {
          callback(err);
          return;
        }

        var indexNames = indexes.map(function (index) {
          return index.name || '';
        });
        callback(undefined, indexNames);
      });
    }
  }]);

  return CreateIndexesOperation;
}(command_1.CommandOperation);

exports.CreateIndexesOperation = CreateIndexesOperation;
/** @internal */

var CreateIndexOperation = /*#__PURE__*/function (_CreateIndexesOperati) {
  _inherits(CreateIndexOperation, _CreateIndexesOperati);

  var _super3 = _createSuper(CreateIndexOperation);

  function CreateIndexOperation(parent, collectionName, indexSpec, options) {
    _classCallCheck(this, CreateIndexOperation);

    return _super3.call(this, parent, collectionName, [makeIndexSpec(indexSpec, options)], options);
  }

  _createClass(CreateIndexOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(CreateIndexOperation.prototype), "executeCallback", this).call(this, server, session, function (err, indexNames) {
        if (err || !indexNames) return callback(err);
        return callback(undefined, indexNames[0]);
      });
    }
  }]);

  return CreateIndexOperation;
}(CreateIndexesOperation);

exports.CreateIndexOperation = CreateIndexOperation;
/** @internal */

var EnsureIndexOperation = /*#__PURE__*/function (_CreateIndexOperation) {
  _inherits(EnsureIndexOperation, _CreateIndexOperation);

  var _super4 = _createSuper(EnsureIndexOperation);

  function EnsureIndexOperation(db, collectionName, indexSpec, options) {
    var _this3;

    _classCallCheck(this, EnsureIndexOperation);

    _this3 = _super4.call(this, db, collectionName, indexSpec, options);
    _this3.readPreference = read_preference_1.ReadPreference.primary;
    _this3.db = db;
    _this3.collectionName = collectionName;
    return _this3;
  }

  _createClass(EnsureIndexOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this4 = this;

      var indexName = this.indexes[0].name;
      var cursor = this.db.collection(this.collectionName).listIndexes({
        session: session
      });
      cursor.toArray().then(function (indexes) {
        indexes = Array.isArray(indexes) ? indexes : [indexes];

        if (indexes.some(function (index) {
          return index.name === indexName;
        })) {
          callback(undefined, indexName);
          return;
        }

        _get(_getPrototypeOf(EnsureIndexOperation.prototype), "executeCallback", _this4).call(_this4, server, session, callback);
      }, function (error) {
        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          // ignore "NamespaceNotFound" errors
          return _get(_getPrototypeOf(EnsureIndexOperation.prototype), "executeCallback", _this4).call(_this4, server, session, callback);
        }

        return callback(error);
      });
    }
  }]);

  return EnsureIndexOperation;
}(CreateIndexOperation);

exports.EnsureIndexOperation = EnsureIndexOperation;
/** @internal */

var DropIndexOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DropIndexOperation, _command_1$CommandOpe2);

  var _super5 = _createSuper(DropIndexOperation);

  function DropIndexOperation(collection, indexName, options) {
    var _this5;

    _classCallCheck(this, DropIndexOperation);

    _this5 = _super5.call(this, collection, options);
    _this5.options = options !== null && options !== void 0 ? options : {};
    _this5.collection = collection;
    _this5.indexName = indexName;
    return _this5;
  }

  _createClass(DropIndexOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var cmd = {
        dropIndexes: this.collection.collectionName,
        index: this.indexName
      };

      _get(_getPrototypeOf(DropIndexOperation.prototype), "executeCommand", this).call(this, server, session, cmd, callback);
    }
  }]);

  return DropIndexOperation;
}(command_1.CommandOperation);

exports.DropIndexOperation = DropIndexOperation;
/** @internal */

var DropIndexesOperation = /*#__PURE__*/function (_DropIndexOperation) {
  _inherits(DropIndexesOperation, _DropIndexOperation);

  var _super6 = _createSuper(DropIndexesOperation);

  function DropIndexesOperation(collection, options) {
    _classCallCheck(this, DropIndexesOperation);

    return _super6.call(this, collection, '*', options);
  }

  _createClass(DropIndexesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(DropIndexesOperation.prototype), "executeCallback", this).call(this, server, session, function (err) {
        if (err) return callback(err, false);
        callback(undefined, true);
      });
    }
  }]);

  return DropIndexesOperation;
}(DropIndexOperation);

exports.DropIndexesOperation = DropIndexesOperation;
/** @internal */

var ListIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe3) {
  _inherits(ListIndexesOperation, _command_1$CommandOpe3);

  var _super7 = _createSuper(ListIndexesOperation);

  function ListIndexesOperation(collection, options) {
    var _this6;

    _classCallCheck(this, ListIndexesOperation);

    _this6 = _super7.call(this, collection, options);
    _this6.options = _objectSpread({}, options);
    delete _this6.options.writeConcern;
    _this6.collectionNamespace = collection.s.namespace;
    return _this6;
  }

  _createClass(ListIndexesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var cursor = this.options.batchSize ? {
        batchSize: this.options.batchSize
      } : {};
      var command = {
        listIndexes: this.collectionNamespace.collection,
        cursor: cursor
      }; // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax

      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }

      _get(_getPrototypeOf(ListIndexesOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return ListIndexesOperation;
}(command_1.CommandOperation);

exports.ListIndexesOperation = ListIndexesOperation;
/** @internal */

var IndexExistsOperation = /*#__PURE__*/function (_operation_1$Abstract2) {
  _inherits(IndexExistsOperation, _operation_1$Abstract2);

  var _super8 = _createSuper(IndexExistsOperation);

  function IndexExistsOperation(collection, indexes, options) {
    var _this7;

    _classCallCheck(this, IndexExistsOperation);

    _this7 = _super8.call(this, options);
    _this7.options = options;
    _this7.collection = collection;
    _this7.indexes = indexes;
    return _this7;
  }

  _createClass(IndexExistsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      var indexes = this.indexes;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({}, this.options), {}, {
        readPreference: this.readPreference,
        session: session
      }), function (err, indexInformation) {
        // If we have an error return
        if (err != null) return callback(err); // Let's check for the index names

        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes

        for (var i = 0; i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return callback(undefined, false);
          }
        } // All keys found return true


        return callback(undefined, true);
      });
    }
  }]);

  return IndexExistsOperation;
}(operation_1.AbstractCallbackOperation);

exports.IndexExistsOperation = IndexExistsOperation;
/** @internal */

var IndexInformationOperation = /*#__PURE__*/function (_operation_1$Abstract3) {
  _inherits(IndexInformationOperation, _operation_1$Abstract3);

  var _super9 = _createSuper(IndexInformationOperation);

  function IndexInformationOperation(db, name, options) {
    var _this8;

    _classCallCheck(this, IndexInformationOperation);

    _this8 = _super9.call(this, options);
    _this8.options = options !== null && options !== void 0 ? options : {};
    _this8.db = db;
    _this8.name = name;
    return _this8;
  }

  _createClass(IndexInformationOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var db = this.db;
      var name = this.name;
      (0, common_functions_1.indexInformation)(db, name, _objectSpread(_objectSpread({}, this.options), {}, {
        readPreference: this.readPreference,
        session: session
      }), callback);
    }
  }]);

  return IndexInformationOperation;
}(operation_1.AbstractCallbackOperation);

exports.IndexInformationOperation = IndexInformationOperation;
(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);
(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 3583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;

var error_1 = __webpack_require__(9525);

var write_concern_1 = __webpack_require__(6916);

var bulk_write_1 = __webpack_require__(847);

var command_1 = __webpack_require__(9507);

var common_functions_1 = __webpack_require__(9230);

var operation_1 = __webpack_require__(4797);
/** @internal */


var InsertOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(InsertOperation, _command_1$CommandOpe);

  var _super = _createSuper(InsertOperation);

  function InsertOperation(ns, documents, options) {
    var _options$checkKeys;

    var _this;

    _classCallCheck(this, InsertOperation);

    _this = _super.call(this, undefined, options);
    _this.options = _objectSpread(_objectSpread({}, options), {}, {
      checkKeys: (_options$checkKeys = options.checkKeys) !== null && _options$checkKeys !== void 0 ? _options$checkKeys : false
    });
    _this.ns = ns;
    _this.documents = documents;
    return _this;
  }

  _createClass(InsertOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this$options;

      var options = (_this$options = this.options) !== null && _this$options !== void 0 ? _this$options : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered: ordered
      };

      if (typeof options.bypassDocumentValidation === 'boolean') {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      _get(_getPrototypeOf(InsertOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return InsertOperation;
}(command_1.CommandOperation);

exports.InsertOperation = InsertOperation;

var InsertOneOperation = /*#__PURE__*/function (_InsertOperation) {
  _inherits(InsertOneOperation, _InsertOperation);

  var _super2 = _createSuper(InsertOneOperation);

  function InsertOneOperation(collection, doc, options) {
    _classCallCheck(this, InsertOneOperation);

    return _super2.call(this, collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);
  }

  _createClass(InsertOneOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      _get(_getPrototypeOf(InsertOneOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref, _this2$writeConcern;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));

        if (res.writeErrors) {
          // This should be a WriteError but we can't change it now because of error hierarchy
          return callback(new error_1.MongoServerError(res.writeErrors[0]));
        }

        callback(undefined, {
          acknowledged: (_ref = ((_this2$writeConcern = _this2.writeConcern) === null || _this2$writeConcern === void 0 ? void 0 : _this2$writeConcern.w) !== 0) !== null && _ref !== void 0 ? _ref : true,
          insertedId: _this2.documents[0]._id
        });
      });
    }
  }]);

  return InsertOneOperation;
}(InsertOperation);

exports.InsertOneOperation = InsertOneOperation;
/** @internal */

var InsertManyOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(InsertManyOperation, _operation_1$Abstract);

  var _super3 = _createSuper(InsertManyOperation);

  function InsertManyOperation(collection, docs, options) {
    var _this3;

    _classCallCheck(this, InsertManyOperation);

    _this3 = _super3.call(this, options);

    if (!Array.isArray(docs)) {
      throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
    }

    _this3.options = options;
    _this3.collection = collection;
    _this3.docs = docs;
    return _this3;
  }

  _createClass(InsertManyOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference
      });

      var writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      var bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(function (document) {
        return {
          insertOne: {
            document: document
          }
        };
      }), options);
      bulkWriteOperation.executeCallback(server, session, function (err, res) {
        var _ref2;

        if (err || res == null) {
          if (err && err.message === 'Operation must be an object with an operation key') {
            err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');
          }

          return callback(err);
        }

        callback(undefined, {
          acknowledged: (_ref2 = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _ref2 !== void 0 ? _ref2 : true,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        });
      });
    }
  }]);

  return InsertManyOperation;
}(operation_1.AbstractCallbackOperation);

exports.InsertManyOperation = InsertManyOperation;
(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 4785:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IsCappedOperation = void 0;

var error_1 = __webpack_require__(9525);

var operation_1 = __webpack_require__(4797);
/** @internal */


var IsCappedOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(IsCappedOperation, _operation_1$Abstract);

  var _super = _createSuper(IsCappedOperation);

  function IsCappedOperation(collection, options) {
    var _this;

    _classCallCheck(this, IsCappedOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(IsCappedOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      coll.s.db.listCollections({
        name: coll.collectionName
      }, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: false,
        readPreference: this.readPreference,
        session: session
      })).toArray().then(function (collections) {
        var _collections$0$option;

        if (collections.length === 0) {
          // TODO(NODE-3485)
          return callback(new error_1.MongoAPIError("collection ".concat(coll.namespace, " not found")));
        }

        callback(undefined, !!((_collections$0$option = collections[0].options) !== null && _collections$0$option !== void 0 && _collections$0$option.capped));
      }, function (error) {
        return callback(error);
      });
    }
  }]);

  return IsCappedOperation;
}(operation_1.AbstractCallbackOperation);

exports.IsCappedOperation = IsCappedOperation;

/***/ }),

/***/ 7165:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KillCursorsOperation = void 0;

var error_1 = __webpack_require__(9525);

var operation_1 = __webpack_require__(4797);

var KillCursorsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(KillCursorsOperation, _operation_1$Abstract);

  var _super = _createSuper(KillCursorsOperation);

  function KillCursorsOperation(cursorId, ns, server, options) {
    var _this;

    _classCallCheck(this, KillCursorsOperation);

    _this = _super.call(this, options);
    _this.ns = ns;
    _this.cursorId = cursorId;
    _this.server = server;
    return _this;
  }

  _createClass(KillCursorsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      if (server !== this.server) {
        return callback(new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on'));
      }

      var killCursors = this.ns.collection;

      if (killCursors == null) {
        // Cursors should have adopted the namespace returned by MongoDB
        // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
        return callback(new error_1.MongoRuntimeError('A collection name must be determined before killCursors'));
      }

      var killCursorsCommand = {
        killCursors: killCursors,
        cursors: [this.cursorId]
      };
      server.command(this.ns, killCursorsCommand, {
        session: session
      }, function () {
        return callback();
      });
    }
  }]);

  return KillCursorsOperation;
}(operation_1.AbstractCallbackOperation);

exports.KillCursorsOperation = KillCursorsOperation;
(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);

/***/ }),

/***/ 1328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListCollectionsOperation = void 0;

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var ListCollectionsOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ListCollectionsOperation, _command_1$CommandOpe);

  var _super = _createSuper(ListCollectionsOperation);

  function ListCollectionsOperation(db, filter, options) {
    var _this;

    _classCallCheck(this, ListCollectionsOperation);

    _this = _super.call(this, db, options);
    _this.options = _objectSpread({}, options);
    delete _this.options.writeConcern;
    _this.db = db;
    _this.filter = filter;
    _this.nameOnly = !!_this.options.nameOnly;
    _this.authorizedCollections = !!_this.options.authorizedCollections;

    if (typeof _this.options.batchSize === 'number') {
      _this.batchSize = _this.options.batchSize;
    }

    return _this;
  }

  _createClass(ListCollectionsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      return _get(_getPrototypeOf(ListCollectionsOperation.prototype), "executeCommand", this).call(this, server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), callback);
    }
    /* This is here for the purpose of unit testing the final command that gets sent. */

  }, {
    key: "generateCommand",
    value: function generateCommand(wireVersion) {
      var command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? {
          batchSize: this.batchSize
        } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      }; // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax

      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }

      return command;
    }
  }]);

  return ListCollectionsOperation;
}(command_1.CommandOperation);

exports.ListCollectionsOperation = ListCollectionsOperation;
(0, operation_1.defineAspects)(ListCollectionsOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListDatabasesOperation = void 0;

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var ListDatabasesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ListDatabasesOperation, _command_1$CommandOpe);

  var _super = _createSuper(ListDatabasesOperation);

  function ListDatabasesOperation(db, options) {
    var _this;

    _classCallCheck(this, ListDatabasesOperation);

    _this = _super.call(this, db, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');
    return _this;
  }

  _createClass(ListDatabasesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var cmd = {
        listDatabases: 1
      };

      if (typeof this.options.nameOnly === 'boolean') {
        cmd.nameOnly = this.options.nameOnly;
      }

      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }

      if (typeof this.options.authorizedDatabases === 'boolean') {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }

      _get(_getPrototypeOf(ListDatabasesOperation.prototype), "executeCommand", this).call(this, server, session, cmd, callback);
    }
  }]);

  return ListDatabasesOperation;
}(command_1.CommandOperation);

exports.ListDatabasesOperation = ListDatabasesOperation;
(0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);

/***/ }),

/***/ 4797:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defineAspects = exports.AbstractCallbackOperation = exports.AbstractOperation = exports.Aspect = void 0;

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(4356);

var read_preference_1 = __webpack_require__(4064);

exports.Aspect = {
  READ_OPERATION: Symbol('READ_OPERATION'),
  WRITE_OPERATION: Symbol('WRITE_OPERATION'),
  RETRYABLE: Symbol('RETRYABLE'),
  EXPLAINABLE: Symbol('EXPLAINABLE'),
  SKIP_COLLATION: Symbol('SKIP_COLLATION'),
  CURSOR_CREATING: Symbol('CURSOR_CREATING'),
  MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
};
/** @internal */

var kSession = Symbol('session');
/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */

var AbstractOperation = /*#__PURE__*/function () {
  function AbstractOperation() {
    var _read_preference_1$Re;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AbstractOperation);

    this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : (_read_preference_1$Re = read_preference_1.ReadPreference.fromOptions(options)) !== null && _read_preference_1$Re !== void 0 ? _read_preference_1$Re : read_preference_1.ReadPreference.primary; // Pull the BSON serialize options from the already-resolved options

    this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
    this[kSession] = options.session != null ? options.session : undefined;
    this.options = options;
    this.bypassPinningCheck = !!options.bypassPinningCheck;
    this.trySecondaryWrite = false;
  }

  _createClass(AbstractOperation, [{
    key: "hasAspect",
    value: function hasAspect(aspect) {
      var ctor = this.constructor;

      if (ctor.aspects == null) {
        return false;
      }

      return ctor.aspects.has(aspect);
    }
  }, {
    key: "session",
    get: function get() {
      return this[kSession];
    }
  }, {
    key: "clearSession",
    value: function clearSession() {
      this[kSession] = undefined;
    }
  }, {
    key: "canRetryRead",
    get: function get() {
      return true;
    }
  }, {
    key: "canRetryWrite",
    get: function get() {
      return true;
    }
  }]);

  return AbstractOperation;
}();

exports.AbstractOperation = AbstractOperation;
/** @internal */

var AbstractCallbackOperation = /*#__PURE__*/function (_AbstractOperation) {
  _inherits(AbstractCallbackOperation, _AbstractOperation);

  var _super = _createSuper(AbstractCallbackOperation);

  function AbstractCallbackOperation() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AbstractCallbackOperation);

    return _super.call(this, options);
  }

  _createClass(AbstractCallbackOperation, [{
    key: "execute",
    value: function execute(server, session) {
      var _this = this;

      return (0, util_1.promisify)(function (callback) {
        _this.executeCallback(server, session, callback);
      })();
    }
  }]);

  return AbstractCallbackOperation;
}(AbstractOperation);

exports.AbstractCallbackOperation = AbstractCallbackOperation;

function defineAspects(operation, aspects) {
  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
    aspects = [aspects];
  }

  aspects = new Set(aspects);
  Object.defineProperty(operation, 'aspects', {
    value: aspects,
    writable: false
  });
  return aspects;
}

exports.defineAspects = defineAspects;

/***/ }),

/***/ 6687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionsOperation = void 0;

var error_1 = __webpack_require__(9525);

var operation_1 = __webpack_require__(4797);
/** @internal */


var OptionsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(OptionsOperation, _operation_1$Abstract);

  var _super = _createSuper(OptionsOperation);

  function OptionsOperation(collection, options) {
    var _this;

    _classCallCheck(this, OptionsOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(OptionsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var coll = this.collection;
      coll.s.db.listCollections({
        name: coll.collectionName
      }, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: false,
        readPreference: this.readPreference,
        session: session
      })).toArray().then(function (collections) {
        if (collections.length === 0) {
          // TODO(NODE-3485)
          return callback(new error_1.MongoAPIError("collection ".concat(coll.namespace, " not found")));
        }

        callback(undefined, collections[0].options);
      }, function (error) {
        return callback(error);
      });
    }
  }]);

  return OptionsOperation;
}(operation_1.AbstractCallbackOperation);

exports.OptionsOperation = OptionsOperation;

/***/ }),

/***/ 3157:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProfilingLevelOperation = void 0;

var error_1 = __webpack_require__(9525);

var command_1 = __webpack_require__(9507);
/** @internal */


var ProfilingLevelOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ProfilingLevelOperation, _command_1$CommandOpe);

  var _super = _createSuper(ProfilingLevelOperation);

  function ProfilingLevelOperation(db, options) {
    var _this;

    _classCallCheck(this, ProfilingLevelOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    return _this;
  }

  _createClass(ProfilingLevelOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(ProfilingLevelOperation.prototype), "executeCommand", this).call(this, server, session, {
        profile: -1
      }, function (err, doc) {
        if (err == null && doc.ok === 1) {
          var was = doc.was;
          if (was === 0) return callback(undefined, 'off');
          if (was === 1) return callback(undefined, 'slow_only');
          if (was === 2) return callback(undefined, 'all'); // TODO(NODE-3483)

          return callback(new error_1.MongoRuntimeError("Illegal profiling level value ".concat(was)));
        } else {
          // TODO(NODE-3483): Consider MongoUnexpectedServerResponseError
          err != null ? callback(err) : callback(new error_1.MongoRuntimeError('Error with profile command'));
        }
      });
    }
  }]);

  return ProfilingLevelOperation;
}(command_1.CommandOperation);

exports.ProfilingLevelOperation = ProfilingLevelOperation;

/***/ }),

/***/ 9246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RemoveUserOperation = void 0;

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var RemoveUserOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(RemoveUserOperation, _command_1$CommandOpe);

  var _super = _createSuper(RemoveUserOperation);

  function RemoveUserOperation(db, username, options) {
    var _this;

    _classCallCheck(this, RemoveUserOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    _this.username = username;
    return _this;
  }

  _createClass(RemoveUserOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      _get(_getPrototypeOf(RemoveUserOperation.prototype), "executeCommand", this).call(this, server, session, {
        dropUser: this.username
      }, function (err) {
        callback(err, err ? false : true);
      });
    }
  }]);

  return RemoveUserOperation;
}(command_1.CommandOperation);

exports.RemoveUserOperation = RemoveUserOperation;
(0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 116:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RenameOperation = void 0;

var collection_1 = __webpack_require__(9816);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var operation_1 = __webpack_require__(4797);

var run_command_1 = __webpack_require__(6621);
/** @internal */


var RenameOperation = /*#__PURE__*/function (_run_command_1$RunAdm) {
  _inherits(RenameOperation, _run_command_1$RunAdm);

  var _super = _createSuper(RenameOperation);

  function RenameOperation(collection, newName, options) {
    var _this;

    _classCallCheck(this, RenameOperation);

    // Check the collection name
    (0, utils_1.checkCollectionName)(newName); // Build the command

    var renameCollection = collection.namespace;
    var toCollection = collection.s.namespace.withCollection(newName).toString();
    var dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
    var cmd = {
      renameCollection: renameCollection,
      to: toCollection,
      dropTarget: dropTarget
    };
    _this = _super.call(this, collection, cmd, options);
    _this.options = options;
    _this.collection = collection;
    _this.newName = newName;
    return _this;
  }

  _createClass(RenameOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this2 = this;

      var coll = this.collection;

      _get(_getPrototypeOf(RenameOperation.prototype), "executeCallback", this).call(this, server, session, function (err, doc) {
        if (err) return callback(err); // We have an error

        if (doc !== null && doc !== void 0 && doc.errmsg) {
          return callback(new error_1.MongoServerError(doc));
        }

        var newColl;

        try {
          newColl = new collection_1.Collection(coll.s.db, _this2.newName, coll.s.options);
        } catch (err) {
          return callback(err);
        }

        return callback(undefined, newColl);
      });
    }
  }]);

  return RenameOperation;
}(run_command_1.RunAdminCommandOperation);

exports.RenameOperation = RenameOperation;
(0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 6621:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RunAdminCommandOperation = exports.RunCommandOperation = void 0;

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);
/** @internal */


var RunCommandOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(RunCommandOperation, _command_1$CommandOpe);

  var _super = _createSuper(RunCommandOperation);

  function RunCommandOperation(parent, command, options) {
    var _this;

    _classCallCheck(this, RunCommandOperation);

    _this = _super.call(this, parent, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.command = command;
    return _this;
  }

  _createClass(RunCommandOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var command = this.command;
      this.executeCommand(server, session, command, callback);
    }
  }]);

  return RunCommandOperation;
}(command_1.CommandOperation);

exports.RunCommandOperation = RunCommandOperation;

var RunAdminCommandOperation = /*#__PURE__*/function (_RunCommandOperation) {
  _inherits(RunAdminCommandOperation, _RunCommandOperation);

  var _super2 = _createSuper(RunAdminCommandOperation);

  function RunAdminCommandOperation(parent, command, options) {
    var _this2;

    _classCallCheck(this, RunAdminCommandOperation);

    _this2 = _super2.call(this, parent, command, options);
    _this2.ns = new utils_1.MongoDBNamespace('admin');
    return _this2;
  }

  return _createClass(RunAdminCommandOperation);
}(RunCommandOperation);

exports.RunAdminCommandOperation = RunAdminCommandOperation;

/***/ }),

/***/ 9471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CreateSearchIndexesOperation = void 0;

var operation_1 = __webpack_require__(4797);
/** @internal */


var CreateSearchIndexesOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(CreateSearchIndexesOperation, _operation_1$Abstract);

  var _super = _createSuper(CreateSearchIndexesOperation);

  function CreateSearchIndexesOperation(collection, descriptions) {
    var _this;

    _classCallCheck(this, CreateSearchIndexesOperation);

    _this = _super.call(this);
    _this.collection = collection;
    _this.descriptions = descriptions;
    return _this;
  }

  _createClass(CreateSearchIndexesOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var namespace = this.collection.fullNamespace;
      var command = {
        createSearchIndexes: namespace.collection,
        indexes: this.descriptions
      };
      server.command(namespace, command, {
        session: session
      }, function (err, res) {
        var _res$indexesCreated;

        if (err || !res) {
          callback(err);
          return;
        }

        var indexesCreated = (_res$indexesCreated = res === null || res === void 0 ? void 0 : res.indexesCreated) !== null && _res$indexesCreated !== void 0 ? _res$indexesCreated : [];
        callback(undefined, indexesCreated.map(function (_ref) {
          var name = _ref.name;
          return name;
        }));
      });
    }
  }]);

  return CreateSearchIndexesOperation;
}(operation_1.AbstractCallbackOperation);

exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;

/***/ }),

/***/ 8655:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DropSearchIndexOperation = void 0;

var operation_1 = __webpack_require__(4797);
/** @internal */


var DropSearchIndexOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(DropSearchIndexOperation, _operation_1$Abstract);

  var _super = _createSuper(DropSearchIndexOperation);

  function DropSearchIndexOperation(collection, name) {
    var _this;

    _classCallCheck(this, DropSearchIndexOperation);

    _this = _super.call(this);
    _this.collection = collection;
    _this.name = name;
    return _this;
  }

  _createClass(DropSearchIndexOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var namespace = this.collection.fullNamespace;
      var command = {
        dropSearchIndex: namespace.collection
      };

      if (typeof this.name === 'string') {
        command.name = this.name;
      }

      server.command(namespace, command, {
        session: session
      }, function (err) {
        if (err) {
          callback(err);
          return;
        }

        callback();
      });
    }
  }]);

  return DropSearchIndexOperation;
}(operation_1.AbstractCallbackOperation);

exports.DropSearchIndexOperation = DropSearchIndexOperation;

/***/ }),

/***/ 1391:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UpdateSearchIndexOperation = void 0;

var operation_1 = __webpack_require__(4797);
/** @internal */


var UpdateSearchIndexOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(UpdateSearchIndexOperation, _operation_1$Abstract);

  var _super = _createSuper(UpdateSearchIndexOperation);

  function UpdateSearchIndexOperation(collection, name, definition) {
    var _this;

    _classCallCheck(this, UpdateSearchIndexOperation);

    _this = _super.call(this);
    _this.collection = collection;
    _this.name = name;
    _this.definition = definition;
    return _this;
  }

  _createClass(UpdateSearchIndexOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var namespace = this.collection.fullNamespace;
      var command = {
        updateSearchIndex: namespace.collection,
        name: this.name,
        definition: this.definition
      };
      server.command(namespace, command, {
        session: session
      }, function (err) {
        if (err) {
          callback(err);
          return;
        }

        callback();
      });
    }
  }]);

  return UpdateSearchIndexOperation;
}(operation_1.AbstractCallbackOperation);

exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;

/***/ }),

/***/ 3705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SetProfilingLevelOperation = exports.ProfilingLevel = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var levelValues = new Set(['off', 'slow_only', 'all']);
/** @public */

exports.ProfilingLevel = Object.freeze({
  off: 'off',
  slowOnly: 'slow_only',
  all: 'all'
});
/** @internal */

var SetProfilingLevelOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(SetProfilingLevelOperation, _command_1$CommandOpe);

  var _super = _createSuper(SetProfilingLevelOperation);

  function SetProfilingLevelOperation(db, level, options) {
    var _this;

    _classCallCheck(this, SetProfilingLevelOperation);

    _this = _super.call(this, db, options);
    _this.options = options;

    switch (level) {
      case exports.ProfilingLevel.off:
        _this.profile = 0;
        break;

      case exports.ProfilingLevel.slowOnly:
        _this.profile = 1;
        break;

      case exports.ProfilingLevel.all:
        _this.profile = 2;
        break;

      default:
        _this.profile = 0;
        break;
    }

    _this.level = level;
    return _this;
  }

  _createClass(SetProfilingLevelOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var level = this.level;

      if (!levelValues.has(level)) {
        return callback(new error_1.MongoInvalidArgumentError("Profiling level must be one of \"".concat((0, utils_1.enumToString)(exports.ProfilingLevel), "\"")));
      } // TODO(NODE-3483): Determine error to put here


      _get(_getPrototypeOf(SetProfilingLevelOperation.prototype), "executeCommand", this).call(this, server, session, {
        profile: this.profile
      }, function (err, doc) {
        if (err == null && doc.ok === 1) return callback(undefined, level);
        return err != null ? callback(err) : callback(new error_1.MongoRuntimeError('Error with profile command'));
      });
    }
  }]);

  return SetProfilingLevelOperation;
}(command_1.CommandOperation);

exports.SetProfilingLevelOperation = SetProfilingLevelOperation;

/***/ }),

/***/ 5142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DbStatsOperation = exports.CollStatsOperation = void 0;

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/**
 * Get all the collection statistics.
 * @internal
 */


var CollStatsOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CollStatsOperation, _command_1$CommandOpe);

  var _super = _createSuper(CollStatsOperation);

  /**
   * Construct a Stats operation.
   *
   * @param collection - Collection instance
   * @param options - Optional settings. See Collection.prototype.stats for a list of options.
   */
  function CollStatsOperation(collection, options) {
    var _this;

    _classCallCheck(this, CollStatsOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.collectionName = collection.collectionName;
    return _this;
  }

  _createClass(CollStatsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var command = {
        collStats: this.collectionName
      };

      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }

      _get(_getPrototypeOf(CollStatsOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return CollStatsOperation;
}(command_1.CommandOperation);

exports.CollStatsOperation = CollStatsOperation;
/** @internal */

var DbStatsOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DbStatsOperation, _command_1$CommandOpe2);

  var _super2 = _createSuper(DbStatsOperation);

  function DbStatsOperation(db, options) {
    var _this2;

    _classCallCheck(this, DbStatsOperation);

    _this2 = _super2.call(this, db, options);
    _this2.options = options;
    return _this2;
  }

  _createClass(DbStatsOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var command = {
        dbStats: true
      };

      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }

      _get(_getPrototypeOf(DbStatsOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return DbStatsOperation;
}(command_1.CommandOperation);

exports.DbStatsOperation = DbStatsOperation;
(0, operation_1.defineAspects)(CollStatsOperation, [operation_1.Aspect.READ_OPERATION]);
(0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);

/***/ }),

/***/ 8679:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeUpdateStatement = exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = void 0;

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var command_1 = __webpack_require__(9507);

var operation_1 = __webpack_require__(4797);
/** @internal */


var UpdateOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(UpdateOperation, _command_1$CommandOpe);

  var _super = _createSuper(UpdateOperation);

  function UpdateOperation(ns, statements, options) {
    var _this;

    _classCallCheck(this, UpdateOperation);

    _this = _super.call(this, undefined, options);
    _this.options = options;
    _this.ns = ns;
    _this.statements = statements;
    return _this;
  }

  _createClass(UpdateOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (_get(_getPrototypeOf(UpdateOperation.prototype), "canRetryWrite", this) === false) {
        return false;
      }

      return this.statements.every(function (op) {
        return op.multi == null || op.multi === false;
      });
    }
  }, {
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this$options;

      var options = (_this$options = this.options) !== null && _this$options !== void 0 ? _this$options : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered: ordered
      };

      if (typeof options.bypassDocumentValidation === 'boolean') {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      var unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;

      if (unacknowledgedWrite) {
        if (this.statements.find(function (o) {
          return o.hint;
        })) {
          // TODO(NODE-3541): fix error for hint with unacknowledged writes
          callback(new error_1.MongoCompatibilityError("hint is not supported with unacknowledged writes"));
          return;
        }
      }

      _get(_getPrototypeOf(UpdateOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return UpdateOperation;
}(command_1.CommandOperation);

exports.UpdateOperation = UpdateOperation;
/** @internal */

var UpdateOneOperation = /*#__PURE__*/function (_UpdateOperation) {
  _inherits(UpdateOneOperation, _UpdateOperation);

  var _super2 = _createSuper(UpdateOneOperation);

  function UpdateOneOperation(collection, filter, update, options) {
    var _this2;

    _classCallCheck(this, UpdateOneOperation);

    _this2 = _super2.call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread(_objectSpread({}, options), {}, {
      multi: false
    }))], options);

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    return _this2;
  }

  _createClass(UpdateOneOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(UpdateOneOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref, _this3$writeConcern;

        if (err || !res) return callback(err);
        if (_this3.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_ref = ((_this3$writeConcern = _this3.writeConcern) === null || _this3$writeConcern === void 0 ? void 0 : _this3$writeConcern.w) !== 0) !== null && _ref !== void 0 ? _ref : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return UpdateOneOperation;
}(UpdateOperation);

exports.UpdateOneOperation = UpdateOneOperation;
/** @internal */

var UpdateManyOperation = /*#__PURE__*/function (_UpdateOperation2) {
  _inherits(UpdateManyOperation, _UpdateOperation2);

  var _super3 = _createSuper(UpdateManyOperation);

  function UpdateManyOperation(collection, filter, update, options) {
    var _this4;

    _classCallCheck(this, UpdateManyOperation);

    _this4 = _super3.call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread(_objectSpread({}, options), {}, {
      multi: true
    }))], options);

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    return _this4;
  }

  _createClass(UpdateManyOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this5 = this;

      _get(_getPrototypeOf(UpdateManyOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref2, _this5$writeConcern;

        if (err || !res) return callback(err);
        if (_this5.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_ref2 = ((_this5$writeConcern = _this5.writeConcern) === null || _this5$writeConcern === void 0 ? void 0 : _this5$writeConcern.w) !== 0) !== null && _ref2 !== void 0 ? _ref2 : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return UpdateManyOperation;
}(UpdateOperation);

exports.UpdateManyOperation = UpdateManyOperation;
/** @internal */

var ReplaceOneOperation = /*#__PURE__*/function (_UpdateOperation3) {
  _inherits(ReplaceOneOperation, _UpdateOperation3);

  var _super4 = _createSuper(ReplaceOneOperation);

  function ReplaceOneOperation(collection, filter, replacement, options) {
    var _this6;

    _classCallCheck(this, ReplaceOneOperation);

    _this6 = _super4.call(this, collection.s.namespace, [makeUpdateStatement(filter, replacement, _objectSpread(_objectSpread({}, options), {}, {
      multi: false
    }))], options);

    if ((0, utils_1.hasAtomicOperators)(replacement)) {
      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
    }

    return _this6;
  }

  _createClass(ReplaceOneOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var _this7 = this;

      _get(_getPrototypeOf(ReplaceOneOperation.prototype), "executeCallback", this).call(this, server, session, function (err, res) {
        var _ref3, _this7$writeConcern;

        if (err || !res) return callback(err);
        if (_this7.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_ref3 = ((_this7$writeConcern = _this7.writeConcern) === null || _this7$writeConcern === void 0 ? void 0 : _this7$writeConcern.w) !== 0) !== null && _ref3 !== void 0 ? _ref3 : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return ReplaceOneOperation;
}(UpdateOperation);

exports.ReplaceOneOperation = ReplaceOneOperation;

function makeUpdateStatement(filter, update, options) {
  if (filter == null || _typeof(filter) !== 'object') {
    throw new error_1.MongoInvalidArgumentError('Selector must be a valid JavaScript object');
  }

  if (update == null || _typeof(update) !== 'object') {
    throw new error_1.MongoInvalidArgumentError('Document must be a valid JavaScript object');
  }

  var op = {
    q: filter,
    u: update
  };

  if (typeof options.upsert === 'boolean') {
    op.upsert = options.upsert;
  }

  if (options.multi) {
    op.multi = options.multi;
  }

  if (options.hint) {
    op.hint = options.hint;
  }

  if (options.arrayFilters) {
    op.arrayFilters = options.arrayFilters;
  }

  if (options.collation) {
    op.collation = options.collation;
  }

  return op;
}

exports.makeUpdateStatement = makeUpdateStatement;
(0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(UpdateOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(UpdateManyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(ReplaceOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);

/***/ }),

/***/ 6735:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ValidateCollectionOperation = void 0;

var error_1 = __webpack_require__(9525);

var command_1 = __webpack_require__(9507);
/** @internal */


var ValidateCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ValidateCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(ValidateCollectionOperation);

  function ValidateCollectionOperation(admin, collectionName, options) {
    var _this;

    _classCallCheck(this, ValidateCollectionOperation);

    // Decorate command with extra options
    var command = {
      validate: collectionName
    };
    var keys = Object.keys(options);

    for (var i = 0; i < keys.length; i++) {
      if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {
        command[keys[i]] = options[keys[i]];
      }
    }

    _this = _super.call(this, admin.s.db, options);
    _this.options = options;
    _this.command = command;
    _this.collectionName = collectionName;
    return _this;
  }

  _createClass(ValidateCollectionOperation, [{
    key: "executeCallback",
    value: function executeCallback(server, session, callback) {
      var collectionName = this.collectionName;

      _get(_getPrototypeOf(ValidateCollectionOperation.prototype), "executeCommand", this).call(this, server, session, this.command, function (err, doc) {
        if (err != null) return callback(err); // TODO(NODE-3483): Replace these with MongoUnexpectedServerResponseError

        if (doc.ok === 0) return callback(new error_1.MongoRuntimeError('Error with validate command'));
        if (doc.result != null && typeof doc.result !== 'string') return callback(new error_1.MongoRuntimeError('Error with validation data'));
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null) return callback(new error_1.MongoRuntimeError("Invalid collection ".concat(collectionName)));
        if (doc.valid != null && !doc.valid) return callback(new error_1.MongoRuntimeError("Invalid collection ".concat(collectionName)));
        return callback(undefined, doc);
      });
    }
  }]);

  return ValidateCollectionOperation;
}(command_1.CommandOperation);

exports.ValidateCollectionOperation = ValidateCollectionOperation;

/***/ }),

/***/ 2445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReadConcern = exports.ReadConcernLevel = void 0;
/** @public */

exports.ReadConcernLevel = Object.freeze({
  local: 'local',
  majority: 'majority',
  linearizable: 'linearizable',
  available: 'available',
  snapshot: 'snapshot'
});
/**
 * The MongoDB ReadConcern, which allows for control of the consistency and isolation properties
 * of the data read from replica sets and replica set shards.
 * @public
 *
 * @see https://www.mongodb.com/docs/manual/reference/read-concern/index.html
 */

var ReadConcern = /*#__PURE__*/function () {
  /** Constructs a ReadConcern from the read concern level.*/
  function ReadConcern(level) {
    var _exports$ReadConcernL;

    _classCallCheck(this, ReadConcern);

    /**
     * A spec test exists that allows level to be any string.
     * "invalid readConcern with out stage"
     * @see ./test/spec/crud/v2/aggregate-out-readConcern.json
     * @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#unknown-levels-and-additional-options-for-string-based-readconcerns
     */
    this.level = (_exports$ReadConcernL = exports.ReadConcernLevel[level]) !== null && _exports$ReadConcernL !== void 0 ? _exports$ReadConcernL : level;
  }
  /**
   * Construct a ReadConcern given an options object.
   *
   * @param options - The options object from which to extract the write concern.
   */


  _createClass(ReadConcern, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        level: this.level
      };
    }
  }], [{
    key: "fromOptions",
    value: function fromOptions(options) {
      if (options == null) {
        return;
      }

      if (options.readConcern) {
        var readConcern = options.readConcern;

        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === 'string') {
          return new ReadConcern(readConcern);
        } else if ('level' in readConcern && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }

      if (options.level) {
        return new ReadConcern(options.level);
      }

      return;
    }
  }, {
    key: "MAJORITY",
    get: function get() {
      return exports.ReadConcernLevel.majority;
    }
  }, {
    key: "AVAILABLE",
    get: function get() {
      return exports.ReadConcernLevel.available;
    }
  }, {
    key: "LINEARIZABLE",
    get: function get() {
      return exports.ReadConcernLevel.linearizable;
    }
  }, {
    key: "SNAPSHOT",
    get: function get() {
      return exports.ReadConcernLevel.snapshot;
    }
  }]);

  return ReadConcern;
}();

exports.ReadConcern = ReadConcern;

/***/ }),

/***/ 4064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReadPreference = exports.ReadPreferenceMode = void 0;

var error_1 = __webpack_require__(9525);
/** @public */


exports.ReadPreferenceMode = Object.freeze({
  primary: 'primary',
  primaryPreferred: 'primaryPreferred',
  secondary: 'secondary',
  secondaryPreferred: 'secondaryPreferred',
  nearest: 'nearest'
});
/**
 * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
 * used to construct connections.
 * @public
 *
 * @see https://www.mongodb.com/docs/manual/core/read-preference/
 */

var ReadPreference = /*#__PURE__*/function () {
  /**
   * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
   * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
   * @param options - Additional read preference options
   */
  function ReadPreference(mode, tags, options) {
    var _options, _options2;

    _classCallCheck(this, ReadPreference);

    if (!ReadPreference.isValid(mode)) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference mode ".concat(JSON.stringify(mode)));
    }

    if (options == null && _typeof(tags) === 'object' && !Array.isArray(tags)) {
      options = tags;
      tags = undefined;
    } else if (tags && !Array.isArray(tags)) {
      throw new error_1.MongoInvalidArgumentError('ReadPreference tags must be an array');
    }

    this.mode = mode;
    this.tags = tags;
    this.hedge = (_options = options) === null || _options === void 0 ? void 0 : _options.hedge;
    this.maxStalenessSeconds = undefined;
    this.minWireVersion = undefined;
    options = (_options2 = options) !== null && _options2 !== void 0 ? _options2 : {};

    if (options.maxStalenessSeconds != null) {
      if (options.maxStalenessSeconds <= 0) {
        throw new error_1.MongoInvalidArgumentError('maxStalenessSeconds must be a positive integer');
      }

      this.maxStalenessSeconds = options.maxStalenessSeconds; // NOTE: The minimum required wire version is 5 for this read preference. If the existing
      //       topology has a lower value then a MongoError will be thrown during server selection.

      this.minWireVersion = 5;
    }

    if (this.mode === ReadPreference.PRIMARY) {
      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with tags');
      }

      if (this.maxStalenessSeconds) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with maxStalenessSeconds');
      }

      if (this.hedge) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with hedge');
      }
    }
  } // Support the deprecated `preference` property introduced in the porcelain layer


  _createClass(ReadPreference, [{
    key: "preference",
    get: function get() {
      return this.mode;
    }
  }, {
    key: "isValid",
    value:
    /**
     * Validate if a mode is legal
     *
     * @param mode - The string representing the read preference mode.
     */
    function isValid(mode) {
      return ReadPreference.isValid(typeof mode === 'string' ? mode : this.mode);
    }
    /**
     * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
     * @see https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#op-query
     */

  }, {
    key: "secondaryOk",
    value: function secondaryOk() {
      var NEEDS_SECONDARYOK = new Set([ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    /**
     * Check if the two ReadPreferences are equivalent
     *
     * @param readPreference - The read preference with which to check equality
     */

  }, {
    key: "equals",
    value: function equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    /** Return JSON representation */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var readPreference = {
        mode: this.mode
      };
      if (Array.isArray(this.tags)) readPreference.tags = this.tags;
      if (this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge) readPreference.hedge = this.hedge;
      return readPreference;
    }
  }], [{
    key: "fromString",
    value: function fromString(mode) {
      return new ReadPreference(mode);
    }
    /**
     * Construct a ReadPreference given an options object.
     *
     * @param options - The options object from which to extract the read preference.
     */

  }, {
    key: "fromOptions",
    value: function fromOptions(options) {
      var _options$readPreferen, _options$session;

      if (!options) return;
      var readPreference = (_options$readPreferen = options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : (_options$session = options.session) === null || _options$session === void 0 ? void 0 : _options$session.transaction.options.readPreference;
      var readPreferenceTags = options.readPreferenceTags;

      if (readPreference == null) {
        return;
      }

      if (typeof readPreference === 'string') {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && _typeof(readPreference) === 'object') {
        var mode = readPreference.mode || readPreference.preference;

        if (mode && typeof mode === 'string') {
          var _readPreference$tags;

          return new ReadPreference(mode, (_readPreference$tags = readPreference.tags) !== null && _readPreference$tags !== void 0 ? _readPreference$tags : readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }

      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }

      return readPreference;
    }
    /**
     * Replaces options.readPreference with a ReadPreference instance
     */

  }, {
    key: "translate",
    value: function translate(options) {
      if (options.readPreference == null) return options;
      var r = options.readPreference;

      if (typeof r === 'string') {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && _typeof(r) === 'object') {
        var mode = r.mode || r.preference;

        if (mode && typeof mode === 'string') {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference: ".concat(r));
      }

      return options;
    }
    /**
     * Validate if a mode is legal
     *
     * @param mode - The string representing the read preference mode.
     */

  }, {
    key: "isValid",
    value: function isValid(mode) {
      var VALID_MODES = new Set([ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST, null]);
      return VALID_MODES.has(mode);
    }
  }]);

  return ReadPreference;
}();

ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
exports.ReadPreference = ReadPreference;

/***/ }),

/***/ 2801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._advanceClusterTime = exports.drainTimerQueue = exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = void 0;

var timers_1 = __webpack_require__(9512); // shared state names


exports.STATE_CLOSING = 'closing';
exports.STATE_CLOSED = 'closed';
exports.STATE_CONNECTING = 'connecting';
exports.STATE_CONNECTED = 'connected';
/**
 * An enumeration of topology types we know about
 * @public
 */

exports.TopologyType = Object.freeze({
  Single: 'Single',
  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
  Sharded: 'Sharded',
  Unknown: 'Unknown',
  LoadBalanced: 'LoadBalanced'
});
/**
 * An enumeration of server types we know about
 * @public
 */

exports.ServerType = Object.freeze({
  Standalone: 'Standalone',
  Mongos: 'Mongos',
  PossiblePrimary: 'PossiblePrimary',
  RSPrimary: 'RSPrimary',
  RSSecondary: 'RSSecondary',
  RSArbiter: 'RSArbiter',
  RSOther: 'RSOther',
  RSGhost: 'RSGhost',
  Unknown: 'Unknown',
  LoadBalancer: 'LoadBalancer'
});
/** @internal */

function drainTimerQueue(queue) {
  queue.forEach(timers_1.clearTimeout);
  queue.clear();
}

exports.drainTimerQueue = drainTimerQueue;
/** Shared function to determine clusterTime for a given topology or session */

function _advanceClusterTime(entity, $clusterTime) {
  if (entity.clusterTime == null) {
    entity.clusterTime = $clusterTime;
  } else {
    if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
      entity.clusterTime = $clusterTime;
    }
  }
}

exports._advanceClusterTime = _advanceClusterTime;

/***/ }),

/***/ 468:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = void 0;
/**
 * Emitted when server description changes, but does NOT include changes to the RTT.
 * @public
 * @category Event
 */

var ServerDescriptionChangedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerDescriptionChangedEvent(topologyId, address, previousDescription, newDescription) {
  _classCallCheck(this, ServerDescriptionChangedEvent);

  this.topologyId = topologyId;
  this.address = address;
  this.previousDescription = previousDescription;
  this.newDescription = newDescription;
});

exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
/**
 * Emitted when server is initialized.
 * @public
 * @category Event
 */

var ServerOpeningEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerOpeningEvent(topologyId, address) {
  _classCallCheck(this, ServerOpeningEvent);

  this.topologyId = topologyId;
  this.address = address;
});

exports.ServerOpeningEvent = ServerOpeningEvent;
/**
 * Emitted when server is closed.
 * @public
 * @category Event
 */

var ServerClosedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerClosedEvent(topologyId, address) {
  _classCallCheck(this, ServerClosedEvent);

  this.topologyId = topologyId;
  this.address = address;
});

exports.ServerClosedEvent = ServerClosedEvent;
/**
 * Emitted when topology description changes.
 * @public
 * @category Event
 */

var TopologyDescriptionChangedEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyDescriptionChangedEvent(topologyId, previousDescription, newDescription) {
  _classCallCheck(this, TopologyDescriptionChangedEvent);

  this.topologyId = topologyId;
  this.previousDescription = previousDescription;
  this.newDescription = newDescription;
});

exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
/**
 * Emitted when topology is initialized.
 * @public
 * @category Event
 */

var TopologyOpeningEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyOpeningEvent(topologyId) {
  _classCallCheck(this, TopologyOpeningEvent);

  this.topologyId = topologyId;
});

exports.TopologyOpeningEvent = TopologyOpeningEvent;
/**
 * Emitted when topology is closed.
 * @public
 * @category Event
 */

var TopologyClosedEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyClosedEvent(topologyId) {
  _classCallCheck(this, TopologyClosedEvent);

  this.topologyId = topologyId;
});

exports.TopologyClosedEvent = TopologyClosedEvent;
/**
 * Emitted when the server monitor’s hello command is started - immediately before
 * the hello command is serialized into raw BSON and written to the socket.
 *
 * @public
 * @category Event
 */

var ServerHeartbeatStartedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatStartedEvent(connectionId) {
  _classCallCheck(this, ServerHeartbeatStartedEvent);

  this.connectionId = connectionId;
});

exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
/**
 * Emitted when the server monitor’s hello succeeds.
 * @public
 * @category Event
 */

var ServerHeartbeatSucceededEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatSucceededEvent(connectionId, duration, reply) {
  _classCallCheck(this, ServerHeartbeatSucceededEvent);

  this.connectionId = connectionId;
  this.duration = duration;
  this.reply = reply !== null && reply !== void 0 ? reply : {};
});

exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
/**
 * Emitted when the server monitor’s hello fails, either with an “ok: 0” or a socket exception.
 * @public
 * @category Event
 */

var ServerHeartbeatFailedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatFailedEvent(connectionId, duration, failure) {
  _classCallCheck(this, ServerHeartbeatFailedEvent);

  this.connectionId = connectionId;
  this.duration = duration;
  this.failure = failure;
});

exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;

/***/ }),

/***/ 8849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MonitorInterval = exports.RTTPinger = exports.Monitor = void 0;

var timers_1 = __webpack_require__(9512);

var bson_1 = __webpack_require__(4356);

var connect_1 = __webpack_require__(8338);

var connection_1 = __webpack_require__(9532);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var utils_1 = __webpack_require__(672);

var common_1 = __webpack_require__(2801);

var events_1 = __webpack_require__(468);

var server_1 = __webpack_require__(5030);
/** @internal */


var kServer = Symbol('server');
/** @internal */

var kMonitorId = Symbol('monitorId');
/** @internal */

var kConnection = Symbol('connection');
/** @internal */

var kCancellationToken = Symbol('cancellationToken');
/** @internal */

var kRTTPinger = Symbol('rttPinger');
/** @internal */

var kRoundTripTime = Symbol('roundTripTime');
var STATE_IDLE = 'idle';
var STATE_MONITORING = 'monitoring';
var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, STATE_MONITORING]), _defineProperty(_ref, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING]), _defineProperty(_ref, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]), _ref));
var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);

function isInCloseState(monitor) {
  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
}
/** @internal */


var Monitor = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Monitor, _mongo_types_1$TypedE);

  var _super = _createSuper(Monitor);

  function Monitor(server, options) {
    var _options$connectTimeo, _options$heartbeatFre, _options$minHeartbeat;

    var _this;

    _classCallCheck(this, Monitor);

    _this = _super.call(this);
    _this[kServer] = server;
    _this[kConnection] = undefined;
    _this[kCancellationToken] = new mongo_types_1.CancellationToken();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kMonitorId] = undefined;
    _this.s = {
      state: common_1.STATE_CLOSED
    };
    _this.address = server.description.address;
    _this.options = Object.freeze({
      connectTimeoutMS: (_options$connectTimeo = options.connectTimeoutMS) !== null && _options$connectTimeo !== void 0 ? _options$connectTimeo : 10000,
      heartbeatFrequencyMS: (_options$heartbeatFre = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre !== void 0 ? _options$heartbeatFre : 10000,
      minHeartbeatFrequencyMS: (_options$minHeartbeat = options.minHeartbeatFrequencyMS) !== null && _options$minHeartbeat !== void 0 ? _options$minHeartbeat : 500
    });
    var cancellationToken = _this[kCancellationToken]; // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration

    var connectOptions = Object.assign({
      id: '<monitor>',
      generation: server.pool.generation,
      connectionType: connection_1.Connection,
      cancellationToken: cancellationToken,
      hostAddress: server.description.hostAddress
    }, options, // force BSON serialization options
    {
      raw: false,
      useBigInt64: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: true
    }); // ensure no authentication is used for monitoring

    delete connectOptions.credentials;

    if (connectOptions.autoEncrypter) {
      delete connectOptions.autoEncrypter;
    }

    _this.connectOptions = Object.freeze(connectOptions);
    return _this;
  }

  _createClass(Monitor, [{
    key: "connection",
    get: function get() {
      return this[kConnection];
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      } // start


      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS: heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,
        immediate: true
      });
    }
  }, {
    key: "requestCheck",
    value: function requestCheck() {
      var _this$kMonitorId;

      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }

      (_this$kMonitorId = this[kMonitorId]) === null || _this$kMonitorId === void 0 ? void 0 : _this$kMonitorId.wake();
    }
  }, {
    key: "reset",
    value: function reset() {
      var topologyVersion = this[kServer].description.topologyVersion;

      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this); // restart monitor

      stateTransition(this, STATE_IDLE); // restart monitoring

      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS: heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: minHeartbeatFrequencyMS
      });
    }
  }, {
    key: "close",
    value: function close() {
      if (isInCloseState(this)) {
        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this); // close monitor

      this.emit('close');
      stateTransition(this, common_1.STATE_CLOSED);
    }
  }]);

  return Monitor;
}(mongo_types_1.TypedEventEmitter);

exports.Monitor = Monitor;

function resetMonitorState(monitor) {
  var _monitor$kMonitorId, _monitor$kRTTPinger, _monitor$kConnection;

  (_monitor$kMonitorId = monitor[kMonitorId]) === null || _monitor$kMonitorId === void 0 ? void 0 : _monitor$kMonitorId.stop();
  monitor[kMonitorId] = undefined;
  (_monitor$kRTTPinger = monitor[kRTTPinger]) === null || _monitor$kRTTPinger === void 0 ? void 0 : _monitor$kRTTPinger.close();
  monitor[kRTTPinger] = undefined;
  monitor[kCancellationToken].emit('cancel');
  (_monitor$kConnection = monitor[kConnection]) === null || _monitor$kConnection === void 0 ? void 0 : _monitor$kConnection.destroy({
    force: true
  });
  monitor[kConnection] = undefined;
}

function checkServer(monitor, callback) {
  var start = (0, utils_1.now)();
  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));

  function failureHandler(err) {
    var _monitor$kConnection2;

    (_monitor$kConnection2 = monitor[kConnection]) === null || _monitor$kConnection2 === void 0 ? void 0 : _monitor$kConnection2.destroy({
      force: true
    });
    monitor[kConnection] = undefined;
    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));
    var error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(err) : err;
    error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);

    if (error instanceof error_1.MongoNetworkTimeoutError) {
      error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
    }

    monitor.emit('resetServer', error);
    callback(err);
  }

  var connection = monitor[kConnection];

  if (connection && !connection.closed) {
    var serverApi = connection.serverApi,
        helloOk = connection.helloOk;
    var connectTimeoutMS = monitor.options.connectTimeoutMS;
    var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
    var topologyVersion = monitor[kServer].description.topologyVersion;
    var isAwaitable = topologyVersion != null;

    var cmd = _objectSpread(_defineProperty({}, serverApi !== null && serverApi !== void 0 && serverApi.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, 1), isAwaitable && topologyVersion ? {
      maxAwaitTimeMS: maxAwaitTimeMS,
      topologyVersion: makeTopologyVersion(topologyVersion)
    } : {});

    var options = isAwaitable ? {
      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
      exhaustAllowed: true
    } : {
      socketTimeoutMS: connectTimeoutMS
    };

    if (isAwaitable && monitor[kRTTPinger] == null) {
      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({
        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS
      }, monitor.connectOptions));
    }

    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, function (err, hello) {
      if (err) {
        return failureHandler(err);
      }

      if (!('isWritablePrimary' in hello)) {
        // Provide hello-style response document.
        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
      }

      var rttPinger = monitor[kRTTPinger];
      var duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello)); // if we are using the streaming protocol then we immediately issue another `started`
      // event, otherwise the "check" is complete and return to the main monitor loop

      if (isAwaitable && hello.topologyVersion) {
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
        start = (0, utils_1.now)();
      } else {
        var _monitor$kRTTPinger2;

        (_monitor$kRTTPinger2 = monitor[kRTTPinger]) === null || _monitor$kRTTPinger2 === void 0 ? void 0 : _monitor$kRTTPinger2.close();
        monitor[kRTTPinger] = undefined;
        callback(undefined, hello);
      }
    });
    return;
  } // connecting does an implicit `hello`


  (0, connect_1.connect)(monitor.connectOptions, function (err, conn) {
    if (err) {
      monitor[kConnection] = undefined;
      failureHandler(err);
      return;
    }

    if (conn) {
      // Tell the connection that we are using the streaming protocol so that the
      // connection's message stream will only read the last hello on the buffer.
      conn.isMonitoringConnection = true;

      if (isInCloseState(monitor)) {
        conn.destroy({
          force: true
        });
        return;
      }

      monitor[kConnection] = conn;
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));
      callback(undefined, conn.hello);
    }
  });
}

function monitorServer(monitor) {
  return function (callback) {
    if (monitor.s.state === STATE_MONITORING) {
      process.nextTick(callback);
      return;
    }

    stateTransition(monitor, STATE_MONITORING);

    function done() {
      if (!isInCloseState(monitor)) {
        stateTransition(monitor, STATE_IDLE);
      }

      callback();
    }

    checkServer(monitor, function (err, hello) {
      if (err) {
        // otherwise an error occurred on initial discovery, also bail
        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
          return done();
        }
      } // if the check indicates streaming is supported, immediately reschedule monitoring


      if (hello && hello.topologyVersion) {
        (0, timers_1.setTimeout)(function () {
          if (!isInCloseState(monitor)) {
            var _monitor$kMonitorId2;

            (_monitor$kMonitorId2 = monitor[kMonitorId]) === null || _monitor$kMonitorId2 === void 0 ? void 0 : _monitor$kMonitorId2.wake();
          }
        }, 0);
      }

      done();
    });
  };
}

function makeTopologyVersion(tv) {
  return {
    processId: tv.processId,
    // tests mock counter as just number, but in a real situation counter should always be a Long
    // TODO(NODE-2674): Preserve int64 sent from MongoDB
    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
  };
}
/** @internal */


var RTTPinger = /*#__PURE__*/function () {
  function RTTPinger(cancellationToken, options) {
    var _this2 = this;

    _classCallCheck(this, RTTPinger);

    this[kConnection] = undefined;
    this[kCancellationToken] = cancellationToken;
    this[kRoundTripTime] = 0;
    this.closed = false;
    var heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    this[kMonitorId] = (0, timers_1.setTimeout)(function () {
      return measureRoundTripTime(_this2, options);
    }, heartbeatFrequencyMS);
  }

  _createClass(RTTPinger, [{
    key: "roundTripTime",
    get: function get() {
      return this[kRoundTripTime];
    }
  }, {
    key: "close",
    value: function close() {
      var _this$kConnection;

      this.closed = true;
      (0, timers_1.clearTimeout)(this[kMonitorId]);
      (_this$kConnection = this[kConnection]) === null || _this$kConnection === void 0 ? void 0 : _this$kConnection.destroy({
        force: true
      });
      this[kConnection] = undefined;
    }
  }]);

  return RTTPinger;
}();

exports.RTTPinger = RTTPinger;

function measureRoundTripTime(rttPinger, options) {
  var start = (0, utils_1.now)();
  options.cancellationToken = rttPinger[kCancellationToken];
  var heartbeatFrequencyMS = options.heartbeatFrequencyMS;

  if (rttPinger.closed) {
    return;
  }

  function measureAndReschedule(conn) {
    if (rttPinger.closed) {
      conn === null || conn === void 0 ? void 0 : conn.destroy({
        force: true
      });
      return;
    }

    if (rttPinger[kConnection] == null) {
      rttPinger[kConnection] = conn;
    }

    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);
    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(function () {
      return measureRoundTripTime(rttPinger, options);
    }, heartbeatFrequencyMS);
  }

  var connection = rttPinger[kConnection];

  if (connection == null) {
    (0, connect_1.connect)(options, function (err, conn) {
      if (err) {
        rttPinger[kConnection] = undefined;
        rttPinger[kRoundTripTime] = 0;
        return;
      }

      measureAndReschedule(conn);
    });
    return;
  }

  connection.command((0, utils_1.ns)('admin.$cmd'), _defineProperty({}, constants_1.LEGACY_HELLO_COMMAND, 1), undefined, function (err) {
    if (err) {
      rttPinger[kConnection] = undefined;
      rttPinger[kRoundTripTime] = 0;
      return;
    }

    measureAndReschedule();
  });
}
/**
 * @internal
 */


var MonitorInterval = /*#__PURE__*/function () {
  function MonitorInterval(fn) {
    var _this3 = this,
        _options$heartbeatFre2,
        _options$minHeartbeat2;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MonitorInterval);

    this.isExpeditedCallToFnScheduled = false;
    this.stopped = false;
    this.isExecutionInProgress = false;
    this.hasExecutedOnce = false;

    this._executeAndReschedule = function () {
      if (_this3.stopped) return;

      if (_this3.timerId) {
        (0, timers_1.clearTimeout)(_this3.timerId);
      }

      _this3.isExpeditedCallToFnScheduled = false;
      _this3.isExecutionInProgress = true;

      _this3.fn(function () {
        _this3.lastExecutionEnded = (0, utils_1.now)();
        _this3.isExecutionInProgress = false;

        _this3._reschedule(_this3.heartbeatFrequencyMS);
      });
    };

    this.fn = fn;
    this.lastExecutionEnded = -Infinity;
    this.heartbeatFrequencyMS = (_options$heartbeatFre2 = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre2 !== void 0 ? _options$heartbeatFre2 : 1000;
    this.minHeartbeatFrequencyMS = (_options$minHeartbeat2 = options.minHeartbeatFrequencyMS) !== null && _options$minHeartbeat2 !== void 0 ? _options$minHeartbeat2 : 500;

    if (options.immediate) {
      this._executeAndReschedule();
    } else {
      this._reschedule(undefined);
    }
  }

  _createClass(MonitorInterval, [{
    key: "wake",
    value: function wake() {
      var currentTime = (0, utils_1.now)();
      var timeSinceLastCall = currentTime - this.lastExecutionEnded; // TODO(NODE-4674): Add error handling and logging to the monitor

      if (timeSinceLastCall < 0) {
        return this._executeAndReschedule();
      }

      if (this.isExecutionInProgress) {
        return;
      } // debounce multiple calls to wake within the `minInterval`


      if (this.isExpeditedCallToFnScheduled) {
        return;
      } // reschedule a call as soon as possible, ensuring the call never happens
      // faster than the `minInterval`


      if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
        this.isExpeditedCallToFnScheduled = true;

        this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);

        return;
      }

      this._executeAndReschedule();
    }
  }, {
    key: "stop",
    value: function stop() {
      this.stopped = true;

      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
        this.timerId = undefined;
      }

      this.lastExecutionEnded = -Infinity;
      this.isExpeditedCallToFnScheduled = false;
    }
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var currentTime = (0, utils_1.now)();
      var timeSinceLastCall = currentTime - this.lastExecutionEnded;
      return {
        timerId: this.timerId != null ? 'set' : 'cleared',
        lastCallTime: this.lastExecutionEnded,
        isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
        stopped: this.stopped,
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
        currentTime: currentTime,
        timeSinceLastCall: timeSinceLastCall
      };
    }
  }, {
    key: "_reschedule",
    value: function _reschedule(ms) {
      if (this.stopped) return;

      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
      }

      this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    }
  }]);

  return MonitorInterval;
}();

exports.MonitorInterval = MonitorInterval;

/***/ }),

/***/ 5030:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Server = void 0;

var util_1 = __webpack_require__(3837);

var connection_1 = __webpack_require__(9532);

var connection_pool_1 = __webpack_require__(2809);

var errors_1 = __webpack_require__(2676);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var transactions_1 = __webpack_require__(3879);

var utils_1 = __webpack_require__(672);

var common_1 = __webpack_require__(2801);

var monitor_1 = __webpack_require__(8849);

var server_description_1 = __webpack_require__(3509);

var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));
/** @internal */

var kMonitor = Symbol('monitor');
/** @internal */

var Server = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Server, _mongo_types_1$TypedE);

  var _super = _createSuper(Server);

  /**
   * Create a server
   */
  function Server(topology, description, options) {
    var _this;

    _classCallCheck(this, Server);

    _this = _super.call(this);
    _this.commandAsync = (0, util_1.promisify)(function (ns, cmd, options, callback) {
      return _this.command(ns, cmd, options, callback);
    });
    _this.serverApi = options.serverApi;

    var poolOptions = _objectSpread({
      hostAddress: description.hostAddress
    }, options);

    _this.topology = topology;
    _this.pool = new connection_pool_1.ConnectionPool(_assertThisInitialized(_this), poolOptions);
    _this.s = {
      description: description,
      options: options,
      state: common_1.STATE_CLOSED,
      operationCount: 0
    };

    var _loop = function _loop() {
      var event = _arr[_i];

      _this.pool.on(event, function (e) {
        return _this.emit(event, e);
      });
    };

    for (var _i = 0, _arr = [].concat(_toConsumableArray(constants_1.CMAP_EVENTS), _toConsumableArray(constants_1.APM_EVENTS)); _i < _arr.length; _i++) {
      _loop();
    }

    _this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, function (clusterTime) {
      _this.clusterTime = clusterTime;
    });

    if (_this.loadBalanced) {
      _this[kMonitor] = null; // monitoring is disabled in load balancing mode

      return _possibleConstructorReturn(_this);
    } // create the monitor
    // TODO(NODE-4144): Remove new variable for type narrowing


    var monitor = new monitor_1.Monitor(_assertThisInitialized(_this), _this.s.options);
    _this[kMonitor] = monitor;

    var _iterator = _createForOfIteratorHelper(constants_1.HEARTBEAT_EVENTS),
        _step;

    try {
      var _loop2 = function _loop2() {
        var event = _step.value;
        monitor.on(event, function (e) {
          return _this.emit(event, e);
        });
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    monitor.on('resetServer', function (error) {
      return markServerUnknown(_assertThisInitialized(_this), error);
    });
    monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, function (event) {
      _this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(_this.description.hostAddress, event.reply, {
        roundTripTime: calculateRoundTripTime(_this.description.roundTripTime, event.duration)
      }));

      if (_this.s.state === common_1.STATE_CONNECTING) {
        stateTransition(_assertThisInitialized(_this), common_1.STATE_CONNECTED);

        _this.emit(Server.CONNECT, _assertThisInitialized(_this));
      }
    });
    return _this;
  }

  _createClass(Server, [{
    key: "clusterTime",
    get: function get() {
      return this.topology.clusterTime;
    },
    set: function set(clusterTime) {
      this.topology.clusterTime = clusterTime;
    }
  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }, {
    key: "name",
    get: function get() {
      return this.s.description.address;
    }
  }, {
    key: "autoEncrypter",
    get: function get() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }

      return;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    /**
     * Initiate server connect
     */

  }, {
    key: "connect",
    value: function connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }

      stateTransition(this, common_1.STATE_CONNECTING); // If in load balancer mode we automatically set the server to
      // a load balancer. It never transitions out of this state and
      // has no monitor.

      if (!this.loadBalanced) {
        var _this$kMonitor;

        (_this$kMonitor = this[kMonitor]) === null || _this$kMonitor === void 0 ? void 0 : _this$kMonitor.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    /** Destroy the server connection */

  }, {
    key: "destroy",
    value: function destroy(options, callback) {
      var _this2 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {
          force: false
        };
      }

      options = Object.assign({}, {
        force: false
      }, options);

      if (this.s.state === common_1.STATE_CLOSED) {
        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);

      if (!this.loadBalanced) {
        var _this$kMonitor2;

        (_this$kMonitor2 = this[kMonitor]) === null || _this$kMonitor2 === void 0 ? void 0 : _this$kMonitor2.close();
      }

      this.pool.close(options, function (err) {
        stateTransition(_this2, common_1.STATE_CLOSED);

        _this2.emit('closed');

        if (typeof callback === 'function') {
          callback(err);
        }
      });
    }
    /**
     * Immediately schedule monitoring of this server. If there already an attempt being made
     * this will be a no-op.
     */

  }, {
    key: "requestCheck",
    value: function requestCheck() {
      if (!this.loadBalanced) {
        var _this$kMonitor3;

        (_this$kMonitor3 = this[kMonitor]) === null || _this$kMonitor3 === void 0 ? void 0 : _this$kMonitor3.requestCheck();
      }
    }
    /**
     * Execute a command
     * @internal
     */

  }, {
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var _this3 = this;

      if (callback == null) {
        throw new error_1.MongoInvalidArgumentError('Callback must be provided');
      }

      if (ns.db == null || typeof ns === 'string') {
        throw new error_1.MongoInvalidArgumentError('Namespace must not be a string');
      }

      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        callback(new error_1.MongoServerClosedError());
        return;
      } // Clone the options


      var finalOptions = Object.assign({}, options, {
        wireProtocolCommand: false
      }); // There are cases where we need to flag the read preference not to get sent in
      // the command, such as pre-5.0 servers attempting to perform an aggregate write
      // with a non-primary read preference. In this case the effective read preference
      // (primary) is not the same as the provided and must be removed completely.

      if (finalOptions.omitReadPreference) {
        delete finalOptions.readPreference;
      }

      var session = finalOptions.session;
      var conn = session === null || session === void 0 ? void 0 : session.pinnedConnection; // NOTE: This is a hack! We can't retrieve the connections used for executing an operation
      //       (and prevent them from being checked back in) at the point of operation execution.
      //       This should be considered as part of the work for NODE-2882
      // NOTE:
      //       When incrementing operation count, it's important that we increment it before we
      //       attempt to check out a connection from the pool.  This ensures that operations that
      //       are waiting for a connection are included in the operation count.  Load balanced
      //       mode will only ever have a single server, so the operation count doesn't matter.
      //       Incrementing the operation count above the logic to handle load balanced mode would
      //       require special logic to decrement it again, or would double increment (the load
      //       balanced code makes a recursive call).  Instead, we increment the count after this
      //       check.

      if (this.loadBalanced && session && conn == null && isPinnableCommand(cmd, session)) {
        this.pool.checkOut(function (err, checkedOut) {
          if (err || checkedOut == null) {
            if (callback) return callback(err);
            return;
          }

          session.pin(checkedOut);

          _this3.command(ns, cmd, finalOptions, callback);
        });
        return;
      }

      this.incrementOperationCount();
      this.pool.withConnection(conn, function (err, conn, cb) {
        if (err || !conn) {
          _this3.decrementOperationCount();

          if (!err) {
            return cb(new error_1.MongoRuntimeError('Failed to create connection without error'));
          }

          if (!(err instanceof errors_1.PoolClearedError)) {
            _this3.handleError(err);
          }

          return cb(err);
        }

        conn.command(ns, cmd, finalOptions, makeOperationHandler(_this3, conn, cmd, finalOptions, function (error, response) {
          _this3.decrementOperationCount();

          cb(error, response);
        }));
      }, callback);
    }
    /**
     * Handle SDAM error
     * @internal
     */

  }, {
    key: "handleError",
    value: function handleError(error, connection) {
      var _this4 = this;

      if (!(error instanceof error_1.MongoError)) {
        return;
      }

      var isStaleError = error.connectionGeneration && error.connectionGeneration < this.pool.generation;

      if (isStaleError) {
        return;
      }

      var isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
      var isNetworkTimeoutBeforeHandshakeError = (0, error_1.isNetworkErrorBeforeHandshake)(error);
      var isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);

      if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
        // In load balanced mode we never mark the server as unknown and always
        // clear for the specific service id.
        if (!this.loadBalanced) {
          error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
          markServerUnknown(this, error);
        } else if (connection) {
          this.pool.clear({
            serviceId: connection.serviceId
          });
        }
      } else {
        if ((0, error_1.isSDAMUnrecoverableError)(error)) {
          if (shouldHandleStateChangeError(this, error)) {
            var shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);

            if (this.loadBalanced && connection && shouldClearPool) {
              this.pool.clear({
                serviceId: connection.serviceId
              });
            }

            if (!this.loadBalanced) {
              if (shouldClearPool) {
                error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
              }

              markServerUnknown(this, error);
              process.nextTick(function () {
                return _this4.requestCheck();
              });
            }
          }
        }
      }
    }
    /**
     * Decrement the operation count, returning the new count.
     */

  }, {
    key: "decrementOperationCount",
    value: function decrementOperationCount() {
      return this.s.operationCount -= 1;
    }
    /**
     * Increment the operation count, returning the new count.
     */

  }, {
    key: "incrementOperationCount",
    value: function incrementOperationCount() {
      return this.s.operationCount += 1;
    }
  }]);

  return Server;
}(mongo_types_1.TypedEventEmitter);
/** @event */


Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
/** @event */

Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
/** @event */

Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
/** @event */

Server.CONNECT = constants_1.CONNECT;
/** @event */

Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
/** @event */

Server.CLOSED = constants_1.CLOSED;
/** @event */

Server.ENDED = constants_1.ENDED;
exports.Server = Server;

function calculateRoundTripTime(oldRtt, duration) {
  if (oldRtt === -1) {
    return duration;
  }

  var alpha = 0.2;
  return alpha * duration + (1 - alpha) * oldRtt;
}

function markServerUnknown(server, error) {
  // Load balancer servers can never be marked unknown.
  if (server.loadBalanced) {
    return;
  }

  if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
    var _server$kMonitor;

    (_server$kMonitor = server[kMonitor]) === null || _server$kMonitor === void 0 ? void 0 : _server$kMonitor.reset();
  }

  server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, {
    error: error
  }));
}

function isPinnableCommand(cmd, session) {
  if (session) {
    return session.inTransaction() || 'aggregate' in cmd || 'find' in cmd || 'getMore' in cmd || 'listCollections' in cmd || 'listIndexes' in cmd;
  }

  return false;
}

function connectionIsStale(pool, connection) {
  if (connection.serviceId) {
    return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
  }

  return connection.generation !== pool.generation;
}

function shouldHandleStateChangeError(server, err) {
  var etv = err.topologyVersion;
  var stv = server.description.topologyVersion;
  return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
}

function inActiveTransaction(session, cmd) {
  return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
}
/** this checks the retryWrites option passed down from the client options, it
 * does not check if the server supports retryable writes */


function isRetryableWritesEnabled(topology) {
  return topology.s.options.retryWrites !== false;
}

function makeOperationHandler(server, connection, cmd, options, callback) {
  var session = options === null || options === void 0 ? void 0 : options.session;
  return function handleOperationResult(error, result) {
    // We should not swallow an error if it is present.
    if (error == null && result != null) {
      return callback(undefined, result);
    }

    if (options != null && 'noResponse' in options && options.noResponse === true) {
      return callback(undefined, null);
    }

    if (!error) {
      return callback(new error_1.MongoUnexpectedServerResponseError('Empty response with no error'));
    }

    if (!(error instanceof error_1.MongoError)) {
      // Node.js or some other error we have not special handling for
      return callback(error);
    }

    if (connectionIsStale(server.pool, connection)) {
      return callback(error);
    }

    if (error instanceof error_1.MongoNetworkError) {
      if (session && !session.hasEnded && session.serverSession) {
        session.serverSession.isDirty = true;
      } // inActiveTransaction check handles commit and abort.


      if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
      }

      if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(server) && !inActiveTransaction(session, cmd)) {
        error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
      }
    } else {
      if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(server)) && !inActiveTransaction(session, cmd)) {
        error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
      }
    }

    if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      session.unpin({
        force: true
      });
    }

    server.handleError(error, connection);
    return callback(error);
  };
}

/***/ }),

/***/ 3509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;

var bson_1 = __webpack_require__(4356);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var common_1 = __webpack_require__(2801);

var WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);
var DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);
/**
 * The client's view of a single server, based on the most recent hello outcome.
 *
 * Internal type, not meant to be directly instantiated
 * @public
 */

var ServerDescription = /*#__PURE__*/function () {
  /**
   * Create a ServerDescription
   * @internal
   *
   * @param address - The address of the server
   * @param hello - An optional hello response for this server
   */
  function ServerDescription(address, hello) {
    var _hello$hosts$map, _hello$hosts, _hello$passives$map, _hello$passives, _hello$arbiters$map, _hello$arbiters, _hello$tags, _hello$minWireVersion, _hello$maxWireVersion, _options$roundTripTim, _hello$lastWrite$last, _hello$lastWrite, _options$error, _ref, _this$error$topologyV, _this$error, _hello$setName, _hello$setVersion, _hello$electionId, _hello$logicalSession, _hello$primary, _hello$me$toLowerCase, _hello$me, _hello$$clusterTime;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ServerDescription);

    if (address == null || address === '') {
      throw new error_1.MongoRuntimeError('ServerDescription must be provided with a non-empty address');
    }

    this.address = typeof address === 'string' ? utils_1.HostAddress.fromString(address).toString() // Use HostAddress to normalize
    : address.toString();
    this.type = parseServerType(hello, options);
    this.hosts = (_hello$hosts$map = hello === null || hello === void 0 || (_hello$hosts = hello.hosts) === null || _hello$hosts === void 0 ? void 0 : _hello$hosts.map(function (host) {
      return host.toLowerCase();
    })) !== null && _hello$hosts$map !== void 0 ? _hello$hosts$map : [];
    this.passives = (_hello$passives$map = hello === null || hello === void 0 || (_hello$passives = hello.passives) === null || _hello$passives === void 0 ? void 0 : _hello$passives.map(function (host) {
      return host.toLowerCase();
    })) !== null && _hello$passives$map !== void 0 ? _hello$passives$map : [];
    this.arbiters = (_hello$arbiters$map = hello === null || hello === void 0 || (_hello$arbiters = hello.arbiters) === null || _hello$arbiters === void 0 ? void 0 : _hello$arbiters.map(function (host) {
      return host.toLowerCase();
    })) !== null && _hello$arbiters$map !== void 0 ? _hello$arbiters$map : [];
    this.tags = (_hello$tags = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _hello$tags !== void 0 ? _hello$tags : {};
    this.minWireVersion = (_hello$minWireVersion = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _hello$minWireVersion !== void 0 ? _hello$minWireVersion : 0;
    this.maxWireVersion = (_hello$maxWireVersion = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _hello$maxWireVersion !== void 0 ? _hello$maxWireVersion : 0;
    this.roundTripTime = (_options$roundTripTim = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _options$roundTripTim !== void 0 ? _options$roundTripTim : -1;
    this.lastUpdateTime = (0, utils_1.now)();
    this.lastWriteDate = (_hello$lastWrite$last = hello === null || hello === void 0 || (_hello$lastWrite = hello.lastWrite) === null || _hello$lastWrite === void 0 ? void 0 : _hello$lastWrite.lastWriteDate) !== null && _hello$lastWrite$last !== void 0 ? _hello$lastWrite$last : 0;
    this.error = (_options$error = options.error) !== null && _options$error !== void 0 ? _options$error : null; // TODO(NODE-2674): Preserve int64 sent from MongoDB

    this.topologyVersion = (_ref = (_this$error$topologyV = (_this$error = this.error) === null || _this$error === void 0 ? void 0 : _this$error.topologyVersion) !== null && _this$error$topologyV !== void 0 ? _this$error$topologyV : hello === null || hello === void 0 ? void 0 : hello.topologyVersion) !== null && _ref !== void 0 ? _ref : null;
    this.setName = (_hello$setName = hello === null || hello === void 0 ? void 0 : hello.setName) !== null && _hello$setName !== void 0 ? _hello$setName : null;
    this.setVersion = (_hello$setVersion = hello === null || hello === void 0 ? void 0 : hello.setVersion) !== null && _hello$setVersion !== void 0 ? _hello$setVersion : null;
    this.electionId = (_hello$electionId = hello === null || hello === void 0 ? void 0 : hello.electionId) !== null && _hello$electionId !== void 0 ? _hello$electionId : null;
    this.logicalSessionTimeoutMinutes = (_hello$logicalSession = hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) !== null && _hello$logicalSession !== void 0 ? _hello$logicalSession : null;
    this.primary = (_hello$primary = hello === null || hello === void 0 ? void 0 : hello.primary) !== null && _hello$primary !== void 0 ? _hello$primary : null;
    this.me = (_hello$me$toLowerCase = hello === null || hello === void 0 || (_hello$me = hello.me) === null || _hello$me === void 0 ? void 0 : _hello$me.toLowerCase()) !== null && _hello$me$toLowerCase !== void 0 ? _hello$me$toLowerCase : null;
    this.$clusterTime = (_hello$$clusterTime = hello === null || hello === void 0 ? void 0 : hello.$clusterTime) !== null && _hello$$clusterTime !== void 0 ? _hello$$clusterTime : null;
  }

  _createClass(ServerDescription, [{
    key: "hostAddress",
    get: function get() {
      return utils_1.HostAddress.fromString(this.address);
    }
  }, {
    key: "allHosts",
    get: function get() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    /** Is this server available for reads*/

  }, {
    key: "isReadable",
    get: function get() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    /** Is this server data bearing */

  }, {
    key: "isDataBearing",
    get: function get() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    /** Is this server available for writes */

  }, {
    key: "isWritable",
    get: function get() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
  }, {
    key: "host",
    get: function get() {
      var chopLength = ":".concat(this.port).length;
      return this.address.slice(0, -chopLength);
    }
  }, {
    key: "port",
    get: function get() {
      var port = this.address.split(':').pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    /**
     * Determines if another `ServerDescription` is equal to this one per the rules defined
     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}
     */

  }, {
    key: "equals",
    value: function equals(other) {
      // Despite using the comparator that would determine a nullish topologyVersion as greater than
      // for equality we should only always perform direct equality comparison
      var topologyVersionsEqual = this.topologyVersion === (other === null || other === void 0 ? void 0 : other.topologyVersion) || compareTopologyVersion(this.topologyVersion, other === null || other === void 0 ? void 0 : other.topologyVersion) === 0;
      var electionIdsEqual = this.electionId != null && (other === null || other === void 0 ? void 0 : other.electionId) != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === (other === null || other === void 0 ? void 0 : other.electionId);
      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }]);

  return ServerDescription;
}();

exports.ServerDescription = ServerDescription; // Parses a `hello` message and determines the server type

function parseServerType(hello, options) {
  if (options !== null && options !== void 0 && options.loadBalanced) {
    return common_1.ServerType.LoadBalancer;
  }

  if (!hello || !hello.ok) {
    return common_1.ServerType.Unknown;
  }

  if (hello.isreplicaset) {
    return common_1.ServerType.RSGhost;
  }

  if (hello.msg && hello.msg === 'isdbgrid') {
    return common_1.ServerType.Mongos;
  }

  if (hello.setName) {
    if (hello.hidden) {
      return common_1.ServerType.RSOther;
    } else if (hello.isWritablePrimary) {
      return common_1.ServerType.RSPrimary;
    } else if (hello.secondary) {
      return common_1.ServerType.RSSecondary;
    } else if (hello.arbiterOnly) {
      return common_1.ServerType.RSArbiter;
    } else {
      return common_1.ServerType.RSOther;
    }
  }

  return common_1.ServerType.Standalone;
}

exports.parseServerType = parseServerType;

function tagsStrictEqual(tags, tags2) {
  var tagsKeys = Object.keys(tags);
  var tags2Keys = Object.keys(tags2);
  return tagsKeys.length === tags2Keys.length && tagsKeys.every(function (key) {
    return tags2[key] === tags[key];
  });
}
/**
 * Compares two topology versions.
 *
 * 1. If the response topologyVersion is unset or the ServerDescription's
 *    topologyVersion is null, the client MUST assume the response is more recent.
 * 1. If the response's topologyVersion.processId is not equal to the
 *    ServerDescription's, the client MUST assume the response is more recent.
 * 1. If the response's topologyVersion.processId is equal to the
 *    ServerDescription's, the client MUST use the counter field to determine
 *    which topologyVersion is more recent.
 *
 * ```ts
 * currentTv <   newTv === -1
 * currentTv === newTv === 0
 * currentTv >   newTv === 1
 * ```
 */


function compareTopologyVersion(currentTv, newTv) {
  if (currentTv == null || newTv == null) {
    return -1;
  }

  if (!currentTv.processId.equals(newTv.processId)) {
    return -1;
  } // TODO(NODE-2674): Preserve int64 sent from MongoDB


  var currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
  var newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
  return currentCounter.compare(newCounter);
}

exports.compareTopologyVersion = compareTopologyVersion;

/***/ }),

/***/ 4265:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;

var error_1 = __webpack_require__(9525);

var read_preference_1 = __webpack_require__(4064);

var common_1 = __webpack_require__(2801); // max staleness constants


var IDLE_WRITE_PERIOD = 10000;
var SMALLEST_MAX_STALENESS_SECONDS = 90; //  Minimum version to try writes on secondaries.

exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
/**
 * Returns a server selector that selects for writable servers
 */

function writableServerSelector() {
  return function (topologyDescription, servers) {
    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {
      return s.isWritable;
    }));
  };
}

exports.writableServerSelector = writableServerSelector;
/**
 * The purpose of this selector is to select the same server, only
 * if it is in a state that it can have commands sent to it.
 */

function sameServerSelector(description) {
  return function (topologyDescription, servers) {
    if (!description) return []; // Filter the servers to match the provided description only if
    // the type is not unknown.

    return servers.filter(function (sd) {
      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
    });
  };
}

exports.sameServerSelector = sameServerSelector;
/**
 * Returns a server selector that uses a read preference to select a
 * server potentially for a write on a secondary.
 */

function secondaryWritableServerSelector(wireVersion, readPreference) {
  // If server version < 5.0, read preference always primary.
  // If server version >= 5.0...
  // - If read preference is supplied, use that.
  // - If no read preference is supplied, use primary.
  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
  }

  return readPreferenceServerSelector(readPreference);
}

exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
/**
 * Reduces the passed in array of servers by the rules of the "Max Staleness" specification
 * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst
 *
 * @param readPreference - The read preference providing max staleness guidance
 * @param topologyDescription - The topology description
 * @param servers - The list of server descriptions to be reduced
 * @returns The list of servers that satisfy the requirements of max staleness
 */

function maxStalenessReducer(readPreference, topologyDescription, servers) {
  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
    return servers;
  }

  var maxStaleness = readPreference.maxStalenessSeconds;
  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;

  if (maxStaleness < maxStalenessVariance) {
    throw new error_1.MongoInvalidArgumentError("Option \"maxStalenessSeconds\" must be at least ".concat(maxStalenessVariance, " seconds"));
  }

  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
    throw new error_1.MongoInvalidArgumentError("Option \"maxStalenessSeconds\" must be at least ".concat(SMALLEST_MAX_STALENESS_SECONDS, " seconds"));
  }

  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
    return servers.reduce(function (result, server) {
      var _readPreference$maxSt;

      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      var maxStalenessSeconds = (_readPreference$maxSt = readPreference.maxStalenessSeconds) !== null && _readPreference$maxSt !== void 0 ? _readPreference$maxSt : 0;

      if (staleness <= maxStalenessSeconds) {
        result.push(server);
      }

      return result;
    }, []);
  }

  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
    if (servers.length === 0) {
      return servers;
    }

    var sMax = servers.reduce(function (max, s) {
      return s.lastWriteDate > max.lastWriteDate ? s : max;
    });
    return servers.reduce(function (result, server) {
      var _readPreference$maxSt2;

      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      var maxStalenessSeconds = (_readPreference$maxSt2 = readPreference.maxStalenessSeconds) !== null && _readPreference$maxSt2 !== void 0 ? _readPreference$maxSt2 : 0;

      if (staleness <= maxStalenessSeconds) {
        result.push(server);
      }

      return result;
    }, []);
  }

  return servers;
}
/**
 * Determines whether a server's tags match a given set of tags
 *
 * @param tagSet - The requested tag set to match
 * @param serverTags - The server's tags
 */


function tagSetMatch(tagSet, serverTags) {
  var keys = Object.keys(tagSet);
  var serverTagKeys = Object.keys(serverTags);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];

    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
      return false;
    }
  }

  return true;
}
/**
 * Reduces a set of server descriptions based on tags requested by the read preference
 *
 * @param readPreference - The read preference providing the requested tags
 * @param servers - The list of server descriptions to reduce
 * @returns The list of servers matching the requested tags
 */


function tagSetReducer(readPreference, servers) {
  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
    return servers;
  }

  var _loop = function _loop() {
    var tagSet = readPreference.tags[i];
    var serversMatchingTagset = servers.reduce(function (matched, server) {
      if (tagSetMatch(tagSet, server.tags)) matched.push(server);
      return matched;
    }, []);

    if (serversMatchingTagset.length) {
      return {
        v: serversMatchingTagset
      };
    }
  },
      _ret;

  for (var i = 0; i < readPreference.tags.length; ++i) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }

  return [];
}
/**
 * Reduces a list of servers to ensure they fall within an acceptable latency window. This is
 * further specified in the "Server Selection" specification, found here:
 * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst
 *
 * @param topologyDescription - The topology description
 * @param servers - The list of servers to reduce
 * @returns The servers which fall within an acceptable latency window
 */


function latencyWindowReducer(topologyDescription, servers) {
  var low = servers.reduce(function (min, server) {
    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);
  }, -1);
  var high = low + topologyDescription.localThresholdMS;
  return servers.reduce(function (result, server) {
    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);
    return result;
  }, []);
} // filters


function primaryFilter(server) {
  return server.type === common_1.ServerType.RSPrimary;
}

function secondaryFilter(server) {
  return server.type === common_1.ServerType.RSSecondary;
}

function nearestFilter(server) {
  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
}

function knownFilter(server) {
  return server.type !== common_1.ServerType.Unknown;
}

function loadBalancerFilter(server) {
  return server.type === common_1.ServerType.LoadBalancer;
}
/**
 * Returns a function which selects servers based on a provided read preference
 *
 * @param readPreference - The read preference to select with
 */


function readPreferenceServerSelector(readPreference) {
  if (!readPreference.isValid()) {
    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');
  }

  return function (topologyDescription, servers) {
    var commonWireVersion = topologyDescription.commonWireVersion;

    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
      throw new error_1.MongoCompatibilityError("Minimum wire version '".concat(readPreference.minWireVersion, "' required, but found '").concat(commonWireVersion, "'"));
    }

    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
      return servers.filter(loadBalancerFilter);
    }

    if (topologyDescription.type === common_1.TopologyType.Unknown) {
      return [];
    }

    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {
      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
    }

    var mode = readPreference.mode;

    if (mode === read_preference_1.ReadPreference.PRIMARY) {
      return servers.filter(primaryFilter);
    }

    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
      var result = servers.filter(primaryFilter);

      if (result.length) {
        return result;
      }
    }

    var filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));

    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
      return servers.filter(primaryFilter);
    }

    return selectedServers;
  };
}

exports.readPreferenceServerSelector = readPreferenceServerSelector;

/***/ }),

/***/ 1817:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SrvPoller = exports.SrvPollingEvent = void 0;

var dns = __webpack_require__(9523);

var timers_1 = __webpack_require__(9512);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var utils_1 = __webpack_require__(672);
/**
 * @internal
 * @category Event
 */


var SrvPollingEvent = /*#__PURE__*/function () {
  function SrvPollingEvent(srvRecords) {
    _classCallCheck(this, SrvPollingEvent);

    this.srvRecords = srvRecords;
  }

  _createClass(SrvPollingEvent, [{
    key: "hostnames",
    value: function hostnames() {
      return new Set(this.srvRecords.map(function (r) {
        return utils_1.HostAddress.fromSrvRecord(r).toString();
      }));
    }
  }]);

  return SrvPollingEvent;
}();

exports.SrvPollingEvent = SrvPollingEvent;
/** @internal */

var SrvPoller = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(SrvPoller, _mongo_types_1$TypedE);

  var _super = _createSuper(SrvPoller);

  function SrvPoller(options) {
    var _options$srvMaxHosts, _options$srvServiceNa, _options$heartbeatFre;

    var _this;

    _classCallCheck(this, SrvPoller);

    _this = _super.call(this);

    if (!options || !options.srvHost) {
      throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');
    }

    _this.srvHost = options.srvHost;
    _this.srvMaxHosts = (_options$srvMaxHosts = options.srvMaxHosts) !== null && _options$srvMaxHosts !== void 0 ? _options$srvMaxHosts : 0;
    _this.srvServiceName = (_options$srvServiceNa = options.srvServiceName) !== null && _options$srvServiceNa !== void 0 ? _options$srvServiceNa : 'mongodb';
    _this.rescanSrvIntervalMS = 60000;
    _this.heartbeatFrequencyMS = (_options$heartbeatFre = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre !== void 0 ? _options$heartbeatFre : 10000;
    _this.haMode = false;
    _this.generation = 0;
    _this._timeout = undefined;
    return _this;
  }

  _createClass(SrvPoller, [{
    key: "srvAddress",
    get: function get() {
      return "_".concat(this.srvServiceName, "._tcp.").concat(this.srvHost);
    }
  }, {
    key: "intervalMS",
    get: function get() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
  }, {
    key: "start",
    value: function start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    } // TODO(NODE-4994): implement new logging logic for SrvPoller failures

  }, {
    key: "schedule",
    value: function schedule() {
      var _this2 = this;

      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }

      this._timeout = (0, timers_1.setTimeout)(function () {
        _this2._poll()["catch"](function () {
          return null;
        });
      }, this.intervalMS);
    }
  }, {
    key: "success",
    value: function success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
  }, {
    key: "failure",
    value: function failure() {
      this.haMode = true;
      this.schedule();
    }
  }, {
    key: "_poll",
    value: function () {
      var _poll2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var generation, srvRecords, finalAddresses, _iterator, _step, record;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              generation = this.generation;
              _context.prev = 1;
              _context.next = 4;
              return dns.promises.resolveSrv(this.srvAddress);

            case 4:
              srvRecords = _context.sent;
              _context.next = 11;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              this.failure();
              return _context.abrupt("return");

            case 11:
              if (!(generation !== this.generation)) {
                _context.next = 13;
                break;
              }

              return _context.abrupt("return");

            case 13:
              finalAddresses = [];
              _iterator = _createForOfIteratorHelper(srvRecords);

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  record = _step.value;

                  if ((0, utils_1.matchesParentDomain)(record.name, this.srvHost)) {
                    finalAddresses.push(record);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

              if (finalAddresses.length) {
                _context.next = 19;
                break;
              }

              this.failure();
              return _context.abrupt("return");

            case 19:
              this.success(finalAddresses);

            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 7]]);
      }));

      function _poll() {
        return _poll2.apply(this, arguments);
      }

      return _poll;
    }()
  }]);

  return SrvPoller;
}(mongo_types_1.TypedEventEmitter);
/** @event */


SrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';
exports.SrvPoller = SrvPoller;

/***/ }),

/***/ 2776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServerCapabilities = exports.Topology = void 0;

var timers_1 = __webpack_require__(9512);

var util_1 = __webpack_require__(3837);

var connection_string_1 = __webpack_require__(1825);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var read_preference_1 = __webpack_require__(4064);

var utils_1 = __webpack_require__(672);

var common_1 = __webpack_require__(2801);

var events_1 = __webpack_require__(468);

var server_1 = __webpack_require__(5030);

var server_description_1 = __webpack_require__(3509);

var server_selection_1 = __webpack_require__(4265);

var srv_polling_1 = __webpack_require__(1817);

var topology_description_1 = __webpack_require__(8707); // Global state


var globalTopologyCounter = 0;
var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));
/** @internal */

var kCancelled = Symbol('cancelled');
/** @internal */

var kWaitQueue = Symbol('waitQueue');
/**
 * A container of server instances representing a connection to a MongoDB topology.
 * @internal
 */

var Topology = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Topology, _mongo_types_1$TypedE);

  var _super = _createSuper(Topology);

  /**
   * @param seedlist - a list of HostAddress instances to connect to
   */
  function Topology(client, seeds, options) {
    var _options, _options2;

    var _this;

    _classCallCheck(this, Topology);

    _this = _super.call(this);
    _this.client = client;
    _this.selectServerAsync = (0, util_1.promisify)(function (selector, options, callback) {
      return _this.selectServer(selector, options, callback);
    }); // Options should only be undefined in tests, MongoClient will always have defined options

    options = (_options = options) !== null && _options !== void 0 ? _options : _objectSpread(_objectSpread({
      hosts: [utils_1.HostAddress.fromString('localhost:27017')]
    }, Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())), Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries()));

    if (typeof seeds === 'string') {
      seeds = [utils_1.HostAddress.fromString(seeds)];
    } else if (!Array.isArray(seeds)) {
      seeds = [seeds];
    }

    var seedlist = [];

    var _iterator = _createForOfIteratorHelper(seeds),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var seed = _step.value;

        if (typeof seed === 'string') {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          // FIXME(NODE-3483): May need to be a MongoParseError
          throw new error_1.MongoRuntimeError("Topology cannot be constructed from ".concat(JSON.stringify(seed)));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var topologyType = topologyTypeFromOptions(options);
    var topologyId = globalTopologyCounter++;
    var selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
    var serverDescriptions = new Map();

    var _iterator2 = _createForOfIteratorHelper(selectedHosts),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var hostAddress = _step2.value;
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    _this[kWaitQueue] = new utils_1.List();
    _this.s = {
      // the id of this topology
      id: topologyId,
      // passed in options
      options: options,
      // initial seedlist of servers to connect to
      seedlist: seedlist,
      // initial state
      state: common_1.STATE_CLOSED,
      // the topology description
      description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
      heartbeatFrequencyMS: options.heartbeatFrequencyMS,
      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
      // a map of server instances to normalized addresses
      servers: new Map(),
      credentials: (_options2 = options) === null || _options2 === void 0 ? void 0 : _options2.credentials,
      clusterTime: undefined,
      // timer management
      connectionTimers: new Set(),
      detectShardedTopology: function detectShardedTopology(ev) {
        return _this.detectShardedTopology(ev);
      },
      detectSrvRecords: function detectSrvRecords(ev) {
        return _this.detectSrvRecords(ev);
      }
    };

    if (options.srvHost && !options.loadBalanced) {
      var _options$srvPoller;

      _this.s.srvPoller = (_options$srvPoller = options.srvPoller) !== null && _options$srvPoller !== void 0 ? _options$srvPoller : new srv_polling_1.SrvPoller({
        heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,
        srvHost: options.srvHost,
        srvMaxHosts: options.srvMaxHosts,
        srvServiceName: options.srvServiceName
      });

      _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);
    }

    return _this;
  }

  _createClass(Topology, [{
    key: "detectShardedTopology",
    value: function detectShardedTopology(event) {
      var _this$s$srvPoller;

      var previousType = event.previousDescription.type;
      var newType = event.newDescription.type;
      var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      var srvListeners = (_this$s$srvPoller = this.s.srvPoller) === null || _this$s$srvPoller === void 0 ? void 0 : _this$s$srvPoller.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      var listeningToSrvPolling = !!(srvListeners !== null && srvListeners !== void 0 && srvListeners.includes(this.s.detectSrvRecords));

      if (transitionToSharded && !listeningToSrvPolling) {
        var _this$s$srvPoller2, _this$s$srvPoller3;

        (_this$s$srvPoller2 = this.s.srvPoller) === null || _this$s$srvPoller2 === void 0 ? void 0 : _this$s$srvPoller2.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        (_this$s$srvPoller3 = this.s.srvPoller) === null || _this$s$srvPoller3 === void 0 ? void 0 : _this$s$srvPoller3.start();
      }
    }
  }, {
    key: "detectSrvRecords",
    value: function detectSrvRecords(ev) {
      var previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);

      if (this.s.description === previousTopologyDescription) {
        // Nothing changed, so return
        return;
      }

      updateServers(this);
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    /**
     * @returns A `TopologyDescription` for this topology
     */

  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.s.options.loadBalanced;
    }
  }, {
    key: "capabilities",
    get: function get() {
      return new ServerCapabilities(this.lastHello());
    }
  }, {
    key: "connect",
    value: function connect(options, callback) {
      var _options3,
          _this2 = this,
          _options$readPreferen;

      if (typeof options === 'function') callback = options, options = {};
      options = (_options3 = options) !== null && _options3 !== void 0 ? _options3 : {};

      if (this.s.state === common_1.STATE_CONNECTED) {
        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      stateTransition(this, common_1.STATE_CONNECTING); // emit SDAM monitoring events

      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id)); // emit an event for the topology change

      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown
      this.s.description)); // connect all known servers, then attempt server selection to connect

      var serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map(function (serverDescription) {
        return [serverDescription.address, createAndConnectServer(_this2, serverDescription)];
      })); // In load balancer mode we need to fake a server description getting
      // emitted from the monitor, since the monitor doesn't exist.

      if (this.s.options.loadBalanced) {
        var _iterator3 = _createForOfIteratorHelper(serverDescriptions),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var description = _step3.value;
            var newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
              loadBalanced: this.s.options.loadBalanced
            });
            this.serverUpdateHandler(newDescription);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      var exitWithError = function exitWithError(error) {
        return callback ? callback(error) : _this2.emit(Topology.ERROR, error);
      };

      var readPreference = (_options$readPreferen = options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : read_preference_1.ReadPreference.primary;
      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, function (err, server) {
        var _callback2;

        if (err) {
          return _this2.close({
            force: false
          }, function () {
            return exitWithError(err);
          });
        } // TODO: NODE-2471


        var skipPingOnConnect = _this2.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] === true;

        if (!skipPingOnConnect && server && _this2.s.credentials) {
          server.command((0, utils_1.ns)('admin.$cmd'), {
            ping: 1
          }, {}, function (err) {
            var _callback;

            if (err) {
              return exitWithError(err);
            }

            stateTransition(_this2, common_1.STATE_CONNECTED);

            _this2.emit(Topology.OPEN, _this2);

            _this2.emit(Topology.CONNECT, _this2);

            (_callback = callback) === null || _callback === void 0 ? void 0 : _callback(undefined, _this2);
          });
          return;
        }

        stateTransition(_this2, common_1.STATE_CONNECTED);

        _this2.emit(Topology.OPEN, _this2);

        _this2.emit(Topology.CONNECT, _this2);

        (_callback2 = callback) === null || _callback2 === void 0 ? void 0 : _callback2(undefined, _this2);
      });
    }
  }, {
    key: "close",
    value: function close(options, callback) {
      var _options4,
          _this3 = this;

      options = (_options4 = options) !== null && _options4 !== void 0 ? _options4 : {
        force: false
      };

      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return callback === null || callback === void 0 ? void 0 : callback();
      }

      var destroyedServers = Array.from(this.s.servers.values(), function (server) {
        var _options5;

        return (0, util_1.promisify)(destroyServer)(server, _this3, {
          force: !!((_options5 = options) !== null && _options5 !== void 0 && _options5.force)
        });
      });
      Promise.all(destroyedServers).then(function () {
        _this3.s.servers.clear();

        stateTransition(_this3, common_1.STATE_CLOSING);
        drainWaitQueue(_this3[kWaitQueue], new error_1.MongoTopologyClosedError());
        (0, common_1.drainTimerQueue)(_this3.s.connectionTimers);

        if (_this3.s.srvPoller) {
          _this3.s.srvPoller.stop();

          _this3.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, _this3.s.detectSrvRecords);
        }

        _this3.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this3.s.detectShardedTopology);

        stateTransition(_this3, common_1.STATE_CLOSED); // emit an event for close

        _this3.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(_this3.s.id));
      })["finally"](function () {
        return callback === null || callback === void 0 ? void 0 : callback();
      });
    }
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
     * @param options - Optional settings related to server selection
     * @param callback - The callback used to indicate success or failure
     * @returns An instance of a `Server` meeting the criteria of the predicate provided
     */

  }, {
    key: "selectServer",
    value: function selectServer(selector, options, callback) {
      var _this4 = this;

      var serverSelector;

      if (typeof selector !== 'function') {
        if (typeof selector === 'string') {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          var readPreference;

          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }

          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }

      options = Object.assign({}, {
        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS
      }, options);
      var isSharded = this.description.type === common_1.TopologyType.Sharded;
      var session = options.session;
      var transaction = session && session.transaction;

      if (isSharded && transaction && transaction.server) {
        callback(undefined, transaction.server);
        return;
      }

      var waitQueueMember = {
        serverSelector: serverSelector,
        transaction: transaction,
        callback: callback
      };
      var serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;

      if (serverSelectionTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;
          var timeoutError = new error_1.MongoServerSelectionError("Server selection timed out after ".concat(serverSelectionTimeoutMS, " ms"), _this4.description);
          waitQueueMember.callback(timeoutError);
        }, serverSelectionTimeoutMS);
      }

      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    }
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param serverDescription - The server to update in the internal list of server descriptions
     */

  }, {
    key: "serverUpdateHandler",
    value: function serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      } // ignore this server update if its from an outdated topologyVersion


      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      } // these will be used for monitoring events later


      var previousTopologyDescription = this.s.description;
      var previousServerDescription = this.s.description.servers.get(serverDescription.address);

      if (!previousServerDescription) {
        return;
      } // Driver Sessions Spec: "Whenever a driver receives a cluster time from
      // a server it MUST compare it to the current highest seen cluster time
      // for the deployment. If the new cluster time is higher than the
      // highest seen cluster time it MUST become the new highest seen cluster
      // time. Two cluster times are compared using only the BsonTimestamp
      // value of the clusterTime embedded field."


      var clusterTime = serverDescription.$clusterTime;

      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      } // If we already know all the information contained in this updated description, then
      // we don't need to emit SDAM events, but still need to update the description, in order
      // to keep client-tracked attributes like last update time and round trip time up to date


      var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription); // first update the TopologyDescription

      this.s.description = this.s.description.update(serverDescription);

      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      } // emit monitoring events for this change


      if (!equalDescriptions) {
        var newDescription = this.s.description.servers.get(serverDescription.address);

        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      } // update server list from updated descriptions


      updateServers(this, serverDescription); // attempt to resolve any outstanding server selection attempts

      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }

      if (!equalDescriptions) {
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
  }, {
    key: "auth",
    value: function auth(credentials, callback) {
      if (typeof credentials === 'function') callback = credentials, credentials = undefined;
      if (typeof callback === 'function') callback(undefined, true);
    }
  }, {
    key: "clientMetadata",
    get: function get() {
      return this.s.options.metadata;
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    } // NOTE: There are many places in code where we explicitly check the last hello
    //       to do feature support detection. This should be done any other way, but for
    //       now we will just return the first hello seen, which should suffice.

  }, {
    key: "lastHello",
    value: function lastHello() {
      var serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0) return {};
      var sd = serverDescriptions.filter(function (sd) {
        return sd.type !== common_1.ServerType.Unknown;
      })[0];
      var result = sd || {
        maxWireVersion: this.description.commonWireVersion
      };
      return result;
    }
  }, {
    key: "commonWireVersion",
    get: function get() {
      return this.description.commonWireVersion;
    }
  }, {
    key: "logicalSessionTimeoutMinutes",
    get: function get() {
      return this.description.logicalSessionTimeoutMinutes;
    }
  }, {
    key: "clusterTime",
    get: function get() {
      return this.s.clusterTime;
    },
    set: function set(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }]);

  return Topology;
}(mongo_types_1.TypedEventEmitter);
/** @event */


Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
/** @event */

Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
/** @event */

Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
/** @event */

Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
/** @event */

Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
/** @event */

Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
/** @event */

Topology.ERROR = constants_1.ERROR;
/** @event */

Topology.OPEN = constants_1.OPEN;
/** @event */

Topology.CONNECT = constants_1.CONNECT;
/** @event */

Topology.CLOSE = constants_1.CLOSE;
/** @event */

Topology.TIMEOUT = constants_1.TIMEOUT;
exports.Topology = Topology;
/** Destroys a server, and removes all event listeners from the instance */

function destroyServer(server, topology, options, callback) {
  var _options6;

  options = (_options6 = options) !== null && _options6 !== void 0 ? _options6 : {
    force: false
  };

  var _iterator4 = _createForOfIteratorHelper(constants_1.LOCAL_SERVER_EVENTS),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var event = _step4.value;
      server.removeAllListeners(event);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  server.destroy(options, function () {
    topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));

    var _iterator5 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var event = _step5.value;
        server.removeAllListeners(event);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    if (typeof callback === 'function') {
      callback();
    }
  });
}
/** Predicts the TopologyType from options */


function topologyTypeFromOptions(options) {
  if (options !== null && options !== void 0 && options.directConnection) {
    return common_1.TopologyType.Single;
  }

  if (options !== null && options !== void 0 && options.replicaSet) {
    return common_1.TopologyType.ReplicaSetNoPrimary;
  }

  if (options !== null && options !== void 0 && options.loadBalanced) {
    return common_1.TopologyType.LoadBalanced;
  }

  return common_1.TopologyType.Unknown;
}
/**
 * Creates new server instances and attempts to connect them
 *
 * @param topology - The topology that this server belongs to
 * @param serverDescription - The description for the server to initialize and connect to
 */


function createAndConnectServer(topology, serverDescription) {
  topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
  var server = new server_1.Server(topology, serverDescription, topology.s.options);

  var _iterator6 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),
      _step6;

  try {
    var _loop = function _loop() {
      var event = _step6.value;
      server.on(event, function (e) {
        return topology.emit(event, e);
      });
    };

    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) {
    return topology.serverUpdateHandler(description);
  });
  server.connect();
  return server;
}
/**
 * @param topology - Topology to update.
 * @param incomingServerDescription - New server description.
 */


function updateServers(topology, incomingServerDescription) {
  // update the internal server's description
  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
    var server = topology.s.servers.get(incomingServerDescription.address);

    if (server) {
      server.s.description = incomingServerDescription;

      if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
        var interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
        server.pool.clear({
          interruptInUseConnections: interruptInUseConnections
        });
      } else if (incomingServerDescription.error == null) {
        var newTopologyType = topology.s.description.type;
        var shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;

        if (shouldMarkPoolReady) {
          server.pool.ready();
        }
      }
    }
  } // add new servers for all descriptions we currently don't know about locally


  var _iterator7 = _createForOfIteratorHelper(topology.description.servers.values()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var serverDescription = _step7.value;

      if (!topology.s.servers.has(serverDescription.address)) {
        var _server = createAndConnectServer(topology, serverDescription);

        topology.s.servers.set(serverDescription.address, _server);
      }
    } // for all servers no longer known, remove their descriptions and destroy their instances

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  var _iterator8 = _createForOfIteratorHelper(topology.s.servers),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var entry = _step8.value;
      var serverAddress = entry[0];

      if (topology.description.hasServer(serverAddress)) {
        continue;
      }

      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }

      var _server2 = topology.s.servers.get(serverAddress);

      topology.s.servers["delete"](serverAddress); // prepare server for garbage collection

      if (_server2) {
        destroyServer(_server2, topology);
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
}

function drainWaitQueue(queue, err) {
  while (queue.length) {
    var waitQueueMember = queue.shift();

    if (!waitQueueMember) {
      continue;
    }

    if (waitQueueMember.timer) {
      (0, timers_1.clearTimeout)(waitQueueMember.timer);
    }

    if (!waitQueueMember[kCancelled]) {
      waitQueueMember.callback(err);
    }
  }
}

function processWaitQueue(topology) {
  if (topology.s.state === common_1.STATE_CLOSED) {
    drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());
    return;
  }

  var isSharded = topology.description.type === common_1.TopologyType.Sharded;
  var serverDescriptions = Array.from(topology.description.servers.values());
  var membersToProcess = topology[kWaitQueue].length;

  for (var i = 0; i < membersToProcess; ++i) {
    var waitQueueMember = topology[kWaitQueue].shift();

    if (!waitQueueMember) {
      continue;
    }

    if (waitQueueMember[kCancelled]) {
      continue;
    }

    var selectedDescriptions = void 0;

    try {
      var serverSelector = waitQueueMember.serverSelector;
      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
    } catch (e) {
      if (waitQueueMember.timer) {
        (0, timers_1.clearTimeout)(waitQueueMember.timer);
      }

      waitQueueMember.callback(e);
      continue;
    }

    var selectedServer = void 0;

    if (selectedDescriptions.length === 0) {
      topology[kWaitQueue].push(waitQueueMember);
      continue;
    } else if (selectedDescriptions.length === 1) {
      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
    } else {
      var descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
      var server1 = topology.s.servers.get(descriptions[0].address);
      var server2 = topology.s.servers.get(descriptions[1].address);
      selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
    }

    if (!selectedServer) {
      waitQueueMember.callback(new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description));
      return;
    }

    var transaction = waitQueueMember.transaction;

    if (isSharded && transaction && transaction.isActive && selectedServer) {
      transaction.pinServer(selectedServer);
    }

    if (waitQueueMember.timer) {
      (0, timers_1.clearTimeout)(waitQueueMember.timer);
    }

    waitQueueMember.callback(undefined, selectedServer);
  }

  if (topology[kWaitQueue].length > 0) {
    // ensure all server monitors attempt monitoring soon
    var _iterator9 = _createForOfIteratorHelper(topology.s.servers),
        _step9;

    try {
      var _loop2 = function _loop2() {
        var _step9$value = _slicedToArray(_step9.value, 2),
            server = _step9$value[1];

        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      };

      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }
}

function isStaleServerDescription(topologyDescription, incomingServerDescription) {
  var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
  var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;
  return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
}
/** @public */


var ServerCapabilities = /*#__PURE__*/function () {
  function ServerCapabilities(hello) {
    _classCallCheck(this, ServerCapabilities);

    this.minWireVersion = hello.minWireVersion || 0;
    this.maxWireVersion = hello.maxWireVersion || 0;
  }

  _createClass(ServerCapabilities, [{
    key: "hasAggregationCursor",
    get: function get() {
      return this.maxWireVersion >= 1;
    }
  }, {
    key: "hasWriteCommands",
    get: function get() {
      return this.maxWireVersion >= 2;
    }
  }, {
    key: "hasTextSearch",
    get: function get() {
      return this.minWireVersion >= 0;
    }
  }, {
    key: "hasAuthCommands",
    get: function get() {
      return this.maxWireVersion >= 1;
    }
  }, {
    key: "hasListCollectionsCommand",
    get: function get() {
      return this.maxWireVersion >= 3;
    }
  }, {
    key: "hasListIndexesCommand",
    get: function get() {
      return this.maxWireVersion >= 3;
    }
  }, {
    key: "supportsSnapshotReads",
    get: function get() {
      return this.maxWireVersion >= 13;
    }
  }, {
    key: "commandsTakeWriteConcern",
    get: function get() {
      return this.maxWireVersion >= 5;
    }
  }, {
    key: "commandsTakeCollation",
    get: function get() {
      return this.maxWireVersion >= 5;
    }
  }]);

  return ServerCapabilities;
}();

exports.ServerCapabilities = ServerCapabilities;

/***/ }),

/***/ 8707:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TopologyDescription = void 0;

var WIRE_CONSTANTS = __webpack_require__(7154);

var error_1 = __webpack_require__(9525);

var utils_1 = __webpack_require__(672);

var common_1 = __webpack_require__(2801);

var server_description_1 = __webpack_require__(3509); // constants related to compatibility checks


var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
var NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);
/**
 * Representation of a deployment of servers
 * @public
 */

var TopologyDescription = /*#__PURE__*/function () {
  /**
   * Create a TopologyDescription
   */
  function TopologyDescription(topologyType) {
    var _options, _options$heartbeatFre, _options$localThresho;

    var serverDescriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var commonWireVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    _classCallCheck(this, TopologyDescription);

    options = (_options = options) !== null && _options !== void 0 ? _options : {};
    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;
    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();
    this.stale = false;
    this.compatible = true;
    this.heartbeatFrequencyMS = (_options$heartbeatFre = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre !== void 0 ? _options$heartbeatFre : 0;
    this.localThresholdMS = (_options$localThresho = options.localThresholdMS) !== null && _options$localThresho !== void 0 ? _options$localThresho : 15;
    this.setName = setName !== null && setName !== void 0 ? setName : null;
    this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;
    this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;
    this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0; // determine server compatibility

    var _iterator = _createForOfIteratorHelper(this.servers.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var serverDescription = _step.value;

        // Load balancer mode is always compatible.
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }

        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " requires wire version ").concat(serverDescription.minWireVersion, ", but this version of the driver only supports up to ").concat(MAX_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MAX_SUPPORTED_SERVER_VERSION, ")");
        }

        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " reports wire version ").concat(serverDescription.maxWireVersion, ", but this version of the driver requires at least ").concat(MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MIN_SUPPORTED_SERVER_VERSION, ").");
          break;
        }
      } // Whenever a client updates the TopologyDescription from a hello response, it MUST set
      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes
      // value among ServerDescriptions of all data-bearing server types. If any have a null
      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be
      // set to null.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.logicalSessionTimeoutMinutes = null;

    var _iterator2 = _createForOfIteratorHelper(this.servers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value2 = _slicedToArray(_step2.value, 2),
            server = _step2$value2[1];

        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            // If any of the servers have a null logicalSessionsTimeout, then the whole topology does
            this.logicalSessionTimeoutMinutes = null;
            break;
          }

          if (this.logicalSessionTimeoutMinutes == null) {
            // First server with a non null logicalSessionsTimeout
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          } // Always select the smaller of the:
          // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout


          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Returns a new TopologyDescription based on the SrvPollingEvent
   * @internal
   */


  _createClass(TopologyDescription, [{
    key: "updateFromSrvPollingEvent",
    value: function updateFromSrvPollingEvent(ev) {
      var srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      /** The SRV addresses defines the set of addresses we should be using */
      var incomingHostnames = ev.hostnames();
      var currentHostnames = new Set(this.servers.keys());
      var hostnamesToAdd = new Set(incomingHostnames);
      var hostnamesToRemove = new Set();

      var _iterator3 = _createForOfIteratorHelper(currentHostnames),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var hostname = _step3.value;
          // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames
          hostnamesToAdd["delete"](hostname);

          if (!incomingHostnames.has(hostname)) {
            // If the SRV Records no longer include this hostname
            // we have to stop using it
            hostnamesToRemove.add(hostname);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        // No new hosts to add and none to remove
        return this;
      }

      var serverDescriptions = new Map(this.servers);

      var _iterator4 = _createForOfIteratorHelper(hostnamesToRemove),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var removedHost = _step4.value;
          serverDescriptions["delete"](removedHost);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          // Add all!
          var _iterator5 = _createForOfIteratorHelper(hostnamesToAdd),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var hostToAdd = _step5.value;
              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          // Add only the amount needed to get us back to srvMaxHosts
          var selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);

          var _iterator6 = _createForOfIteratorHelper(selectedHosts),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var selectedHostToAdd = _step6.value;
              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      }

      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        localThresholdMS: this.localThresholdMS
      });
    }
    /**
     * Returns a copy of this description updated with a given ServerDescription
     * @internal
     */

  }, {
    key: "update",
    value: function update(serverDescription) {
      var address = serverDescription.address; // potentially mutated values

      var topologyType = this.type,
          setName = this.setName,
          maxSetVersion = this.maxSetVersion,
          maxElectionId = this.maxElectionId,
          commonWireVersion = this.commonWireVersion;
      var serverType = serverDescription.type;
      var serverDescriptions = new Map(this.servers); // update common wire version

      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }

      if (typeof serverDescription.setName === 'string' && typeof setName === 'string' && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          // "Single" Topology with setName mismatch is direct connection usage, mark unknown do not remove
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions["delete"](address);
        }
      } // update the actual server description


      serverDescriptions.set(address, serverDescription);

      if (topologyType === common_1.TopologyType.Single) {
        // once we are defined as single, that never changes
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {
          heartbeatFrequencyMS: this.heartbeatFrequencyMS,
          localThresholdMS: this.localThresholdMS
        });
      }

      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions["delete"](address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }

      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions["delete"](address);
        }
      }

      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions["delete"](address);
        }

        if (serverType === common_1.ServerType.RSPrimary) {
          var result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          var _result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);

          topologyType = _result[0];
          setName = _result[1];
        }
      }

      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions["delete"](address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          var _result2 = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);

          topologyType = _result2[0];
          setName = _result2[1];
          maxSetVersion = _result2[2];
          maxElectionId = _result2[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }

      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        localThresholdMS: this.localThresholdMS
      });
    }
  }, {
    key: "error",
    get: function get() {
      var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) {
        return sd.error;
      });

      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }

      return null;
    }
    /**
     * Determines if the topology description has any known servers
     */

  }, {
    key: "hasKnownServers",
    get: function get() {
      return Array.from(this.servers.values()).some(function (sd) {
        return sd.type !== common_1.ServerType.Unknown;
      });
    }
    /**
     * Determines if this topology description has a data-bearing server available.
     */

  }, {
    key: "hasDataBearingServers",
    get: function get() {
      return Array.from(this.servers.values()).some(function (sd) {
        return sd.isDataBearing;
      });
    }
    /**
     * Determines if the topology has a definition for the provided address
     * @internal
     */

  }, {
    key: "hasServer",
    value: function hasServer(address) {
      return this.servers.has(address);
    }
  }]);

  return TopologyDescription;
}();

exports.TopologyDescription = TopologyDescription;

function topologyTypeForServerType(serverType) {
  switch (serverType) {
    case common_1.ServerType.Standalone:
      return common_1.TopologyType.Single;

    case common_1.ServerType.Mongos:
      return common_1.TopologyType.Sharded;

    case common_1.ServerType.RSPrimary:
      return common_1.TopologyType.ReplicaSetWithPrimary;

    case common_1.ServerType.RSOther:
    case common_1.ServerType.RSSecondary:
      return common_1.TopologyType.ReplicaSetNoPrimary;

    default:
      return common_1.TopologyType.Unknown;
  }
}

function updateRsFromPrimary(serverDescriptions, serverDescription) {
  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  setName = setName || serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }

  if (serverDescription.maxWireVersion >= 17) {
    var _maxSetVersion, _serverDescription$se;

    var electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
    var maxElectionIdIsEqual = electionIdComparison === 0;
    var maxElectionIdIsLess = electionIdComparison === -1;
    var maxSetVersionIsLessOrEqual = ((_maxSetVersion = maxSetVersion) !== null && _maxSetVersion !== void 0 ? _maxSetVersion : -1) <= ((_serverDescription$se = serverDescription.setVersion) !== null && _serverDescription$se !== void 0 ? _serverDescription$se : -1);

    if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
      // The reported electionId was greater
      // or the electionId was equal and reported setVersion was greater
      // Always update both values, they are a tuple
      maxElectionId = serverDescription.electionId;
      maxSetVersion = serverDescription.setVersion;
    } else {
      // Stale primary
      // replace serverDescription with a default ServerDescription of type "Unknown"
      serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
  } else {
    var electionId = serverDescription.electionId ? serverDescription.electionId : null;

    if (serverDescription.setVersion && electionId) {
      if (maxSetVersion && maxElectionId) {
        if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
          // this primary is stale, we must remove it
          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      }

      maxElectionId = serverDescription.electionId;
    }

    if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
      maxSetVersion = serverDescription.setVersion;
    }
  } // We've heard from the primary. Is it the same primary as before?


  var _iterator7 = _createForOfIteratorHelper(serverDescriptions),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value2 = _slicedToArray(_step7.value, 2),
          address = _step7$value2[0],
          server = _step7$value2[1];

      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        // Reset old primary's type to Unknown.
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary

        break;
      }
    } // Discover new hosts from this primary's response.

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new server_description_1.ServerDescription(address));
    }
  }); // Remove hosts not in the response.

  var currentAddresses = Array.from(serverDescriptions.keys());
  var responseAddresses = serverDescription.allHosts;
  currentAddresses.filter(function (addr) {
    return responseAddresses.indexOf(addr) === -1;
  }).forEach(function (address) {
    serverDescriptions["delete"](address);
  });
  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
}

function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription) {
  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (setName == null) {
    // TODO(NODE-3483): should be an appropriate runtime error
    throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
  }

  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return checkHasPrimary(serverDescriptions);
}

function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription) {
  var _setName;

  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
  setName = (_setName = setName) !== null && _setName !== void 0 ? _setName : serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [topologyType, setName];
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new server_description_1.ServerDescription(address));
    }
  });

  if (serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return [topologyType, setName];
}

function checkHasPrimary(serverDescriptions) {
  var _iterator8 = _createForOfIteratorHelper(serverDescriptions.values()),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var serverDescription = _step8.value;

      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  return common_1.TopologyType.ReplicaSetNoPrimary;
}

/***/ }),

/***/ 2516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _a;

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(4356);

var metrics_1 = __webpack_require__(1186);

var shared_1 = __webpack_require__(8118);

var constants_1 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var mongo_types_1 = __webpack_require__(1815);

var execute_operation_1 = __webpack_require__(5756);

var run_command_1 = __webpack_require__(6621);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var common_1 = __webpack_require__(2801);

var transactions_1 = __webpack_require__(3879);

var utils_1 = __webpack_require__(672);

var write_concern_1 = __webpack_require__(6916);

var minWireVersionForShardedTransactions = 8;
/** @internal */

var kServerSession = Symbol('serverSession');
/** @internal */

var kSnapshotTime = Symbol('snapshotTime');
/** @internal */

var kSnapshotEnabled = Symbol('snapshotEnabled');
/** @internal */

var kPinnedConnection = Symbol('pinnedConnection');
/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */

var kTxnNumberIncrement = Symbol('txnNumberIncrement');
/**
 * A class representing a client session on the server
 *
 * NOTE: not meant to be instantiated directly.
 * @public
 */

var ClientSession = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(ClientSession, _mongo_types_1$TypedE);

  var _super = _createSuper(ClientSession);

  /**
   * Create a client session.
   * @internal
   * @param client - The current client
   * @param sessionPool - The server session pool (Internal Class)
   * @param options - Optional settings
   * @param clientOptions - Optional settings provided when creating a MongoClient
   */
  function ClientSession(client, sessionPool, options, clientOptions) {
    var _options, _options$causalConsis;

    var _this;

    _classCallCheck(this, ClientSession);

    _this = _super.call(this);
    /** @internal */

    _this[_a] = false;

    if (client == null) {
      // TODO(NODE-3483)
      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');
    }

    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
      // TODO(NODE-3483)
      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');
    }

    options = (_options = options) !== null && _options !== void 0 ? _options : {};

    if (options.snapshot === true) {
      _this[kSnapshotEnabled] = true;

      if (options.causalConsistency === true) {
        throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
      }
    }

    _this.client = client;
    _this.sessionPool = sessionPool;
    _this.hasEnded = false;
    _this.clientOptions = clientOptions;
    _this.explicit = !!options.explicit;
    _this[kServerSession] = _this.explicit ? _this.sessionPool.acquire() : null;
    _this[kTxnNumberIncrement] = 0;
    var defaultCausalConsistencyValue = _this.explicit && options.snapshot !== true;
    _this.supports = {
      // if we can enable causal consistency, do so by default
      causalConsistency: (_options$causalConsis = options.causalConsistency) !== null && _options$causalConsis !== void 0 ? _options$causalConsis : defaultCausalConsistencyValue
    };
    _this.clusterTime = options.initialClusterTime;
    _this.operationTime = undefined;
    _this.owner = options.owner;
    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
    _this.transaction = new transactions_1.Transaction();
    return _this;
  }
  /** The server id associated with this session */


  _createClass(ClientSession, [{
    key: "id",
    get: function get() {
      var _this$kServerSession;

      return (_this$kServerSession = this[kServerSession]) === null || _this$kServerSession === void 0 ? void 0 : _this$kServerSession.id;
    }
  }, {
    key: "serverSession",
    get: function get() {
      var serverSession = this[kServerSession];

      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');
        }

        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');
        }

        serverSession = this.sessionPool.acquire();
        this[kServerSession] = serverSession;
      }

      return serverSession;
    }
    /** Whether or not this session is configured for snapshot reads */

  }, {
    key: "snapshotEnabled",
    get: function get() {
      return this[kSnapshotEnabled];
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      var _this$client$topology;

      return ((_this$client$topology = this.client.topology) === null || _this$client$topology === void 0 ? void 0 : _this$client$topology.description.type) === common_1.TopologyType.LoadBalanced;
    }
    /** @internal */

  }, {
    key: "pinnedConnection",
    get: function get() {
      return this[kPinnedConnection];
    }
    /** @internal */

  }, {
    key: "pin",
    value: function pin(conn) {
      if (this[kPinnedConnection]) {
        throw TypeError('Cannot pin multiple connections to the same session');
      }

      this[kPinnedConnection] = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    /** @internal */

  }, {
    key: "unpin",
    value: function unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }

      this.transaction.unpinServer();
    }
  }, {
    key: "isPinned",
    get: function get() {
      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
    }
    /**
     * Ends this session on the server
     *
     * @param options - Optional settings. Currently reserved for future use
     */

  }, {
    key: "endSession",
    value: function () {
      var _endSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var serverSession;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;

              if (!this.inTransaction()) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return this.abortTransaction();

            case 4:
              if (!this.hasEnded) {
                serverSession = this[kServerSession];

                if (serverSession != null) {
                  // release the server session back to the pool
                  this.sessionPool.release(serverSession); // Make sure a new serverSession never makes it onto this ClientSession

                  Object.defineProperty(this, kServerSession, {
                    value: ServerSession.clone(serverSession),
                    writable: false
                  });
                } // mark the session as ended, and emit a signal


                this.hasEnded = true;
                this.emit('ended', this);
              }

              _context.next = 9;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);

            case 9:
              _context.prev = 9;
              maybeClearPinnedConnection(this, _objectSpread({
                force: true
              }, options));
              return _context.finish(9);

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 7, 9, 12]]);
      }));

      function endSession(_x) {
        return _endSession.apply(this, arguments);
      }

      return endSession;
    }()
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */

  }, {
    key: "advanceOperationTime",
    value: function advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }

      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    /**
     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
     *
     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
     */

  }, {
    key: "advanceClusterTime",
    value: function advanceClusterTime(clusterTime) {
      var _clusterTime$signatur, _clusterTime$signatur2;

      if (!clusterTime || _typeof(clusterTime) !== 'object') {
        throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');
      }

      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }

      if (!clusterTime.signature || ((_clusterTime$signatur = clusterTime.signature.hash) === null || _clusterTime$signatur === void 0 ? void 0 : _clusterTime$signatur._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && ((_clusterTime$signatur2 = clusterTime.signature.keyId) === null || _clusterTime$signatur2 === void 0 ? void 0 : _clusterTime$signatur2._bsontype) !== 'Long' // apparently we decode the key to number?
      ) {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }

      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */

  }, {
    key: "equals",
    value: function equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }

      if (this.id == null || session.id == null) {
        return false;
      }

      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    }
    /**
     * Increment the transaction number on the internal ServerSession
     *
     * @privateRemarks
     * This helper increments a value stored on the client session that will be
     * added to the serverSession's txnNumber upon applying it to a command.
     * This is because the serverSession is lazily acquired after a connection is obtained
     */

  }, {
    key: "incrementTransactionNumber",
    value: function incrementTransactionNumber() {
      this[kTxnNumberIncrement] += 1;
    }
    /** @returns whether this session is currently in a transaction or not */

  }, {
    key: "inTransaction",
    value: function inTransaction() {
      return this.transaction.isActive;
    }
    /**
     * Starts a new transaction with the given options.
     *
     * @param options - Options for the transaction
     */

  }, {
    key: "startTransaction",
    value: function startTransaction(options) {
      var _ref, _options$readConcern, _this$clientOptions, _ref2, _options$writeConcern, _this$clientOptions2, _ref3, _options$readPreferen, _this$clientOptions3, _options$maxCommitTim;

      if (this[kSnapshotEnabled]) {
        throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');
      }

      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError('Transaction already in progress');
      }

      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }

      var topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);

      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');
      } // increment txnNumber


      this.incrementTransactionNumber(); // create transaction state

      this.transaction = new transactions_1.Transaction({
        readConcern: (_ref = (_options$readConcern = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _options$readConcern !== void 0 ? _options$readConcern : this.defaultTransactionOptions.readConcern) !== null && _ref !== void 0 ? _ref : (_this$clientOptions = this.clientOptions) === null || _this$clientOptions === void 0 ? void 0 : _this$clientOptions.readConcern,
        writeConcern: (_ref2 = (_options$writeConcern = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _options$writeConcern !== void 0 ? _options$writeConcern : this.defaultTransactionOptions.writeConcern) !== null && _ref2 !== void 0 ? _ref2 : (_this$clientOptions2 = this.clientOptions) === null || _this$clientOptions2 === void 0 ? void 0 : _this$clientOptions2.writeConcern,
        readPreference: (_ref3 = (_options$readPreferen = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : this.defaultTransactionOptions.readPreference) !== null && _ref3 !== void 0 ? _ref3 : (_this$clientOptions3 = this.clientOptions) === null || _this$clientOptions3 === void 0 ? void 0 : _this$clientOptions3.readPreference,
        maxCommitTimeMS: (_options$maxCommitTim = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _options$maxCommitTim !== void 0 ? _options$maxCommitTim : this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    /**
     * Commits the currently active transaction in this session.
     */

  }, {
    key: "commitTransaction",
    value: function () {
      var _commitTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", endTransactionAsync(this, 'commitTransaction'));

            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function commitTransaction() {
        return _commitTransaction.apply(this, arguments);
      }

      return commitTransaction;
    }()
    /**
     * Aborts the currently active transaction in this session.
     */

  }, {
    key: "abortTransaction",
    value: function () {
      var _abortTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", endTransactionAsync(this, 'abortTransaction'));

            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function abortTransaction() {
        return _abortTransaction.apply(this, arguments);
      }

      return abortTransaction;
    }()
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */

  }, {
    key: "toBSON",
    value: function toBSON() {
      throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');
    }
    /**
     * Runs a provided callback within a transaction, retrying either the commitTransaction operation
     * or entire transaction as needed (and when the error permits) to better ensure that
     * the transaction can complete successfully.
     *
     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.
     * Any callbacks that do not return a Promise will result in undefined behavior.
     *
     * @remarks
     * This function:
     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)
     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`
     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback
     *
     * Checkout a descriptive example here:
     * @see https://www.mongodb.com/developer/quickstart/node-transactions/
     *
     * @param fn - callback to run within a transaction
     * @param options - optional settings for the transaction
     * @returns A raw command response or undefined
     */

  }, {
    key: "withTransaction",
    value: function () {
      var _withTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fn, options) {
        var startTime;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              startTime = (0, utils_1.now)();
              return _context4.abrupt("return", attemptTransaction(this, startTime, fn, options));

            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function withTransaction(_x2, _x3) {
        return _withTransaction.apply(this, arguments);
      }

      return withTransaction;
    }()
  }]);

  return ClientSession;
}(mongo_types_1.TypedEventEmitter);

exports.ClientSession = ClientSession;
_a = kSnapshotEnabled;
var MAX_WITH_TRANSACTION_TIMEOUT = 120000;
var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);

function hasNotTimedOut(startTime, max) {
  return (0, utils_1.calculateDurationInMs)(startTime) < max;
}

function isUnknownTransactionCommitResult(err) {
  var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
}

function maybeClearPinnedConnection(session, options) {
  // unpin a connection if it has been pinned
  var conn = session[kPinnedConnection];
  var error = options === null || options === void 0 ? void 0 : options.error;

  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
    return;
  }

  var topology = session.client.topology; // NOTE: the spec talks about what to do on a network error only, but the tests seem to
  //       to validate that we don't unpin on _all_ errors?

  if (conn && topology != null) {
    var servers = Array.from(topology.s.servers.values());
    var loadBalancer = servers[0];

    if ((options === null || options === void 0 ? void 0 : options.error) == null || options !== null && options !== void 0 && options.force) {
      loadBalancer.pool.checkIn(conn);
      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);

      if (options !== null && options !== void 0 && options.forceClear) {
        loadBalancer.pool.clear({
          serviceId: conn.serviceId
        });
      }
    }

    session[kPinnedConnection] = undefined;
  }
}

exports.maybeClearPinnedConnection = maybeClearPinnedConnection;

function isMaxTimeMSExpiredError(err) {
  if (err == null || !(err instanceof error_1.MongoServerError)) {
    return false;
  }

  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
}

function attemptTransactionCommit(session, startTime, fn, options) {
  return session.commitTransaction()["catch"](function (err) {
    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
        return attemptTransactionCommit(session, startTime, fn, options);
      }

      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return attemptTransaction(session, startTime, fn, options);
      }
    }

    throw err;
  });
}

var USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);

function userExplicitlyEndedTransaction(session) {
  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
}

function attemptTransaction(session, startTime, fn, options) {
  session.startTransaction(options);
  var promise;

  try {
    promise = fn(session);
  } catch (err) {
    promise = Promise.reject(err);
  }

  if (!(0, utils_1.isPromiseLike)(promise)) {
    session.abortTransaction()["catch"](function () {
      return null;
    });
    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');
  }

  return promise.then(function () {
    if (userExplicitlyEndedTransaction(session)) {
      return;
    }

    return attemptTransactionCommit(session, startTime, fn, options);
  }, function (err) {
    function maybeRetryOrThrow(err) {
      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
        return attemptTransaction(session, startTime, fn, options);
      }

      if (isMaxTimeMSExpiredError(err)) {
        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
      }

      throw err;
    }

    if (session.inTransaction()) {
      return session.abortTransaction().then(function () {
        return maybeRetryOrThrow(err);
      });
    }

    return maybeRetryOrThrow(err);
  });
}

var endTransactionAsync = (0, util_1.promisify)(endTransaction);

function endTransaction(session, commandName, callback) {
  // handle any initial problematic cases
  var txnState = session.transaction.state;

  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
    callback(new error_1.MongoTransactionError('No transaction started'));
    return;
  }

  if (commandName === 'commitTransaction') {
    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
      // the transaction was never started, we can safely exit here
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
      callback();
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));
      return;
    }
  } else {
    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
      // the transaction was never started, we can safely exit here
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
      callback();
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));
      return;
    }
  } // construct and send the command


  var command = _defineProperty({}, commandName, 1); // apply a writeConcern if specified


  var writeConcern;

  if (session.transaction.options.writeConcern) {
    writeConcern = Object.assign({}, session.transaction.options.writeConcern);
  } else if (session.clientOptions && session.clientOptions.writeConcern) {
    writeConcern = {
      w: session.clientOptions.writeConcern.w
    };
  }

  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
    writeConcern = Object.assign({
      wtimeoutMS: 10000
    }, writeConcern, {
      w: 'majority'
    });
  }

  if (writeConcern) {
    write_concern_1.WriteConcern.apply(command, writeConcern);
  }

  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {
    Object.assign(command, {
      maxTimeMS: session.transaction.options.maxTimeMS
    });
  }

  function commandHandler(error, result) {
    if (commandName !== 'commitTransaction') {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);

      if (session.loadBalanced) {
        maybeClearPinnedConnection(session, {
          force: false
        });
      } // The spec indicates that we should ignore all errors on `abortTransaction`


      return callback();
    }

    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);

    if (error instanceof error_1.MongoError) {
      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {
        if (isUnknownTransactionCommitResult(error)) {
          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult); // per txns spec, must unpin session in this case

          session.unpin({
            error: error
          });
        }
      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({
          error: error
        });
      }
    }

    callback(error, result);
  }

  if (session.transaction.recoveryToken) {
    command.recoveryToken = session.transaction.recoveryToken;
  } // send the command


  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
    session: session,
    readPreference: read_preference_1.ReadPreference.primary,
    bypassPinningCheck: true
  }), function (error, result) {
    if (command.abortTransaction) {
      // always unpin on abort regardless of command outcome
      session.unpin();
    }

    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {
      // SPEC-1185: apply majority write concern when retrying commitTransaction
      if (command.commitTransaction) {
        // per txns spec, must unpin session in this case
        session.unpin({
          force: true
        });
        command.writeConcern = Object.assign({
          wtimeout: 10000
        }, command.writeConcern, {
          w: 'majority'
        });
      }

      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
        session: session,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      }), commandHandler);
    }

    commandHandler(error, result);
  });
}
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */


var ServerSession = /*#__PURE__*/function () {
  /** @internal */
  function ServerSession() {
    _classCallCheck(this, ServerSession);

    this.id = {
      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)
    };
    this.lastUse = (0, utils_1.now)();
    this.txnNumber = 0;
    this.isDirty = false;
  }
  /**
   * Determines if the server session has timed out.
   *
   * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
   */


  _createClass(ServerSession, [{
    key: "hasTimedOut",
    value: function hasTimedOut(sessionTimeoutMinutes) {
      // Take the difference of the lastUse timestamp and now, which will result in a value in
      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
      var idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
    /**
     * @internal
     * Cloning meant to keep a readable reference to the server session data
     * after ClientSession has ended
     */

  }], [{
    key: "clone",
    value: function clone(serverSession) {
      var arrayBuffer = new ArrayBuffer(16);
      var idBytes = Buffer.from(arrayBuffer);
      idBytes.set(serverSession.id.id.buffer);
      var id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type); // Manual prototype construction to avoid modifying the constructor of this class

      return Object.setPrototypeOf({
        id: {
          id: id
        },
        lastUse: serverSession.lastUse,
        txnNumber: serverSession.txnNumber,
        isDirty: serverSession.isDirty
      }, ServerSession.prototype);
    }
  }]);

  return ServerSession;
}();

exports.ServerSession = ServerSession;
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */

var ServerSessionPool = /*#__PURE__*/function () {
  function ServerSessionPool(client) {
    _classCallCheck(this, ServerSessionPool);

    if (client == null) {
      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');
    }

    this.client = client;
    this.sessions = new utils_1.List();
  }
  /**
   * Acquire a Server Session from the pool.
   * Iterates through each session in the pool, removing any stale sessions
   * along the way. The first non-stale session found is removed from the
   * pool and returned. If no non-stale session is found, a new ServerSession is created.
   */


  _createClass(ServerSessionPool, [{
    key: "acquire",
    value: function acquire() {
      var _this$client$topology2, _this$client$topology3;

      var sessionTimeoutMinutes = (_this$client$topology2 = (_this$client$topology3 = this.client.topology) === null || _this$client$topology3 === void 0 ? void 0 : _this$client$topology3.logicalSessionTimeoutMinutes) !== null && _this$client$topology2 !== void 0 ? _this$client$topology2 : 10;
      var session = null; // Try to obtain from session pool

      while (this.sessions.length > 0) {
        var _this$client$topology4;

        var potentialSession = this.sessions.shift();

        if (potentialSession != null && (!!((_this$client$topology4 = this.client.topology) !== null && _this$client$topology4 !== void 0 && _this$client$topology4.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      } // If nothing valid came from the pool make a new one


      if (session == null) {
        session = new ServerSession();
      }

      return session;
    }
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */

  }, {
    key: "release",
    value: function release(session) {
      var _this$client$topology5, _this$client$topology6, _this$client$topology7;

      var sessionTimeoutMinutes = (_this$client$topology5 = (_this$client$topology6 = this.client.topology) === null || _this$client$topology6 === void 0 ? void 0 : _this$client$topology6.logicalSessionTimeoutMinutes) !== null && _this$client$topology5 !== void 0 ? _this$client$topology5 : 10;

      if ((_this$client$topology7 = this.client.topology) !== null && _this$client$topology7 !== void 0 && _this$client$topology7.loadBalanced && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }

      if (!sessionTimeoutMinutes) {
        return;
      }

      this.sessions.prune(function (session) {
        return session.hasTimedOut(sessionTimeoutMinutes);
      });

      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        } // otherwise, readd this session to the session pool


        this.sessions.unshift(session);
      }
    }
  }]);

  return ServerSessionPool;
}();

exports.ServerSessionPool = ServerSessionPool;
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 *
 * @internal
 */

function applySession(session, command, options) {
  var _options$writeConcern2;

  if (session.hasEnded) {
    return new error_1.MongoExpiredSessionError();
  } // May acquire serverSession here


  var serverSession = session.serverSession;

  if (serverSession == null) {
    return new error_1.MongoRuntimeError('Unable to acquire server session');
  }

  if (((_options$writeConcern2 = options.writeConcern) === null || _options$writeConcern2 === void 0 ? void 0 : _options$writeConcern2.w) === 0) {
    if (session && session.explicit) {
      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)
      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');
    }

    return;
  } // mark the last use of this session, and apply the `lsid`


  serverSession.lastUse = (0, utils_1.now)();
  command.lsid = serverSession.id;
  var inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
  var isRetryableWrite = !!options.willRetryWrite;

  if (isRetryableWrite || inTxnOrTxnCommand) {
    serverSession.txnNumber += session[kTxnNumberIncrement];
    session[kTxnNumberIncrement] = 0; // TODO(NODE-2674): Preserve int64 sent from MongoDB

    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
  }

  if (!inTxnOrTxnCommand) {
    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
    }

    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {
      command.readConcern = command.readConcern || {};
      Object.assign(command.readConcern, {
        afterClusterTime: session.operationTime
      });
    } else if (session[kSnapshotEnabled]) {
      command.readConcern = command.readConcern || {
        level: read_concern_1.ReadConcernLevel.snapshot
      };

      if (session[kSnapshotTime] != null) {
        Object.assign(command.readConcern, {
          atClusterTime: session[kSnapshotTime]
        });
      }
    }

    return;
  } // now attempt to apply transaction-specific sessions data
  // `autocommit` must always be false to differentiate from retryable writes


  command.autocommit = false;

  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
    var _session$clientOption;

    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
    command.startTransaction = true;
    var readConcern = session.transaction.options.readConcern || (session === null || session === void 0 || (_session$clientOption = session.clientOptions) === null || _session$clientOption === void 0 ? void 0 : _session$clientOption.readConcern);

    if (readConcern) {
      command.readConcern = readConcern;
    }

    if (session.supports.causalConsistency && session.operationTime) {
      command.readConcern = command.readConcern || {};
      Object.assign(command.readConcern, {
        afterClusterTime: session.operationTime
      });
    }
  }

  return;
}

exports.applySession = applySession;

function updateSessionFromResponse(session, document) {
  if (document.$clusterTime) {
    (0, common_1._advanceClusterTime)(session, document.$clusterTime);
  }

  if (document.operationTime && session && session.supports.causalConsistency) {
    session.advanceOperationTime(document.operationTime);
  }

  if (document.recoveryToken && session && session.inTransaction()) {
    session.transaction._recoveryToken = document.recoveryToken;
  }

  if (session !== null && session !== void 0 && session[kSnapshotEnabled] && session[kSnapshotTime] == null) {
    var _document$cursor;

    // find and aggregate commands return atClusterTime on the cursor
    // distinct includes it in the response body
    var atClusterTime = ((_document$cursor = document.cursor) === null || _document$cursor === void 0 ? void 0 : _document$cursor.atClusterTime) || document.atClusterTime;

    if (atClusterTime) {
      session[kSnapshotTime] = atClusterTime;
    }
  }
}

exports.updateSessionFromResponse = updateSessionFromResponse;

/***/ }),

/***/ 8077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.formatSort = void 0;

var error_1 = __webpack_require__(9525);
/** @internal */


function prepareDirection() {
  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var value = "".concat(direction).toLowerCase();
  if (isMeta(direction)) return direction;

  switch (value) {
    case 'ascending':
    case 'asc':
    case '1':
      return 1;

    case 'descending':
    case 'desc':
    case '-1':
      return -1;

    default:
      throw new error_1.MongoInvalidArgumentError("Invalid sort direction: ".concat(JSON.stringify(direction)));
  }
}
/** @internal */


function isMeta(t) {
  return _typeof(t) === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';
}
/** @internal */


function isPair(t) {
  if (Array.isArray(t) && t.length === 2) {
    try {
      prepareDirection(t[1]);
      return true;
    } catch (e) {
      return false;
    }
  }

  return false;
}

function isDeep(t) {
  return Array.isArray(t) && Array.isArray(t[0]);
}

function isMap(t) {
  return t instanceof Map && t.size > 0;
}
/** @internal */


function pairToMap(v) {
  return new Map([["".concat(v[0]), prepareDirection([v[1]])]]);
}
/** @internal */


function deepToMap(t) {
  var sortEntries = t.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** @internal */


function stringsToMap(t) {
  var sortEntries = t.map(function (key) {
    return ["".concat(key), 1];
  });
  return new Map(sortEntries);
}
/** @internal */


function objectToMap(t) {
  var sortEntries = Object.entries(t).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        k = _ref4[0],
        v = _ref4[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** @internal */


function mapToMap(t) {
  var sortEntries = Array.from(t).map(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        k = _ref6[0],
        v = _ref6[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** converts a Sort type into a type that is valid for the server (SortForCmd) */


function formatSort(sort, direction) {
  if (sort == null) return undefined;
  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);

  if (_typeof(sort) !== 'object') {
    throw new error_1.MongoInvalidArgumentError("Invalid sort format: ".concat(JSON.stringify(sort), " Sort must be a valid object"));
  }

  if (!Array.isArray(sort)) {
    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
  }

  if (!sort.length) return undefined;
  if (isDeep(sort)) return deepToMap(sort);
  if (isPair(sort)) return pairToMap(sort);
  return stringsToMap(sort);
}

exports.formatSort = formatSort;

/***/ }),

/***/ 3879:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _stateMachine;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isTransactionCommand = exports.Transaction = exports.TxnState = void 0;

var error_1 = __webpack_require__(9525);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var write_concern_1 = __webpack_require__(6916);
/** @internal */


exports.TxnState = Object.freeze({
  NO_TRANSACTION: 'NO_TRANSACTION',
  STARTING_TRANSACTION: 'STARTING_TRANSACTION',
  TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
  TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
  TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
  TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
});
var stateMachine = (_stateMachine = {}, _defineProperty(_stateMachine, exports.TxnState.NO_TRANSACTION, [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.STARTING_TRANSACTION, [exports.TxnState.TRANSACTION_IN_PROGRESS, exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.TRANSACTION_ABORTED]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_IN_PROGRESS, [exports.TxnState.TRANSACTION_IN_PROGRESS, exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_ABORTED]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_COMMITTED, [exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_ABORTED, [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, [exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.NO_TRANSACTION]), _stateMachine);
var ACTIVE_STATES = new Set([exports.TxnState.STARTING_TRANSACTION, exports.TxnState.TRANSACTION_IN_PROGRESS]);
var COMMITTED_STATES = new Set([exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.TRANSACTION_ABORTED]);
/**
 * @public
 * A class maintaining state related to a server transaction. Internal Only
 */

var Transaction = /*#__PURE__*/function () {
  /** Create a transaction @internal */
  function Transaction(options) {
    var _options;

    _classCallCheck(this, Transaction);

    options = (_options = options) !== null && _options !== void 0 ? _options : {};
    this.state = exports.TxnState.NO_TRANSACTION;
    this.options = {};
    var writeConcern = write_concern_1.WriteConcern.fromOptions(options);

    if (writeConcern) {
      if (writeConcern.w === 0) {
        throw new error_1.MongoTransactionError('Transactions do not support unacknowledged write concern');
      }

      this.options.writeConcern = writeConcern;
    }

    if (options.readConcern) {
      this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
    }

    if (options.readPreference) {
      this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
    }

    if (options.maxCommitTimeMS) {
      this.options.maxTimeMS = options.maxCommitTimeMS;
    } // TODO: This isn't technically necessary


    this._pinnedServer = undefined;
    this._recoveryToken = undefined;
  }
  /** @internal */


  _createClass(Transaction, [{
    key: "server",
    get: function get() {
      return this._pinnedServer;
    }
  }, {
    key: "recoveryToken",
    get: function get() {
      return this._recoveryToken;
    }
  }, {
    key: "isPinned",
    get: function get() {
      return !!this.server;
    }
    /** @returns Whether the transaction has started */

  }, {
    key: "isStarting",
    get: function get() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    /**
     * @returns Whether this session is presently in a transaction
     */

  }, {
    key: "isActive",
    get: function get() {
      return ACTIVE_STATES.has(this.state);
    }
  }, {
    key: "isCommitted",
    get: function get() {
      return COMMITTED_STATES.has(this.state);
    }
    /**
     * Transition the transaction in the state machine
     * @internal
     * @param nextState - The new state to transition to
     */

  }, {
    key: "transition",
    value: function transition(nextState) {
      var nextStates = stateMachine[this.state];

      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;

        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }

        return;
      }

      throw new error_1.MongoRuntimeError("Attempted illegal state transition from [".concat(this.state, "] to [").concat(nextState, "]"));
    }
    /** @internal */

  }, {
    key: "pinServer",
    value: function pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    /** @internal */

  }, {
    key: "unpinServer",
    value: function unpinServer() {
      this._pinnedServer = undefined;
    }
  }]);

  return Transaction;
}();

exports.Transaction = Transaction;

function isTransactionCommand(command) {
  return !!(command.commitTransaction || command.abortTransaction);
}

exports.isTransactionCommand = isTransactionCommand;

/***/ }),

/***/ 672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.matchesParentDomain = exports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.hostMatchesWildcards = exports.ByteUtils = void 0;
exports.request = void 0;

var crypto = __webpack_require__(6113);

var http = __webpack_require__(3685);

var url = __webpack_require__(7310);

var url_1 = __webpack_require__(7310);

var bson_1 = __webpack_require__(4356);

var constants_1 = __webpack_require__(7154);

var constants_2 = __webpack_require__(9592);

var error_1 = __webpack_require__(9525);

var read_concern_1 = __webpack_require__(2445);

var read_preference_1 = __webpack_require__(4064);

var common_1 = __webpack_require__(2801);

var write_concern_1 = __webpack_require__(6916);

exports.ByteUtils = {
  toLocalBufferType: function toLocalBufferType(buffer) {
    return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  },
  equals: function equals(seqA, seqB) {
    return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
  },
  compare: function compare(seqA, seqB) {
    return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
  },
  toBase64: function toBase64(uint8array) {
    return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');
  }
};
/**
 * Determines if a connection's address matches a user provided list
 * of domain wildcards.
 */

function hostMatchesWildcards(host, wildcards) {
  var _iterator = _createForOfIteratorHelper(wildcards),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var wildcard = _step.value;

      if (host === wildcard || wildcard.startsWith('*.') && host !== null && host !== void 0 && host.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith('*/') && host !== null && host !== void 0 && host.endsWith(wildcard.substring(2, wildcard.length))) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}

exports.hostMatchesWildcards = hostMatchesWildcards;
/**
 * Throws if collectionName is not a valid mongodb collection namespace.
 * @internal
 */

function checkCollectionName(collectionName) {
  if ('string' !== typeof collectionName) {
    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');
  }

  if (!collectionName || collectionName.indexOf('..') !== -1) {
    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');
  }

  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError("Collection names must not contain '$'");
  }

  if (collectionName.match(/^\.|\.$/) != null) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError("Collection names must not start or end with '.'");
  } // Validate that we are not passing 0x00 in the collection name


  if (collectionName.indexOf('\x00') !== -1) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');
  }
}

exports.checkCollectionName = checkCollectionName;
/**
 * Ensure Hint field is in a shape we expect:
 * - object of index names mapping to 1 or -1
 * - just an index name
 * @internal
 */

function normalizeHintField(hint) {
  var finalHint = undefined;

  if (typeof hint === 'string') {
    finalHint = hint;
  } else if (Array.isArray(hint)) {
    finalHint = {};
    hint.forEach(function (param) {
      finalHint[param] = 1;
    });
  } else if (hint != null && _typeof(hint) === 'object') {
    finalHint = {};

    for (var name in hint) {
      finalHint[name] = hint[name];
    }
  }

  return finalHint;
}

exports.normalizeHintField = normalizeHintField;

var TO_STRING = function TO_STRING(object) {
  return Object.prototype.toString.call(object);
};
/**
 * Checks if arg is an Object:
 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
 * @internal
 */


function isObject(arg) {
  return '[object Object]' === TO_STRING(arg);
}

exports.isObject = isObject;
/** @internal */

function mergeOptions(target, source) {
  return _objectSpread(_objectSpread({}, target), source);
}

exports.mergeOptions = mergeOptions;
/** @internal */

function filterOptions(options, names) {
  var filterOptions = {};

  for (var name in options) {
    if (names.includes(name)) {
      filterOptions[name] = options[name];
    }
  } // Filtered options


  return filterOptions;
}

exports.filterOptions = filterOptions;
/**
 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
 * @internal
 *
 * @param target - The target command to which we will apply retryWrites.
 * @param db - The database from which we can inherit a retryWrites value.
 */

function applyRetryableWrites(target, db) {
  var _db$s$options;

  if (db && (_db$s$options = db.s.options) !== null && _db$s$options !== void 0 && _db$s$options.retryWrites) {
    target.retryWrites = true;
  }

  return target;
}

exports.applyRetryableWrites = applyRetryableWrites;
/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 * @internal
 *
 * @param target - the target command we will be applying the write concern to
 * @param sources - sources where we can inherit default write concerns from
 * @param options - optional settings passed into a command for write concern overrides
 */

/**
 * Checks if a given value is a Promise
 *
 * @typeParam T - The resolution type of the possible promise
 * @param value - An object that could be a promise
 * @returns true if the provided value is a Promise
 */

function isPromiseLike(value) {
  return !!value && typeof value.then === 'function';
}

exports.isPromiseLike = isPromiseLike;
/**
 * Applies collation to a given command.
 * @internal
 *
 * @param command - the command on which to apply collation
 * @param target - target of command
 * @param options - options containing collation settings
 */

function decorateWithCollation(command, target, options) {
  var capabilities = getTopology(target).capabilities;

  if (options.collation && _typeof(options.collation) === 'object') {
    if (capabilities && capabilities.commandsTakeCollation) {
      command.collation = options.collation;
    } else {
      throw new error_1.MongoCompatibilityError("Current topology does not support collation");
    }
  }
}

exports.decorateWithCollation = decorateWithCollation;
/**
 * Applies a read concern to a given command.
 * @internal
 *
 * @param command - the command on which to apply the read concern
 * @param coll - the parent collection of the operation calling this method
 */

function decorateWithReadConcern(command, coll, options) {
  if (options && options.session && options.session.inTransaction()) {
    return;
  }

  var readConcern = Object.assign({}, command.readConcern || {});

  if (coll.s.readConcern) {
    Object.assign(readConcern, coll.s.readConcern);
  }

  if (Object.keys(readConcern).length > 0) {
    Object.assign(command, {
      readConcern: readConcern
    });
  }
}

exports.decorateWithReadConcern = decorateWithReadConcern;
/**
 * Applies an explain to a given command.
 * @internal
 *
 * @param command - the command on which to apply the explain
 * @param options - the options containing the explain verbosity
 */

function decorateWithExplain(command, explain) {
  if (command.explain) {
    return command;
  }

  return {
    explain: command,
    verbosity: explain.verbosity
  };
}

exports.decorateWithExplain = decorateWithExplain;
/**
 * A helper function to get the topology from a given provider. Throws
 * if the topology cannot be found.
 * @throws MongoNotConnectedError
 * @internal
 */

function getTopology(provider) {
  // MongoClient or ClientSession or AbstractCursor
  if ('topology' in provider && provider.topology) {
    return provider.topology;
  } else if ('client' in provider && provider.client.topology) {
    return provider.client.topology;
  }

  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');
}

exports.getTopology = getTopology;
/** @internal */

function ns(ns) {
  return MongoDBNamespace.fromString(ns);
}

exports.ns = ns;
/** @public */

var MongoDBNamespace = /*#__PURE__*/function () {
  /**
   * Create a namespace object
   *
   * @param db - database name
   * @param collection - collection name
   */
  function MongoDBNamespace(db, collection) {
    _classCallCheck(this, MongoDBNamespace);

    this.db = db;
    this.collection = collection;
    this.collection = collection === '' ? undefined : collection;
  }

  _createClass(MongoDBNamespace, [{
    key: "toString",
    value: function toString() {
      return this.collection ? "".concat(this.db, ".").concat(this.collection) : this.db;
    }
  }, {
    key: "withCollection",
    value: function withCollection(collection) {
      return new MongoDBCollectionNamespace(this.db, collection);
    }
  }], [{
    key: "fromString",
    value: function fromString(namespace) {
      if (typeof namespace !== 'string' || namespace === '') {
        // TODO(NODE-3483): Replace with MongoNamespaceError
        throw new error_1.MongoRuntimeError("Cannot parse namespace from \"".concat(namespace, "\""));
      }

      var _namespace$split = namespace.split('.'),
          _namespace$split2 = _toArray(_namespace$split),
          db = _namespace$split2[0],
          collectionParts = _namespace$split2.slice(1);

      var collection = collectionParts.join('.');
      return new MongoDBNamespace(db, collection === '' ? undefined : collection);
    }
  }]);

  return MongoDBNamespace;
}();

exports.MongoDBNamespace = MongoDBNamespace;
/**
 * @public
 *
 * A class representing a collection's namespace.  This class enforces (through Typescript) that
 * the `collection` portion of the namespace is defined and should only be
 * used in scenarios where this can be guaranteed.
 */

var MongoDBCollectionNamespace = /*#__PURE__*/function (_MongoDBNamespace) {
  _inherits(MongoDBCollectionNamespace, _MongoDBNamespace);

  var _super = _createSuper(MongoDBCollectionNamespace);

  function MongoDBCollectionNamespace(db, collection) {
    var _this;

    _classCallCheck(this, MongoDBCollectionNamespace);

    _this = _super.call(this, db, collection);
    _this.collection = collection;
    return _this;
  }

  return _createClass(MongoDBCollectionNamespace);
}(MongoDBNamespace);

exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
/** @internal */

function makeCounter() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var count, newCount;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          count = seed;

        case 1:
          if (false) {}

          newCount = count;
          count += 1;
          _context.next = 6;
          return newCount;

        case 6:
          _context.next = 1;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })();
}

exports.makeCounter = makeCounter;

function maybeCallback(promiseFn, callback) {
  var promise = promiseFn();

  if (callback == null) {
    return promise;
  }

  promise.then(function (result) {
    return callback(undefined, result);
  }, function (error) {
    return callback(error);
  });
  return;
}

exports.maybeCallback = maybeCallback;
/** @internal */

function databaseNamespace(ns) {
  return ns.split('.')[0];
}

exports.databaseNamespace = databaseNamespace;
/**
 * Synchronously Generate a UUIDv4
 * @internal
 */

function uuidV4() {
  var result = crypto.randomBytes(16);
  result[6] = result[6] & 0x0f | 0x40;
  result[8] = result[8] & 0x3f | 0x80;
  return result;
}

exports.uuidV4 = uuidV4;
/**
 * A helper function for determining `maxWireVersion` between legacy and new topology instances
 * @internal
 */

function maxWireVersion(topologyOrServer) {
  if (topologyOrServer) {
    if (topologyOrServer.loadBalanced) {
      // Since we do not have a monitor, we assume the load balanced server is always
      // pointed at the latest mongodb version. There is a risk that for on-prem
      // deployments that don't upgrade immediately that this could alert to the
      // application that a feature is available that is actually not.
      return constants_1.MAX_SUPPORTED_WIRE_VERSION;
    }

    if (topologyOrServer.hello) {
      return topologyOrServer.hello.maxWireVersion;
    }

    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {
      var lastHello = topologyOrServer.lastHello();

      if (lastHello) {
        return lastHello.maxWireVersion;
      }
    }

    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
      return topologyOrServer.description.maxWireVersion;
    }
  }

  return 0;
}

exports.maxWireVersion = maxWireVersion;
/**
 * Applies the function `eachFn` to each item in `arr`, in parallel.
 * @internal
 *
 * @param arr - An array of items to asynchronously iterate over
 * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.
 * @param callback - The callback called after every item has been iterated
 */

function eachAsync(arr, eachFn, callback) {
  arr = arr || [];
  var idx = 0;
  var awaiting = 0;

  for (idx = 0; idx < arr.length; ++idx) {
    awaiting++;
    eachFn(arr[idx], eachCallback);
  }

  if (awaiting === 0) {
    callback();
    return;
  }

  function eachCallback(err) {
    awaiting--;

    if (err) {
      callback(err);
      return;
    }

    if (idx === arr.length && awaiting <= 0) {
      callback();
    }
  }
}

exports.eachAsync = eachAsync;
/** @internal */

function arrayStrictEqual(arr, arr2) {
  if (!Array.isArray(arr) || !Array.isArray(arr2)) {
    return false;
  }

  return arr.length === arr2.length && arr.every(function (elt, idx) {
    return elt === arr2[idx];
  });
}

exports.arrayStrictEqual = arrayStrictEqual;
/** @internal */

function errorStrictEqual(lhs, rhs) {
  if (lhs === rhs) {
    return true;
  }

  if (!lhs || !rhs) {
    return lhs === rhs;
  }

  if (lhs == null && rhs != null || lhs != null && rhs == null) {
    return false;
  }

  if (lhs.constructor.name !== rhs.constructor.name) {
    return false;
  }

  if (lhs.message !== rhs.message) {
    return false;
  }

  return true;
}

exports.errorStrictEqual = errorStrictEqual;
/** @internal */

function makeStateMachine(stateTable) {
  return function stateTransition(target, newState) {
    var legalStates = stateTable[target.s.state];

    if (legalStates && legalStates.indexOf(newState) < 0) {
      throw new error_1.MongoRuntimeError("illegal state transition from [".concat(target.s.state, "] => [").concat(newState, "], allowed: [").concat(legalStates, "]"));
    }

    target.emit('stateChanged', target.s.state, newState);
    target.s.state = newState;
  };
}

exports.makeStateMachine = makeStateMachine;
/** @internal */

function now() {
  var hrtime = process.hrtime();
  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);
}

exports.now = now;
/** @internal */

function calculateDurationInMs(started) {
  if (typeof started !== 'number') {
    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');
  }

  var elapsed = now() - started;
  return elapsed < 0 ? 0 : elapsed;
}

exports.calculateDurationInMs = calculateDurationInMs;
/** @internal */

function hasAtomicOperators(doc) {
  if (Array.isArray(doc)) {
    var _iterator2 = _createForOfIteratorHelper(doc),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var document = _step2.value;

        if (hasAtomicOperators(document)) {
          return true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return false;
  }

  var keys = Object.keys(doc);
  return keys.length > 0 && keys[0][0] === '$';
}

exports.hasAtomicOperators = hasAtomicOperators;
/**
 * Merge inherited properties from parent into options, prioritizing values from options,
 * then values from parent.
 * @internal
 */

function resolveOptions(parent, options) {
  var _read_preference_1$Re;

  var result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction

  var session = options === null || options === void 0 ? void 0 : options.session;

  if (!(session !== null && session !== void 0 && session.inTransaction())) {
    var _read_concern_1$ReadC, _write_concern_1$Writ;

    var readConcern = (_read_concern_1$ReadC = read_concern_1.ReadConcern.fromOptions(options)) !== null && _read_concern_1$ReadC !== void 0 ? _read_concern_1$ReadC : parent === null || parent === void 0 ? void 0 : parent.readConcern;

    if (readConcern) {
      result.readConcern = readConcern;
    }

    var writeConcern = (_write_concern_1$Writ = write_concern_1.WriteConcern.fromOptions(options)) !== null && _write_concern_1$Writ !== void 0 ? _write_concern_1$Writ : parent === null || parent === void 0 ? void 0 : parent.writeConcern;

    if (writeConcern) {
      result.writeConcern = writeConcern;
    }
  }

  var readPreference = (_read_preference_1$Re = read_preference_1.ReadPreference.fromOptions(options)) !== null && _read_preference_1$Re !== void 0 ? _read_preference_1$Re : parent === null || parent === void 0 ? void 0 : parent.readPreference;

  if (readPreference) {
    result.readPreference = readPreference;
  }

  return result;
}

exports.resolveOptions = resolveOptions;

function isSuperset(set, subset) {
  set = Array.isArray(set) ? new Set(set) : set;
  subset = Array.isArray(subset) ? new Set(subset) : subset;

  var _iterator3 = _createForOfIteratorHelper(subset),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var elem = _step3.value;

      if (!set.has(elem)) {
        return false;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return true;
}

exports.isSuperset = isSuperset;
/**
 * Checks if the document is a Hello request
 * @internal
 */

function isHello(doc) {
  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
}

exports.isHello = isHello;
/** Returns the items that are uniquely in setA */

function setDifference(setA, setB) {
  var difference = new Set(setA);

  var _iterator4 = _createForOfIteratorHelper(setB),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var elem = _step4.value;
      difference["delete"](elem);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return difference;
}

exports.setDifference = setDifference;

var HAS_OWN = function HAS_OWN(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
};

function isRecord(value) {
  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  if (!isObject(value)) {
    return false;
  }

  var ctor = value.constructor;

  if (ctor && ctor.prototype) {
    if (!isObject(ctor.prototype)) {
      return false;
    } // Check to see if some method exists from the Object exists


    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {
      return false;
    }
  }

  if (requiredKeys) {
    var keys = Object.keys(value);
    return isSuperset(keys, requiredKeys);
  }

  return true;
}

exports.isRecord = isRecord;
/**
 * Make a deep copy of an object
 *
 * NOTE: This is not meant to be the perfect implementation of a deep copy,
 * but instead something that is good enough for the purposes of
 * command monitoring.
 */

function deepCopy(value) {
  if (value == null) {
    return value;
  } else if (Array.isArray(value)) {
    return value.map(function (item) {
      return deepCopy(item);
    });
  } else if (isRecord(value)) {
    var res = {};

    for (var key in value) {
      res[key] = deepCopy(value[key]);
    }

    return res;
  }

  var ctor = value.constructor;

  if (ctor) {
    switch (ctor.name.toLowerCase()) {
      case 'date':
        return new ctor(Number(value));

      case 'map':
        return new Map(value);

      case 'set':
        return new Set(value);

      case 'buffer':
        return Buffer.from(value);
    }
  }

  return value;
}

exports.deepCopy = deepCopy;
/**
 * A sequential list of items in a circularly linked list
 * @remarks
 * The head node is special, it is always defined and has a value of null.
 * It is never "included" in the list, in that, it is not returned by pop/shift or yielded by the iterator.
 * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.
 * New nodes are declared as object literals with keys always in the same order: next, prev, value.
 * @internal
 */

var List = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$iterator) {
  function List() {
    _classCallCheck(this, List);

    this.count = 0; // this is carefully crafted:
    // declaring a complete and consistently key ordered
    // object is beneficial to the runtime optimizations

    this.head = {
      next: null,
      prev: null,
      value: null
    };
    this.head.next = this.head;
    this.head.prev = this.head;
  }

  _createClass(List, [{
    key: "length",
    get: function get() {
      return this.count;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'List';
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return Array.from(this);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "head <=> ".concat(this.toArray().join(' <=> '), " <=> head");
    }
  }, {
    key: _Symbol$iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      var _iterator5, _step5, node;

      return _regeneratorRuntime().wrap(function value$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _iterator5 = _createForOfIteratorHelper(this.nodes());
            _context2.prev = 1;

            _iterator5.s();

          case 3:
            if ((_step5 = _iterator5.n()).done) {
              _context2.next = 9;
              break;
            }

            node = _step5.value;
            _context2.next = 7;
            return node.value;

          case 7:
            _context2.next = 3;
            break;

          case 9:
            _context2.next = 14;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](1);

            _iterator5.e(_context2.t0);

          case 14:
            _context2.prev = 14;

            _iterator5.f();

            return _context2.finish(14);

          case 17:
          case "end":
            return _context2.stop();
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "nodes",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function nodes() {
      var ptr, _ptr2, next;

      return _regeneratorRuntime().wrap(function nodes$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            ptr = this.head.next;

          case 1:
            if (!(ptr !== this.head)) {
              _context3.next = 8;
              break;
            }

            // Save next before yielding so that we make removing within iteration safe
            _ptr2 = ptr, next = _ptr2.next;
            _context3.next = 5;
            return ptr;

          case 5:
            ptr = next;
            _context3.next = 1;
            break;

          case 8:
          case "end":
            return _context3.stop();
        }
      }, nodes, this);
    })
    /** Insert at end of list */

  }, {
    key: "push",
    value: function push(value) {
      this.count += 1;
      var newNode = {
        next: this.head,
        prev: this.head.prev,
        value: value
      };
      this.head.prev.next = newNode;
      this.head.prev = newNode;
    }
    /** Inserts every item inside an iterable instead of the iterable itself */

  }, {
    key: "pushMany",
    value: function pushMany(iterable) {
      var _iterator6 = _createForOfIteratorHelper(iterable),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _value = _step6.value;
          this.push(_value);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /** Insert at front of list */

  }, {
    key: "unshift",
    value: function unshift(value) {
      this.count += 1;
      var newNode = {
        next: this.head.next,
        prev: this.head,
        value: value
      };
      this.head.next.prev = newNode;
      this.head.next = newNode;
    }
  }, {
    key: "remove",
    value: function remove(node) {
      if (node === this.head || this.length === 0) {
        return null;
      }

      this.count -= 1;
      var prevNode = node.prev;
      var nextNode = node.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      return node.value;
    }
    /** Removes the first node at the front of the list */

  }, {
    key: "shift",
    value: function shift() {
      return this.remove(this.head.next);
    }
    /** Removes the last node at the end of the list */

  }, {
    key: "pop",
    value: function pop() {
      return this.remove(this.head.prev);
    }
    /** Iterates through the list and removes nodes where filter returns true */

  }, {
    key: "prune",
    value: function prune(filter) {
      var _iterator7 = _createForOfIteratorHelper(this.nodes()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var node = _step7.value;

          if (filter(node.value)) {
            this.remove(node);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.count = 0;
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    /** Returns the first item in the list, does not remove */

  }, {
    key: "first",
    value: function first() {
      // If the list is empty, value will be the head's null
      return this.head.next.value;
    }
    /** Returns the last item in the list, does not remove */

  }, {
    key: "last",
    value: function last() {
      // If the list is empty, value will be the head's null
      return this.head.prev.value;
    }
  }]);

  return List;
}(Symbol.toStringTag, Symbol.iterator);

exports.List = List;
/**
 * A pool of Buffers which allow you to read them as if they were one
 * @internal
 */

var BufferPool = /*#__PURE__*/function () {
  function BufferPool() {
    _classCallCheck(this, BufferPool);

    this.buffers = new List();
    this.totalByteLength = 0;
  }

  _createClass(BufferPool, [{
    key: "length",
    get: function get() {
      return this.totalByteLength;
    }
    /** Adds a buffer to the internal buffer pool list */

  }, {
    key: "append",
    value: function append(buffer) {
      this.buffers.push(buffer);
      this.totalByteLength += buffer.length;
    }
    /**
     * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
     * otherwise return null. Size can be negative, caller should error check.
     */

  }, {
    key: "getInt32",
    value: function getInt32() {
      if (this.totalByteLength < 4) {
        return null;
      }

      var firstBuffer = this.buffers.first();

      if (firstBuffer != null && firstBuffer.byteLength >= 4) {
        return firstBuffer.readInt32LE(0);
      } // Unlikely case: an int32 is split across buffers.
      // Use read and put the returned buffer back on top


      var top4Bytes = this.read(4);
      var value = top4Bytes.readInt32LE(0); // Put it back.

      this.totalByteLength += 4;
      this.buffers.unshift(top4Bytes);
      return value;
    }
    /** Reads the requested number of bytes, optionally consuming them */

  }, {
    key: "read",
    value: function read(size) {
      if (typeof size !== 'number' || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      } // oversized request returns empty buffer


      if (size > this.totalByteLength) {
        return Buffer.alloc(0);
      } // We know we have enough, we just don't know how it is spread across chunks
      // TODO(NODE-4732): alloc API should change based on raw option


      var result = Buffer.allocUnsafe(size);

      for (var bytesRead = 0; bytesRead < size;) {
        var buffer = this.buffers.shift();

        if (buffer == null) {
          break;
        }

        var bytesRemaining = size - bytesRead;
        var bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
        var bytes = buffer.subarray(0, bytesReadable);
        result.set(bytes, bytesRead);
        bytesRead += bytesReadable;
        this.totalByteLength -= bytesReadable;

        if (bytesReadable < buffer.byteLength) {
          this.buffers.unshift(buffer.subarray(bytesReadable));
        }
      }

      return result;
    }
  }]);

  return BufferPool;
}();

exports.BufferPool = BufferPool;
/** @public */

var HostAddress = /*#__PURE__*/function (_Symbol$for) {
  function HostAddress(hostString) {
    _classCallCheck(this, HostAddress);

    this.host = undefined;
    this.port = undefined;
    this.socketPath = undefined;
    this.isIPv6 = false;
    var escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts

    if (escapedHost.endsWith('.sock')) {
      // heuristically determine if we're working with a domain socket
      this.socketPath = decodeURIComponent(escapedHost);
      return;
    }

    var urlString = "iLoveJS://".concat(escapedHost);
    var url;

    try {
      url = new url_1.URL(urlString);
    } catch (urlError) {
      var runtimeError = new error_1.MongoRuntimeError("Unable to parse ".concat(escapedHost, " with URL"));
      runtimeError.cause = urlError;
      throw runtimeError;
    }

    var hostname = url.hostname;
    var port = url.port;
    var normalized = decodeURIComponent(hostname).toLowerCase();

    if (normalized.startsWith('[') && normalized.endsWith(']')) {
      this.isIPv6 = true;
      normalized = normalized.substring(1, hostname.length - 1);
    }

    this.host = normalized.toLowerCase();

    if (typeof port === 'number') {
      this.port = port;
    } else if (typeof port === 'string' && port !== '') {
      this.port = Number.parseInt(port, 10);
    } else {
      this.port = 27017;
    }

    if (this.port === 0) {
      throw new error_1.MongoParseError('Invalid port (zero) with hostname');
    }

    Object.freeze(this);
  }

  _createClass(HostAddress, [{
    key: _Symbol$for,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new HostAddress('".concat(this.toString(), "')");
    }
  }, {
    key: "toString",
    value: function toString() {
      if (typeof this.host === 'string') {
        if (this.isIPv6) {
          return "[".concat(this.host, "]:").concat(this.port);
        }

        return "".concat(this.host, ":").concat(this.port);
      }

      return "".concat(this.socketPath);
    }
  }, {
    key: "toHostPort",
    value: function toHostPort() {
      var _this$host, _this$port;

      if (this.socketPath) {
        return {
          host: this.socketPath,
          port: 0
        };
      }

      var host = (_this$host = this.host) !== null && _this$host !== void 0 ? _this$host : '';
      var port = (_this$port = this.port) !== null && _this$port !== void 0 ? _this$port : 0;
      return {
        host: host,
        port: port
      };
    }
  }], [{
    key: "fromString",
    value: function fromString(s) {
      return new HostAddress(s);
    }
  }, {
    key: "fromHostPort",
    value: function fromHostPort(host, port) {
      if (host.includes(':')) {
        host = "[".concat(host, "]"); // IPv6 address
      }

      return HostAddress.fromString("".concat(host, ":").concat(port));
    }
  }, {
    key: "fromSrvRecord",
    value: function fromSrvRecord(_ref) {
      var name = _ref.name,
          port = _ref.port;
      return HostAddress.fromHostPort(name, port);
    }
  }]);

  return HostAddress;
}(Symbol["for"]('nodejs.util.inspect.custom'));

exports.HostAddress = HostAddress;
exports.DEFAULT_PK_FACTORY = {
  // We prefer not to rely on ObjectId having a createPk method
  createPk: function createPk() {
    return new bson_1.ObjectId();
  }
};
/**
 * When the driver used emitWarning the code will be equal to this.
 * @public
 *
 * @example
 * ```ts
 * process.on('warning', (warning) => {
 *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')
 * })
 * ```
 */

exports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';
/** @internal */

function emitWarning(message) {
  return process.emitWarning(message, {
    code: exports.MONGODB_WARNING_CODE
  });
}

exports.emitWarning = emitWarning;
var emittedWarnings = new Set();
/**
 * Will emit a warning once for the duration of the application.
 * Uses the message to identify if it has already been emitted
 * so using string interpolation can cause multiple emits
 * @internal
 */

function emitWarningOnce(message) {
  if (!emittedWarnings.has(message)) {
    emittedWarnings.add(message);
    return emitWarning(message);
  }
}

exports.emitWarningOnce = emitWarningOnce;
/**
 * Takes a JS object and joins the values into a string separated by ', '
 */

function enumToString(en) {
  return Object.values(en).join(', ');
}

exports.enumToString = enumToString;
/**
 * Determine if a server supports retryable writes.
 *
 * @internal
 */

function supportsRetryableWrites(server) {
  if (!server) {
    return false;
  }

  if (server.loadBalanced) {
    // Loadbalanced topologies will always support retry writes
    return true;
  }

  if (server.description.logicalSessionTimeoutMinutes != null) {
    // that supports sessions
    if (server.description.type !== common_1.ServerType.Standalone) {
      // and that is not a standalone
      return true;
    }
  }

  return false;
}

exports.supportsRetryableWrites = supportsRetryableWrites;
/**
 * Fisher–Yates Shuffle
 *
 * Reference: https://bost.ocks.org/mike/shuffle/
 * @param sequence - items to be shuffled
 * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.
 */

function shuffle(sequence) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var items = Array.from(sequence); // shallow copy in order to never shuffle the input

  if (limit > items.length) {
    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');
  }

  var remainingItemsToShuffle = items.length;
  var lowerBound = limit % items.length === 0 ? 1 : items.length - limit;

  while (remainingItemsToShuffle > lowerBound) {
    // Pick a remaining element
    var randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
    remainingItemsToShuffle -= 1; // And swap it with the current element

    var swapHold = items[remainingItemsToShuffle];
    items[remainingItemsToShuffle] = items[randomIndex];
    items[randomIndex] = swapHold;
  }

  return limit % items.length === 0 ? items : items.slice(lowerBound);
}

exports.shuffle = shuffle; // TODO(NODE-4936): read concern eligibility for commands should be codified in command construction
// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern

function commandSupportsReadConcern(command, options) {
  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
    return true;
  }

  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {
    return true;
  }

  return false;
}

exports.commandSupportsReadConcern = commandSupportsReadConcern;
/** A utility function to get the instance of mongodb-client-encryption, if it exists. */

function getMongoDBClientEncryption() {
  var mongodbClientEncryption = null; // NOTE(NODE-4254): This is to get around the circular dependency between
  // mongodb-client-encryption and the driver in the test scenarios.

  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {
    try {
      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block
      // Cannot be moved to helper utility function, bundlers search and replace the actual require call
      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed
      mongodbClientEncryption = __webpack_require__(5616)(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);
    } catch (_unused) {// ignore
    }
  } else {
    try {
      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block
      // Cannot be moved to helper utility function, bundlers search and replace the actual require call
      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed
      mongodbClientEncryption = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'mongodb-client-encryption'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    } catch (_unused2) {// ignore
    }
  }

  return mongodbClientEncryption;
}

exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
/**
 * Compare objectIds. `null` is always less
 * - `+1 = oid1 is greater than oid2`
 * - `-1 = oid1 is less than oid2`
 * - `+0 = oid1 is equal oid2`
 */

function compareObjectId(oid1, oid2) {
  if (oid1 == null && oid2 == null) {
    return 0;
  }

  if (oid1 == null) {
    return -1;
  }

  if (oid2 == null) {
    return 1;
  }

  return exports.ByteUtils.compare(oid1.id, oid2.id);
}

exports.compareObjectId = compareObjectId;

function parseInteger(value) {
  if (typeof value === 'number') return Math.trunc(value);
  var parsedValue = Number.parseInt(String(value), 10);
  return Number.isNaN(parsedValue) ? null : parsedValue;
}

exports.parseInteger = parseInteger;

function parseUnsignedInteger(value) {
  var parsedInt = parseInteger(value);
  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
}

exports.parseUnsignedInteger = parseUnsignedInteger;
/**
 * Determines whether a provided address matches the provided parent domain.
 *
 * If a DNS server were to become compromised SRV records would still need to
 * advertise addresses that are under the same domain as the srvHost.
 *
 * @param address - The address to check against a domain
 * @param srvHost - The domain to check the provided address against
 * @returns Whether the provided address matches the parent domain
 */

function matchesParentDomain(address, srvHost) {
  // Remove trailing dot if exists on either the resolved address or the srv hostname
  var normalizedAddress = address.endsWith('.') ? address.slice(0, address.length - 1) : address;
  var normalizedSrvHost = srvHost.endsWith('.') ? srvHost.slice(0, srvHost.length - 1) : srvHost;
  var allCharacterBeforeFirstDot = /^.*?\./; // Remove all characters before first dot
  // Add leading dot back to string so
  //   an srvHostDomain = '.trusted.site'
  //   will not satisfy an addressDomain that endsWith '.fake-trusted.site'

  var addressDomain = ".".concat(normalizedAddress.replace(allCharacterBeforeFirstDot, ''));
  var srvHostDomain = ".".concat(normalizedSrvHost.replace(allCharacterBeforeFirstDot, ''));
  return addressDomain.endsWith(srvHostDomain);
}

exports.matchesParentDomain = matchesParentDomain;

function request(_x) {
  return _request.apply(this, arguments);
}

function _request() {
  _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uri) {
    var options,
        _args4 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
          return _context4.abrupt("return", new Promise(function (resolve, reject) {
            var requestOptions = _objectSpread(_objectSpread({
              method: 'GET',
              timeout: 10000,
              json: true
            }, url.parse(uri)), options);

            var req = http.request(requestOptions, function (res) {
              res.setEncoding('utf8');
              var data = '';
              res.on('data', function (d) {
                data += d;
              });
              res.once('end', function () {
                if (options.json === false) {
                  resolve(data);
                  return;
                }

                try {
                  var parsed = JSON.parse(data);
                  resolve(parsed);
                } catch (_unused3) {
                  // TODO(NODE-3483)
                  reject(new error_1.MongoRuntimeError("Invalid JSON response: \"".concat(data, "\"")));
                }
              });
            });
            req.once('timeout', function () {
              return req.destroy(new error_1.MongoNetworkTimeoutError("Network request to ".concat(uri, " timed out after ").concat(options.timeout, " ms")));
            });
            req.once('error', function (error) {
              return reject(error);
            });
            req.end();
          }));

        case 2:
        case "end":
          return _context4.stop();
      }
    }, _callee2);
  }));
  return _request.apply(this, arguments);
}

exports.request = request;

/***/ }),

/***/ 6916:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WriteConcern = exports.WRITE_CONCERN_KEYS = void 0;
exports.WRITE_CONCERN_KEYS = ['w', 'wtimeout', 'j', 'journal', 'fsync'];
/**
 * A MongoDB WriteConcern, which describes the level of acknowledgement
 * requested from MongoDB for write operations.
 * @public
 *
 * @see https://www.mongodb.com/docs/manual/reference/write-concern/
 */

var WriteConcern = /*#__PURE__*/function () {
  /**
   * Constructs a WriteConcern from the write concern properties.
   * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
   * @param wtimeoutMS - specify a time limit to prevent write operations from blocking indefinitely
   * @param journal - request acknowledgment that the write operation has been written to the on-disk journal
   * @param fsync - equivalent to the j option. Is deprecated and will be removed in the next major version.
   */
  function WriteConcern(w, wtimeoutMS, journal, fsync) {
    _classCallCheck(this, WriteConcern);

    if (w != null) {
      if (!Number.isNaN(Number(w))) {
        this.w = Number(w);
      } else {
        this.w = w;
      }
    }

    if (wtimeoutMS != null) {
      this.wtimeoutMS = this.wtimeout = wtimeoutMS;
    }

    if (journal != null) {
      this.journal = this.j = journal;
    }

    if (fsync != null) {
      this.journal = this.j = fsync ? true : false;
    }
  }
  /**
   * Apply a write concern to a command document. Will modify and return the command.
   */


  _createClass(WriteConcern, null, [{
    key: "apply",
    value: function apply(command, writeConcern) {
      var wc = {}; // The write concern document sent to the server has w/wtimeout/j fields.

      if (writeConcern.w != null) wc.w = writeConcern.w;
      if (writeConcern.wtimeoutMS != null) wc.wtimeout = writeConcern.wtimeoutMS;
      if (writeConcern.journal != null) wc.j = writeConcern.j;
      command.writeConcern = wc;
      return command;
    }
    /** Construct a WriteConcern given an options object. */

  }, {
    key: "fromOptions",
    value: function fromOptions(options, inherit) {
      var _inherit;

      if (options == null) return undefined;
      inherit = (_inherit = inherit) !== null && _inherit !== void 0 ? _inherit : {};
      var opts;

      if (typeof options === 'string' || typeof options === 'number') {
        opts = {
          w: options
        };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }

      var parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;

      var _parentOpts$opts = _objectSpread(_objectSpread({}, parentOpts), opts),
          _parentOpts$opts$w = _parentOpts$opts.w,
          w = _parentOpts$opts$w === void 0 ? undefined : _parentOpts$opts$w,
          _parentOpts$opts$wtim = _parentOpts$opts.wtimeout,
          wtimeout = _parentOpts$opts$wtim === void 0 ? undefined : _parentOpts$opts$wtim,
          _parentOpts$opts$j = _parentOpts$opts.j,
          j = _parentOpts$opts$j === void 0 ? undefined : _parentOpts$opts$j,
          _parentOpts$opts$fsyn = _parentOpts$opts.fsync,
          fsync = _parentOpts$opts$fsyn === void 0 ? undefined : _parentOpts$opts$fsyn,
          _parentOpts$opts$jour = _parentOpts$opts.journal,
          journal = _parentOpts$opts$jour === void 0 ? undefined : _parentOpts$opts$jour,
          _parentOpts$opts$wtim2 = _parentOpts$opts.wtimeoutMS,
          wtimeoutMS = _parentOpts$opts$wtim2 === void 0 ? undefined : _parentOpts$opts$wtim2;

      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout !== null && wtimeout !== void 0 ? wtimeout : wtimeoutMS, j !== null && j !== void 0 ? j : journal, fsync);
      }

      return undefined;
    }
  }]);

  return WriteConcern;
}();

exports.WriteConcern = WriteConcern;

/***/ }),

/***/ 1664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6512)


/***/ }),

/***/ 1693:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"5.7.0"};

/***/ })

};
;